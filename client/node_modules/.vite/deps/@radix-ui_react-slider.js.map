{
  "version": 3,
  "sources": ["../../@radix-ui/number/dist/packages/core/number/src/index.ts", "../../@radix-ui/number/dist/packages/core/number/src/number.ts", "../../@radix-ui/react-slider/dist/packages/react/slider/src/index.ts", "../../@radix-ui/react-slider/dist/packages/react/slider/src/Slider.tsx"],
  "sourcesContent": ["export { clamp } from './number';\n", "function clamp(value: number, [min, max]: [number, number]): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport { clamp };\n", "export {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n} from './Slider';\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps } from './Slider';\n", "import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top';\nconst BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  disabled?: boolean;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n  onValueCommit?(value: number[]): void;\n  inverted?: boolean;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      onValueCommit = () => {},\n      inverted = false,\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = slider ? Boolean(slider.closest('form')) : true;\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n    const valuesBeforeSlideStartRef = React.useRef(values);\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function handleSlideEnd() {\n      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n      const nextValue = values[valueIndexToChangeRef.current];\n      const hasChanged = nextValue !== prevValue;\n      if (hasChanged) onValueCommit(values);\n    }\n\n    function updateValues(value: number, atIndex: number, { commit } = { commit: false }) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          const hasChanged = String(nextValues) !== String(prevValues);\n          if (hasChanged && commit) onValueCommit(nextValues);\n          return hasChanged ? nextValues : prevValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={composedRefs}\n              onPointerDown={composeEventHandlers(sliderProps.onPointerDown, () => {\n                if (!disabled) valuesBeforeSlideStartRef.current = values;\n              })}\n              min={min}\n              max={max}\n              inverted={inverted}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onSlideEnd={disabled ? undefined : handleSlideEnd}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0, { commit: true })}\n              onEndKeyDown={() =>\n                !disabled && updateValues(max, values.length - 1, { commit: true })\n              }\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex];\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex, { commit: true });\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n        {isFormControl &&\n          values.map((value, index) => (\n            <BubbleInput\n              key={index}\n              name={name ? name + (values.length > 1 ? '[]' : '') : undefined}\n              value={value}\n            />\n          ))}\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\ntype Side = 'top' | 'right' | 'bottom' | 'left';\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: Side;\n  endEdge: Side;\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  inverted: boolean;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onSlideEnd?(): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      dir,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<ClientRect>();\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n    const isSlidingFromLeft = (isDirectionLTR && !inverted) || (!isDirectionLTR && inverted);\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isSlidingFromLeft ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromLeft ? 'left' : 'right'}\n        endEdge={isSlidingFromLeft ? 'right' : 'left'}\n        direction={isSlidingFromLeft ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          dir={direction}\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<ClientRect>();\n    const isSlidingFromBottom = !inverted;\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = isSlidingFromBottom ? [max, min] : [min, max];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromBottom ? 'bottom' : 'top'}\n        endEdge={isSlidingFromBottom ? 'top' : 'bottom'}\n        size=\"height\"\n        direction={isSlidingFromBottom ? 1 : -1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst BubbleInput = (props: Radix.ComponentPropsWithoutRef<'input'>) => {\n  const { value, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevValue = usePrevious(value);\n\n  // Bubble value change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event('input', { bubbles: true });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n\n  /**\n   * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n   * wrap it will not be able to access its value via the FormData API.\n   *\n   * We purposefully do not add the `value` attribute here to allow the value\n   * to be set programatically and bubble to any parent form `onChange` event.\n   * Adding the `value` will cause React to consider the programatic\n   * dispatch a duplicate and it will get swallowed.\n   */\n  return <input style={{ display: 'none' }} {...inputProps} ref={ref} defaultValue={value} />;\n};\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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",
  "names": ["clamp", "value", "min", "max", "Math", "PAGE_KEYS", "ARROW_KEYS", "BACK_KEYS", "SLIDER_NAME", "Collection", "useCollection", "createCollectionScope", "createCollection", "createSliderContext", "createSliderScope", "createContextScope", "SliderProvider", "useSliderContext", "Slider", "React", "props", "forwardedRef", "min", "value", "sliderProps", "slider", "setSlider", "composedRefs", "useComposedRefs", "node", "thumbRefs", "Set", "valueIndexToChangeRef", "isHorizontal", "orientation", "isFormControl", "Boolean", "closest", "SliderOrientation", "SliderHorizontal", "SliderVertical", "values", "setValues", "useControllableState", "prop", "defaultProp", "defaultValue", "onChange", "thumbs", "current", "focus", "onValueChange", "valuesBeforeSlideStartRef", "handleSlideStart", "closestIndex", "getClosestValueIndex", "updateValues", "handleSlideMove", "handleSlideEnd", "prevValue", "nextValue", "hasChanged", "onValueCommit", "atIndex", "commit", "decimalCount", "getDecimalCount", "step", "snapToStep", "roundValue", "Math", "round", "clamp", "max", "prevValues", "nextValues", "getNextSortedValues", "hasMinStepsBetweenValues", "minStepsBetweenThumbs", "indexOf", "String", "$g1Vy2$createElement", "__scopeSlider", "disabled", "undefined", "composeEventHandlers", "onPointerDown", "length", "direction", "stepDirection", "isPageKey", "includes", "event", "key", "isSkipKey", "shiftKey", "multiplier", "stepInDirection", "map", "index", "name", "SliderOrientationProvider", "useSliderOrientationContext", "startEdge", "endEdge", "size", "rectRef", "useDirection", "dir", "isDirectionLTR", "isSlidingFromLeft", "inverted", "getValueFromPointer", "pointerPosition", "rect", "getBoundingClientRect", "input", "width", "output", "linearScale", "left", "style", "clientX", "onSlideStart", "onSlideMove", "onSlideEnd", "slideDirection", "isBackKey", "onStepKeyDown", "sliderRef", "ref", "isSlidingFromBottom", "height", "top", "clientY", "SliderImpl", "context", "onKeyDown", "onHomeKeyDown", "preventDefault", "onEndKeyDown", "concat", "target", "setPointerCapture", "pointerId", "has", "onPointerMove", "hasPointerCapture", "onPointerUp", "releasePointerCapture", "TRACK_NAME", "SliderTrack", "trackProps", "RANGE_NAME", "SliderRange", "rangeProps", "valuesCount", "percentages", "convertValueToPercentage", "offsetStart", "offsetEnd", "THUMB_NAME", "SliderThumb", "getItems", "thumb", "setThumb", "findIndex", "item", "SliderThumbImpl", "thumbProps", "useSize", "percent", "label", "getLabel", "orientationSize", "thumbInBoundsOffset", "getThumbInBoundsOffset", "add", "delete", "transform", "position", "display", "onFocus", "BubbleInput", "inputProps", "usePrevious", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "setValue", "set", "Event", "bubbles", "call", "dispatchEvent", "sort", "a", "b", "maxSteps", "percentPerStep", "percentage", "totalValues", "distances", "abs", "closestDistance", "halfWidth", "halfPercent", "offset", "getStepsBetweenValues", "slice", "minStepsBetweenValues", "stepsBetweenValues", "actualMinStepsBetweenValues", "ratio", "split", "rounder", "pow", "Root", "Track", "Range", "Thumb"]
}
