{
  "version": 3,
  "sources": ["../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/index.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useId.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useLayoutEffect.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useValueEffect.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useEffectEvent.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/chain.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/domHelpers.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/mergeProps.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/mergeRefs.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/filterDOMProps.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/focusWithoutScrolling.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/getOffset.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/openLink.tsx", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/platform.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/runAfterTransition.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDrag1D.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useGlobalListeners.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useLabels.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useObjectRef.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useUpdateEffect.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useResizeObserver.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useSyncRef.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/getScrollParent.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useViewportSize.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDescription.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useEvent.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/scrollIntoView.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/isVirtualEvent.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDeepMemo.ts", "../../../node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useFormReset.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/index.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/Pressable.tsx", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/usePress.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/textSelection.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/context.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/PressResponder.tsx", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocus.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/utils.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocusVisible.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocusWithin.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useHover.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useInteractOutside.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useKeyboard.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/createEventHandler.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useMove.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useScrollWheel.ts", "../../../node_modules/@react-aria/focus/node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useLongPress.ts", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/index.ts", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/FocusScope.tsx", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/focusSafely.ts", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/isElementVisible.ts", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/FocusRing.tsx", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/useFocusRing.ts", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/useFocusable.tsx", "../../../node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/useHasTabbableChild.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/index.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useId.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useLayoutEffect.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useValueEffect.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useEffectEvent.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/chain.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/domHelpers.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/mergeProps.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/mergeRefs.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/filterDOMProps.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/focusWithoutScrolling.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/getOffset.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/openLink.tsx", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/platform.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/runAfterTransition.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDrag1D.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useGlobalListeners.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useLabels.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useObjectRef.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useUpdateEffect.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useResizeObserver.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useSyncRef.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/getScrollParent.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useViewportSize.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDescription.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useEvent.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/scrollIntoView.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/isVirtualEvent.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useDeepMemo.ts", "../../../node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/packages/@react-aria/utils/src/useFormReset.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/index.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/Pressable.tsx", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/usePress.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/textSelection.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/context.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/PressResponder.tsx", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocus.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/utils.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocusVisible.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useFocusWithin.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useHover.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useInteractOutside.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useKeyboard.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/createEventHandler.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useMove.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useScrollWheel.ts", "../../../node_modules/@react-aria/interactions/dist/packages/@react-aria/interactions/src/useLongPress.ts", "../src/components/button/button.tsx", "../src/hooks/use-active-press.tsx", "../src/utils/env.ts", "../src/utils/owner.ts", "../src/hooks/use-disposables.ts", "../src/utils/micro-task.ts", "../src/utils/disposables.ts", "../src/hooks/use-event.ts", "../src/hooks/use-latest-value.ts", "../src/hooks/use-iso-morphic-effect.ts", "../src/internal/disabled.tsx", "../src/utils/render.ts", "../src/utils/class-names.ts", "../src/utils/match.ts", "../src/components/checkbox/checkbox.tsx", "../src/hooks/use-controllable.ts", "../src/hooks/use-id.ts", "../src/hooks/use-server-handoff-complete.ts", "../src/internal/form-fields.tsx", "../src/utils/form.ts", "../src/internal/hidden.tsx", "../src/internal/id.tsx", "../src/utils/bugs.ts", "../src/components/description/description.tsx", "../src/hooks/use-sync-refs.ts", "../src/components/label/label.tsx", "../../../node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs", "../../../node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs", "../../../node_modules/@tanstack/virtual-core/src/utils.ts", "../../../node_modules/@tanstack/virtual-core/src/index.ts", "../../../node_modules/@tanstack/react-virtual/src/index.tsx", "../src/components/combobox/combobox.tsx", "../src/hooks/use-by-comparator.ts", "../src/hooks/use-outside-click.ts", "../src/utils/focus-management.ts", "../src/utils/platform.ts", "../src/hooks/use-document-event.ts", "../src/hooks/use-window-event.ts", "../src/hooks/use-owner.ts", "../src/hooks/use-resolve-button-type.ts", "../src/hooks/use-tracked-pointer.ts", "../src/hooks/use-tree-walker.ts", "../src/hooks/use-watch.ts", "../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js", "../../../node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs", "../node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.esm.js", "../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs", "../src/internal/floating.tsx", "../src/internal/open-closed.tsx", "../src/utils/document-ready.ts", "../src/utils/active-element-history.ts", "../src/utils/calculate-active-index.ts", "../src/components/data-interactive/data-interactive.tsx", "../src/components/dialog/dialog.tsx", "../src/use-sync-external-store-shim/index.ts", "../src/use-sync-external-store-shim/useSyncExternalStoreShimClient.ts", "../src/use-sync-external-store-shim/useSyncExternalStoreShimServer.ts", "../src/hooks/use-store.ts", "../src/utils/store.ts", "../src/hooks/document-overflow/adjust-scrollbar-padding.ts", "../src/hooks/document-overflow/handle-ios-locking.ts", "../src/hooks/document-overflow/prevent-scroll.ts", "../src/hooks/document-overflow/overflow-store.ts", "../src/hooks/document-overflow/use-document-overflow.ts", "../src/hooks/use-event-listener.ts", "../src/hooks/use-inert.tsx", "../src/hooks/use-is-touch-device.ts", "../src/hooks/use-root-containers.tsx", "../src/internal/portal-force-root.tsx", "../src/internal/stack-context.tsx", "../src/components/focus-trap/focus-trap.tsx", "../src/hooks/use-is-mounted.ts", "../src/hooks/use-on-unmount.ts", "../src/hooks/use-tab-direction.ts", "../src/components/portal/portal.tsx", "../src/components/disclosure/disclosure.tsx", "../src/utils/start-transition.ts", "../src/components/field/field.tsx", "../src/components/fieldset/fieldset.tsx", "../src/components/input/input.tsx", "../src/components/legend/legend.tsx", "../src/components/listbox/listbox.tsx", "../src/hooks/use-computed.ts", "../src/hooks/use-did-element-move.ts", "../src/hooks/use-element-size.ts", "../src/hooks/use-text-value.ts", "../src/utils/get-text-value.ts", "../src/internal/modal.tsx", "../src/components/menu/menu.tsx", "../src/components/popover/popover.tsx", "../src/components/radio-group/radio-group.tsx", "../src/components/select/select.tsx", "../src/components/switch/switch.tsx", "../src/components/tabs/tabs.tsx", "../src/internal/focus-sentinel.tsx", "../src/utils/stable-collection.tsx", "../src/components/textarea/textarea.tsx", "../src/components/transition/transition.tsx", "../src/hooks/use-flags.ts", "../src/utils/once.ts", "../src/components/transition/utils/transition.ts", "../src/hooks/use-transition.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useId, mergeIds, useSlotId} from './useId';\nexport {chain} from './chain';\nexport {getOwnerDocument, getOwnerWindow} from './domHelpers';\nexport {mergeProps} from './mergeProps';\nexport {mergeRefs} from './mergeRefs';\nexport {filterDOMProps} from './filterDOMProps';\nexport {focusWithoutScrolling} from './focusWithoutScrolling';\nexport {getOffset} from './getOffset';\nexport {openLink, getSyntheticLinkProps, RouterProvider, shouldClientNavigate, useRouter} from './openLink';\nexport {runAfterTransition} from './runAfterTransition';\nexport {useDrag1D} from './useDrag1D';\nexport {useGlobalListeners} from './useGlobalListeners';\nexport {useLabels} from './useLabels';\nexport {useObjectRef} from './useObjectRef';\nexport {useUpdateEffect} from './useUpdateEffect';\nexport {useLayoutEffect} from './useLayoutEffect';\nexport {useResizeObserver} from './useResizeObserver';\nexport {useSyncRef} from './useSyncRef';\nexport {getScrollParent, isScrollable} from './getScrollParent';\nexport {useViewportSize} from './useViewportSize';\nexport {useDescription} from './useDescription';\nexport {isMac, isIPhone, isIPad, isIOS, isAppleDevice, isWebKit, isChrome, isAndroid, isFirefox} from './platform';\nexport {useEvent} from './useEvent';\nexport {useValueEffect} from './useValueEffect';\nexport {scrollIntoView, scrollIntoViewport} from './scrollIntoView';\nexport {clamp, snapValueToStep} from '@react-stately/utils';\nexport {isVirtualClick, isVirtualPointerEvent} from './isVirtualEvent';\nexport {useEffectEvent} from './useEffectEvent';\nexport {useDeepMemo} from './useDeepMemo';\nexport {useFormReset} from './useFormReset';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\nimport {useSSRSafeId} from '@react-aria/ssr';\nimport {useValueEffect} from './';\n\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet canUseDOM = Boolean(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nlet idsUpdaterMap: Map<string, (v: string) => void> = new Map();\n\n/**\n * If a default is not provided, generate an id.\n * @param defaultId - Default component id.\n */\nexport function useId(defaultId?: string): string {\n  let [value, setValue] = useState(defaultId);\n  let nextId = useRef(null);\n\n  let res = useSSRSafeId(value);\n\n  let updateValue = useCallback((val) => {\n    nextId.current = val;\n  }, []);\n\n  if (canUseDOM) {\n    idsUpdaterMap.set(res, updateValue);\n  }\n\n  useLayoutEffect(() => {\n    let r = res;\n    return () => {\n      idsUpdaterMap.delete(r);\n    };\n  }, [res]);\n\n  // This cannot cause an infinite loop because the ref is updated first.\n  // eslint-disable-next-line\n  useEffect(() => {\n    let newId = nextId.current;\n    if (newId) {\n      nextId.current = null;\n      setValue(newId);\n    }\n  });\n\n  return res;\n}\n\n/**\n * Merges two ids.\n * Different ids will trigger a side-effect and re-render components hooked up with `useId`.\n */\nexport function mergeIds(idA: string, idB: string): string {\n  if (idA === idB) {\n    return idA;\n  }\n\n  let setIdA = idsUpdaterMap.get(idA);\n  if (setIdA) {\n    setIdA(idB);\n    return idB;\n  }\n\n  let setIdB = idsUpdaterMap.get(idB);\n  if (setIdB) {\n    setIdB(idA);\n    return idA;\n  }\n\n  return idB;\n}\n\n/**\n * Used to generate an id, and after render, check if that id is rendered so we know\n * if we can use it in places such as labelledby.\n * @param depArray - When to recalculate if the id is in the DOM.\n */\nexport function useSlotId(depArray: ReadonlyArray<any> = []): string {\n  let id = useId();\n  let [resolvedId, setResolvedId] = useValueEffect(id);\n  let updateId = useCallback(() => {\n    setResolvedId(function *() {\n      yield id;\n\n      yield document.getElementById(id) ? id : undefined;\n    });\n  }, [id, setResolvedId]);\n\n  useLayoutEffect(updateId, [id, updateId, ...depArray]);\n\n  return resolvedId;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React from 'react';\n\n// During SSR, React emits a warning when calling useLayoutEffect.\n// Since neither useLayoutEffect nor useEffect run on the server,\n// we can suppress this by replace it with a noop on the server.\nexport const useLayoutEffect = typeof document !== 'undefined'\n  ? React.useLayoutEffect\n  : () => {};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Dispatch, useRef, useState} from 'react';\nimport {useEffectEvent, useLayoutEffect} from './';\n\ntype SetValueAction<S> = (prev: S) => Generator<any, void, unknown>;\n\n// This hook works like `useState`, but when setting the value, you pass a generator function\n// that can yield multiple values. Each yielded value updates the state and waits for the next\n// layout effect, then continues the generator. This allows sequential updates to state to be\n// written linearly.\nexport function useValueEffect<S>(defaultValue: S | (() => S)): [S, Dispatch<SetValueAction<S>>] {\n  let [value, setValue] = useState(defaultValue);\n  let effect = useRef(null);\n\n  // Store the function in a ref so we can always access the current version\n  // which has the proper `value` in scope.\n  let nextRef = useEffectEvent(() => {\n    // Run the generator to the next yield.\n    let newValue = effect.current.next();\n\n    // If the generator is done, reset the effect.\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n\n    // If the value is the same as the current value,\n    // then continue to the next yield. Otherwise,\n    // set the value in state and wait for the next layout effect.\n    if (value === newValue.value) {\n      nextRef();\n    } else {\n      setValue(newValue.value);\n    }\n  });\n\n  useLayoutEffect(() => {\n    // If there is an effect currently running, continue to the next yield.\n    if (effect.current) {\n      nextRef();\n    }\n  });\n\n  let queue = useEffectEvent(fn => {\n    effect.current = fn(value);\n    nextRef();\n  });\n\n  return [value, queue];\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\n\nexport function useEffectEvent<T extends Function>(fn: T): T {\n  const ref = useRef<T | null>(null);\n  useLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  // @ts-ignore\n  return useCallback<T>((...args) => {\n    const f = ref.current!;\n    return f(...args);\n  }, []);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Calls all functions in the order they were chained with the same arguments.\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (let callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n", "export const getOwnerDocument = (el: Element | null | undefined): Document => {\n  return el?.ownerDocument ?? document;\n};\n\nexport const getOwnerWindow = (\n  el: (Window & typeof global) | Element | null | undefined\n): Window & typeof global => {\n  if (el && 'window' in el && el.window === el) {\n    return el;\n  }\n\n  const doc = getOwnerDocument(el as Element | null | undefined);\n  return doc.defaultView || window;\n};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain} from './chain';\nimport clsx from 'clsx';\nimport {mergeIds} from './useId';\n\ninterface Props {\n  [key: string]: any\n}\n\ntype PropsArg = Props | null | undefined;\n\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? NullToObject<V> : never;\ntype NullToObject<T> = T extends (null | undefined) ? {} : T;\n// eslint-disable-next-line no-undef, @typescript-eslint/no-unused-vars\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n */\nexport function mergeProps<T extends PropsArg[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  let result: Props = {...args[0]};\n  for (let i = 1; i < args.length; i++) {\n    let props = args[i];\n    for (let key in props) {\n      let a = result[key];\n      let b = props[key];\n\n      // Chain events\n      if (\n        typeof a === 'function' &&\n        typeof b === 'function' &&\n        // This is a lot faster than a regex.\n        key[0] === 'o' &&\n        key[1] === 'n' &&\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\n        key.charCodeAt(2) <= /* 'Z' */ 90\n      ) {\n        result[key] = chain(a, b);\n\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        (key === 'className' || key === 'UNSAFE_className') &&\n        typeof a === 'string' &&\n        typeof b === 'string'\n      ) {\n        result[key] = clsx(a, b);\n      } else if (key === 'id' && a && b) {\n        result.id = mergeIds(a, b);\n        // Override others\n      } else {\n        result[key] = b !== undefined ? b : a;\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ForwardedRef} from 'react';\n\n/**\n * Merges multiple refs into one. Works with either callback or object refs.\n */\nexport function mergeRefs<T>(...refs: ForwardedRef<T>[]): ForwardedRef<T> {\n  if (refs.length === 1) {\n    return refs[0];\n  }\n\n  return (value: T) => {\n    for (let ref of refs) {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMProps, LinkDOMProps} from '@react-types/shared';\n\nconst DOMPropNames = new Set([\n  'id'\n]);\n\nconst labelablePropNames = new Set([\n  'aria-label',\n  'aria-labelledby',\n  'aria-describedby',\n  'aria-details'\n]);\n\n// See LinkDOMProps in dom.d.ts.\nconst linkPropNames = new Set([\n  'href',\n  'target',\n  'rel',\n  'download',\n  'ping',\n  'referrerPolicy'\n]);\n\ninterface Options {\n  /**\n   * If labelling associated aria properties should be included in the filter.\n   */\n  labelable?: boolean,\n  /** Whether the element is a link and should include DOM props for <a> elements. */\n  isLink?: boolean,\n  /**\n   * A Set of other property names that should be included in the filter.\n   */\n  propNames?: Set<string>\n}\n\nconst propRe = /^(data-.*)$/;\n\n/**\n * Filters out all props that aren't valid DOM props or defined via override prop obj.\n * @param props - The component props to be filtered.\n * @param opts - Props to override.\n */\nexport function filterDOMProps(props: DOMProps & AriaLabelingProps & LinkDOMProps, opts: Options = {}): DOMProps & AriaLabelingProps {\n  let {labelable, isLink, propNames} = opts;\n  let filteredProps = {};\n\n  for (const prop in props) {\n    if (\n      Object.prototype.hasOwnProperty.call(props, prop) && (\n        DOMPropNames.has(prop) ||\n        (labelable && labelablePropNames.has(prop)) ||\n        (isLink && linkPropNames.has(prop)) ||\n        propNames?.has(prop) ||\n        propRe.test(prop)\n      )\n    ) {\n      filteredProps[prop] = props[prop];\n    }\n  }\n\n  return filteredProps;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\n\n// This is a polyfill for element.focus({preventScroll: true});\n// Currently necessary for Safari and old Edge:\n// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option\n// See https://bugs.webkit.org/show_bug.cgi?id=178583\n//\n\n// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n\ninterface ScrollableElement {\n  element: HTMLElement,\n  scrollTop: number,\n  scrollLeft: number\n}\n\nexport function focusWithoutScrolling(element: FocusableElement) {\n  if (supportsPreventScroll()) {\n    element.focus({preventScroll: true});\n  } else {\n    let scrollableElements = getScrollableElements(element);\n    element.focus();\n    restoreScrollPosition(scrollableElements);\n  }\n}\n\nlet supportsPreventScrollCached: boolean = null;\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n    try {\n      var focusElem = document.createElement('div');\n      focusElem.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        }\n      });\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached;\n}\n\nfunction getScrollableElements(element: FocusableElement): ScrollableElement[] {\n  var parent = element.parentNode;\n  var scrollableElements: ScrollableElement[] = [];\n  var rootScrollingElement = document.scrollingElement || document.documentElement;\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft\n      });\n    }\n    parent = parent.parentNode;\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft\n    });\n  }\n\n  return scrollableElements;\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (let {element, scrollTop, scrollLeft} of scrollableElements) {\n    element.scrollTop = scrollTop;\n    element.scrollLeft = scrollLeft;\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function getOffset(element, reverse, orientation = 'horizontal') {\n  let rect = element.getBoundingClientRect();\n  if (reverse) {\n    return orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n  return orientation === 'horizontal' ? rect.left : rect.top;\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusWithoutScrolling, isMac, isWebKit} from './index';\nimport {isFirefox, isIPad} from './platform';\nimport {LinkDOMProps} from '@react-types/shared';\nimport React, {createContext, ReactNode, useContext, useMemo} from 'react';\n\ninterface Router {\n  isNative: boolean,\n  open: (target: Element, modifiers: Modifiers) => void\n}\n\nconst RouterContext = createContext<Router>({\n  isNative: true,\n  open: openSyntheticLink\n});\n\ninterface RouterProviderProps {\n  navigate: (path: string) => void,\n  children: ReactNode\n}\n\n/**\n * A RouterProvider accepts a `navigate` function from a framework or client side router,\n * and provides it to all nested React Aria links to enable client side navigation.\n */\nexport function RouterProvider(props: RouterProviderProps) {\n  let {children, navigate} = props;\n\n  let ctx = useMemo(() => ({\n    isNative: false,\n    open: (target: Element, modifiers: Modifiers) => {\n      getSyntheticLink(target, link => {\n        if (shouldClientNavigate(link, modifiers)) {\n          navigate(link.pathname + link.search + link.hash);\n        } else {\n          openLink(link, modifiers);\n        }\n      });\n    }\n  }), [navigate]);\n\n  return (\n    <RouterContext.Provider value={ctx}>\n      {children}\n    </RouterContext.Provider>\n  );\n}\n\nexport function useRouter(): Router {\n  return useContext(RouterContext);\n}\n\ninterface Modifiers {\n  metaKey?: boolean,\n  ctrlKey?: boolean,\n  altKey?: boolean,\n  shiftKey?: boolean\n}\n\nexport function shouldClientNavigate(link: HTMLAnchorElement, modifiers: Modifiers) {\n  // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n  let target = link.getAttribute('target');\n  return (\n    (!target || target === '_self') &&\n    link.origin === location.origin &&\n    !link.hasAttribute('download') &&\n    !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey\n  );\n}\n\nexport function openLink(target: HTMLAnchorElement, modifiers: Modifiers, setOpening = true) {\n  let {metaKey, ctrlKey, altKey, shiftKey} = modifiers;\n\n  // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n  // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n  // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n  if (isFirefox() && window.event?.type?.startsWith('key') && target.target === '_blank') {\n    if (isMac()) {\n      metaKey = true;\n    } else {\n      ctrlKey = true;\n    }\n  }\n\n  // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n  // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n  let event = isWebKit() && isMac() && !isIPad() && process.env.NODE_ENV !== 'test'\n    // @ts-ignore - keyIdentifier is a non-standard property, but it's what webkit expects\n    ? new KeyboardEvent('keydown', {keyIdentifier: 'Enter', metaKey, ctrlKey, altKey, shiftKey})\n    : new MouseEvent('click', {metaKey, ctrlKey, altKey, shiftKey, bubbles: true, cancelable: true});\n  (openLink as any).isOpening = setOpening;\n  focusWithoutScrolling(target);\n  target.dispatchEvent(event);\n  (openLink as any).isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n(openLink as any).isOpening = false;\n\nfunction getSyntheticLink(target: Element, open: (link: HTMLAnchorElement) => void) {\n  if (target instanceof HTMLAnchorElement) {\n    open(target);\n  } else if (target.hasAttribute('data-href')) {\n    let link = document.createElement('a');\n    link.href = target.getAttribute('data-href');\n    if (target.hasAttribute('data-target')) {\n      link.target = target.getAttribute('data-target');\n    }\n    if (target.hasAttribute('data-rel')) {\n      link.rel = target.getAttribute('data-rel');\n    }\n    if (target.hasAttribute('data-download')) {\n      link.download = target.getAttribute('data-download');\n    }\n    if (target.hasAttribute('data-ping')) {\n      link.ping = target.getAttribute('data-ping');\n    }\n    if (target.hasAttribute('data-referrer-policy')) {\n      link.referrerPolicy = target.getAttribute('data-referrer-policy');\n    }\n    target.appendChild(link);\n    open(link);\n    target.removeChild(link);\n  }\n}\n\nfunction openSyntheticLink(target: Element, modifiers: Modifiers) {\n  getSyntheticLink(target, link => openLink(link, modifiers));\n}\n\nexport function getSyntheticLinkProps(props: LinkDOMProps) {\n  return {\n    'data-href': props.href,\n    'data-target': props.target,\n    'data-rel': props.rel,\n    'data-download': props.download,\n    'data-ping': props.ping,\n    'data-referrer-policy': props.referrerPolicy\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction testUserAgent(re: RegExp) {\n  if (typeof window === 'undefined' || window.navigator == null) {\n    return false;\n  }\n  return (\n    window.navigator['userAgentData']?.brands.some((brand: {brand: string, version: string}) => re.test(brand.brand))\n  ) ||\n  re.test(window.navigator.userAgent);\n}\n\nfunction testPlatform(re: RegExp) {\n  return typeof window !== 'undefined' && window.navigator != null\n    ? re.test(window.navigator['userAgentData']?.platform || window.navigator.platform)\n    : false;\n}\n\nexport function isMac() {\n  return testPlatform(/^Mac/i);\n}\n\nexport function isIPhone() {\n  return testPlatform(/^iPhone/i);\n}\n\nexport function isIPad() {\n  return testPlatform(/^iPad/i) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1);\n}\n\nexport function isIOS() {\n  return isIPhone() || isIPad();\n}\n\nexport function isAppleDevice() {\n  return isMac() || isIOS();\n}\n\nexport function isWebKit() {\n  return testUserAgent(/AppleWebKit/i) && !isChrome();\n}\n\nexport function isChrome() {\n  return testUserAgent(/Chrome/i);\n}\n\nexport function isAndroid() {\n  return testUserAgent(/Android/i);\n}\n\nexport function isFirefox() {\n  return testUserAgent(/Firefox/i);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet transitionsByElement = new Map<EventTarget, Set<string>>();\n\n// A list of callbacks to call once there are no transitioning elements.\nlet transitionCallbacks = new Set<() => void>();\n\nfunction setupGlobalEvents() {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  let onTransitionStart = (e: TransitionEvent) => {\n    // Add the transitioning property to the list for this element.\n    let transitions = transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      transitionsByElement.set(e.target, transitions);\n\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener('transitioncancel', onTransitionEnd);\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  let onTransitionEnd = (e: TransitionEvent) => {\n    // Remove property from list of transitioning properties.\n    let properties = transitionsByElement.get(e.target);\n    if (!properties) {\n      return;\n    }\n\n    properties.delete(e.propertyName);\n\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      transitionsByElement.delete(e.target);\n    }\n\n    // If no transitioning elements, call all of the queued callbacks.\n    if (transitionsByElement.size === 0) {\n      for (let cb of transitionCallbacks) {\n        cb();\n      }\n\n      transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalEvents);\n  }\n}\n\nexport function runAfterTransition(fn: () => void) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if (transitionsByElement.size === 0) {\n      fn();\n    } else {\n      transitionCallbacks.add(fn);\n    }\n  });\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n /* eslint-disable rulesdir/pure-render */\n\nimport {getOffset} from './getOffset';\nimport {Orientation} from '@react-types/shared';\nimport React, {HTMLAttributes, MutableRefObject, useRef} from 'react';\n\ninterface UseDrag1DProps {\n  containerRef: MutableRefObject<HTMLElement>,\n  reverse?: boolean,\n  orientation?: Orientation,\n  onHover?: (hovered: boolean) => void,\n  onDrag?: (dragging: boolean) => void,\n  onPositionChange?: (position: number) => void,\n  onIncrement?: () => void,\n  onDecrement?: () => void,\n  onIncrementToMax?: () => void,\n  onDecrementToMin?: () => void,\n  onCollapseToggle?: () => void\n}\n\n// Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst draggingElements: HTMLElement[] = [];\n\n// created for splitview, this should be reusable for things like sliders/dials\n// It also handles keyboard events on the target allowing for increment/decrement by a given stepsize as well as minifying/maximizing and toggling between minified and previous size\n// It can also take a 'reverse' param to say if we should measure from the right/bottom instead of the top/left\n// It can also handle either a vertical or horizontal movement, but not both at the same time\n\nexport function useDrag1D(props: UseDrag1DProps): HTMLAttributes<HTMLElement> {\n  console.warn('useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html');\n  let {containerRef, reverse, orientation, onHover, onDrag, onPositionChange, onIncrement, onDecrement, onIncrementToMax, onDecrementToMin, onCollapseToggle} = props;\n  let getPosition = (e) => orientation === 'horizontal' ? e.clientX : e.clientY;\n  let getNextOffset = (e: MouseEvent) => {\n    let containerOffset = getOffset(containerRef.current, reverse, orientation);\n    let mouseOffset = getPosition(e);\n    let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n    return nextOffset;\n  };\n  let dragging = useRef(false);\n  let prevPosition = useRef(0);\n\n  // Keep track of the current handlers in a ref so that the events can access them.\n  let handlers = useRef({onPositionChange, onDrag});\n  handlers.current.onDrag = onDrag;\n  handlers.current.onPositionChange = onPositionChange;\n\n  let onMouseDragged = (e: MouseEvent) => {\n    e.preventDefault();\n    let nextOffset = getNextOffset(e);\n    if (!dragging.current) {\n      dragging.current = true;\n      if (handlers.current.onDrag) {\n        handlers.current.onDrag(true);\n      }\n      if (handlers.current.onPositionChange) {\n        handlers.current.onPositionChange(nextOffset);\n      }\n    }\n    if (prevPosition.current === nextOffset) {\n      return;\n    }\n    prevPosition.current = nextOffset;\n    if (onPositionChange) {\n      onPositionChange(nextOffset);\n    }\n  };\n\n  let onMouseUp = (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    dragging.current = false;\n    let nextOffset = getNextOffset(e);\n    if (handlers.current.onDrag) {\n      handlers.current.onDrag(false);\n    }\n    if (handlers.current.onPositionChange) {\n      handlers.current.onPositionChange(nextOffset);\n    }\n\n    draggingElements.splice(draggingElements.indexOf(target), 1);\n    window.removeEventListener('mouseup', onMouseUp, false);\n    window.removeEventListener('mousemove', onMouseDragged, false);\n  };\n\n  let onMouseDown = (e: React.MouseEvent<HTMLElement>) => {\n    const target = e.currentTarget;\n    // If we're already handling dragging on a descendant with useDrag1D, then\n    // we don't want to handle the drag motion on this target as well.\n    if (draggingElements.some(elt => target.contains(elt))) {\n      return;\n    }\n    draggingElements.push(target);\n    window.addEventListener('mousemove', onMouseDragged, false);\n    window.addEventListener('mouseup', onMouseUp, false);\n  };\n\n  let onMouseEnter = () => {\n    if (onHover) {\n      onHover(true);\n    }\n  };\n\n  let onMouseOut = () => {\n    if (onHover) {\n      onHover(false);\n    }\n  };\n\n  let onKeyDown = (e) => {\n    switch (e.key) {\n      case 'Left':\n      case 'ArrowLeft':\n        if (orientation === 'horizontal') {\n          e.preventDefault();\n          if (onDecrement && !reverse) {\n            onDecrement();\n          } else if (onIncrement && reverse) {\n            onIncrement();\n          }\n        }\n        break;\n      case 'Up':\n      case 'ArrowUp':\n        if (orientation === 'vertical') {\n          e.preventDefault();\n          if (onDecrement && !reverse) {\n            onDecrement();\n          } else if (onIncrement && reverse) {\n            onIncrement();\n          }\n        }\n        break;\n      case 'Right':\n      case 'ArrowRight':\n        if (orientation === 'horizontal') {\n          e.preventDefault();\n          if (onIncrement && !reverse) {\n            onIncrement();\n          } else if (onDecrement && reverse) {\n            onDecrement();\n          }\n        }\n        break;\n      case 'Down':\n      case 'ArrowDown':\n        if (orientation === 'vertical') {\n          e.preventDefault();\n          if (onIncrement && !reverse) {\n            onIncrement();\n          } else if (onDecrement && reverse) {\n            onDecrement();\n          }\n        }\n        break;\n      case 'Home':\n        e.preventDefault();\n        if (onDecrementToMin) {\n          onDecrementToMin();\n        }\n        break;\n      case 'End':\n        e.preventDefault();\n        if (onIncrementToMax) {\n          onIncrementToMax();\n        }\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (onCollapseToggle) {\n          onCollapseToggle();\n        }\n        break;\n    }\n  };\n\n  return {onMouseDown, onMouseEnter, onMouseOut, onKeyDown};\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useEffect, useRef} from 'react';\n\ninterface GlobalListeners {\n  addGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void,\n  addGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void,\n  removeGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void,\n  removeGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void,\n  removeAllGlobalListeners(): void\n}\n\nexport function useGlobalListeners(): GlobalListeners {\n  let globalListeners = useRef(new Map());\n  let addGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    // Make sure we remove the listener after it is called with the `once` option.\n    let fn = options?.once ? (...args) => {\n      globalListeners.current.delete(listener);\n      listener(...args);\n    } : listener;\n    globalListeners.current.set(listener, {type, eventTarget, fn, options});\n    eventTarget.addEventListener(type, listener, options);\n  }, []);\n  let removeGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    let fn = globalListeners.current.get(listener)?.fn || listener;\n    eventTarget.removeEventListener(type, fn, options);\n    globalListeners.current.delete(listener);\n  }, []);\n  let removeAllGlobalListeners = useCallback(() => {\n    globalListeners.current.forEach((value, key) => {\n      removeGlobalListener(value.eventTarget, value.type, key, value.options);\n    });\n  }, [removeGlobalListener]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return removeAllGlobalListeners;\n  }, [removeAllGlobalListeners]);\n\n  return {addGlobalListener, removeGlobalListener, removeAllGlobalListeners};\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMProps} from '@react-types/shared';\nimport {useId} from './useId';\n\n/**\n * Merges aria-label and aria-labelledby into aria-labelledby when both exist.\n * @param props - Aria label props.\n * @param defaultLabel - Default value for aria-label when not present.\n */\nexport function useLabels(props: DOMProps & AriaLabelingProps, defaultLabel?: string): DOMProps & AriaLabelingProps {\n  let {\n    id,\n    'aria-label': label,\n    'aria-labelledby': labelledBy\n  } = props;\n\n  // If there is both an aria-label and aria-labelledby,\n  // combine them by pointing to the element itself.\n  id = useId(id);\n  if (labelledBy && label) {\n    let ids = new Set([id, ...labelledBy.trim().split(/\\s+/)]);\n    labelledBy = [...ids].join(' ');\n  } else if (labelledBy) {\n    labelledBy = labelledBy.trim().split(/\\s+/).join(' ');\n  }\n\n  // If no labels are provided, use the default\n  if (!label && !labelledBy && defaultLabel) {\n    label = defaultLabel;\n  }\n\n  return {\n    id,\n    'aria-label': label,\n    'aria-labelledby': labelledBy\n  };\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {MutableRefObject, useMemo, useRef} from 'react';\n\n/**\n * Offers an object ref for a given callback ref or an object ref. Especially\n * helfpul when passing forwarded refs (created using `React.forwardRef`) to\n * React Aria Hooks.\n *\n * @param forwardedRef The original ref intended to be used.\n * @returns An object ref that updates the given ref.\n * @see https://reactjs.org/docs/forwarding-refs.html\n */\nexport function useObjectRef<T>(forwardedRef?: ((instance: T | null) => void) | MutableRefObject<T | null> | null): MutableRefObject<T> {\n  const objRef = useRef<T>();\n  return useMemo(() => ({\n    get current() {\n      return objRef.current;\n    },\n    set current(value) {\n      objRef.current = value;\n      if (typeof forwardedRef === 'function') {\n        forwardedRef(value);\n      } else if (forwardedRef) {\n        forwardedRef.current = value;\n      }\n    }\n  }), [forwardedRef]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {EffectCallback, useEffect, useRef} from 'react';\n\n// Like useEffect, but only called for updates after the initial render.\nexport function useUpdateEffect(effect: EffectCallback, dependencies: any[]) {\n  const isInitialMount = useRef(true);\n  const lastDeps = useRef<any[] | null>(null);\n\n  useEffect(() => {\n    isInitialMount.current = true;\n    return () => {\n      isInitialMount.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false;\n    } else if (!lastDeps.current || dependencies.some((dep, i) => !Object.is(dep, lastDeps[i]))) {\n      effect();\n    }\n    lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n", "import {RefObject, useEffect} from 'react';\n\nfunction hasResizeObserver() {\n  return typeof window.ResizeObserver !== 'undefined';\n}\n\ntype useResizeObserverOptionsType<T> = {\n  ref: RefObject<T | undefined> | undefined,\n  onResize: () => void\n}\n\nexport function useResizeObserver<T extends Element>(options: useResizeObserverOptionsType<T>) {\n  const {ref, onResize} = options;\n\n  useEffect(() => {\n    let element = ref?.current;\n    if (!element) {\n      return;\n    }\n\n    if (!hasResizeObserver()) {\n      window.addEventListener('resize', onResize, false);\n      return () => {\n        window.removeEventListener('resize', onResize, false);\n      };\n    } else {\n\n      const resizeObserverInstance = new window.ResizeObserver((entries) => {\n        if (!entries.length) {\n          return;\n        }\n\n        onResize();\n      });\n      resizeObserverInstance.observe(element);\n\n      return () => {\n        if (element) {\n          resizeObserverInstance.unobserve(element);\n        }\n      };\n    }\n\n  }, [onResize, ref]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {MutableRefObject, RefObject} from 'react';\nimport {useLayoutEffect} from './';\n\ninterface ContextValue<T> {\n  ref?: MutableRefObject<T>\n}\n\n// Syncs ref from context with ref passed to hook\nexport function useSyncRef<T>(context?: ContextValue<T> | null, ref?: RefObject<T>) {\n  useLayoutEffect(() => {\n    if (context && context.ref && ref) {\n      context.ref.current = ref.current;\n      return () => {\n        context.ref.current = null;\n      };\n    }\n  });\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function getScrollParent(node: Element, checkForOverflow?: boolean): Element {\n  if (isScrollable(node, checkForOverflow)) {\n    node = node.parentElement;\n  }\n\n  while (node && !isScrollable(node, checkForOverflow)) {\n    node = node.parentElement;\n  }\n\n  return node || document.scrollingElement || document.documentElement;\n}\n\nexport function isScrollable(node: Element, checkForOverflow?: boolean): boolean {\n  let style = window.getComputedStyle(node);\n  let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n\n  if (isScrollable && checkForOverflow) {\n    isScrollable = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;\n  }\n\n  return isScrollable;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\ninterface ViewportSize {\n  width: number,\n  height: number\n}\n\n// @ts-ignore\nlet visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nexport function useViewportSize(): ViewportSize {\n  let isSSR = useIsSSR();\n  let [size, setSize] = useState(() => isSSR ? {width: 0, height: 0} : getViewportSize());\n\n  useEffect(() => {\n    // Use visualViewport api to track available height even on iOS virtual keyboard opening\n    let onResize = () => {\n      setSize(size => {\n        let newSize = getViewportSize();\n        if (newSize.width === size.width && newSize.height === size.height) {\n          return size;\n        }\n        return newSize;\n      });\n    };\n\n    if (!visualViewport) {\n      window.addEventListener('resize', onResize);\n    } else {\n      visualViewport.addEventListener('resize', onResize);\n    }\n\n    return () => {\n      if (!visualViewport) {\n        window.removeEventListener('resize', onResize);\n      } else {\n        visualViewport.removeEventListener('resize', onResize);\n      }\n    };\n  }, []);\n\n  return size;\n}\n\nfunction getViewportSize(): ViewportSize {\n  return {\n    width: visualViewport?.width || window.innerWidth,\n    height: visualViewport?.height || window.innerHeight\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps} from '@react-types/shared';\nimport {useLayoutEffect} from './useLayoutEffect';\nimport {useState} from 'react';\n\nlet descriptionId = 0;\nconst descriptionNodes = new Map<string, {refCount: number, element: Element}>();\n\nexport function useDescription(description?: string): AriaLabelingProps {\n  let [id, setId] = useState(undefined);\n\n  useLayoutEffect(() => {\n    if (!description) {\n      return;\n    }\n\n    let desc = descriptionNodes.get(description);\n    if (!desc) {\n      let id = `react-aria-description-${descriptionId++}`;\n      setId(id);\n\n      let node = document.createElement('div');\n      node.id = id;\n      node.style.display = 'none';\n      node.textContent = description;\n      document.body.appendChild(node);\n      desc = {refCount: 0, element: node};\n      descriptionNodes.set(description, desc);\n    } else {\n      setId(desc.element.id);\n    }\n\n    desc.refCount++;\n    return () => {\n      if (--desc.refCount === 0) {\n        desc.element.remove();\n        descriptionNodes.delete(description);\n      }\n    };\n  }, [description]);\n\n  return {\n    'aria-describedby': description ? id : undefined\n  };\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject, useEffect} from 'react';\nimport {useEffectEvent} from './useEffectEvent';\n\nexport function useEvent<K extends keyof GlobalEventHandlersEventMap>(\n  ref: RefObject<EventTarget>,\n  event: K,\n  handler?: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let handleEvent = useEffectEvent(handler);\n  let isDisabled = handler == null;\n\n  useEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    let element = ref.current;\n    element.addEventListener(event, handleEvent, options);\n    return () => {\n      element.removeEventListener(event, handleEvent, options);\n    };\n  }, [ref, event, options, isDisabled, handleEvent]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getScrollParent} from './';\n\ninterface ScrollIntoViewportOpts {\n  /** The optional containing element of the target to be centered in the viewport. */\n  containingElement?: Element\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nexport function scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  let offsetX = relativeOffset(scrollView, element, 'left');\n  let offsetY = relativeOffset(scrollView, element, 'top');\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n\n  // Account for top/left border offsetting the scroll top/Left\n  let {borderTopWidth, borderLeftWidth} = getComputedStyle(scrollView);\n  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n  // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n  let maxX = borderAdjustedX + scrollView.clientWidth;\n  let maxY = borderAdjustedY + scrollView.clientHeight;\n\n  if (offsetX <= x) {\n    x = offsetX - parseInt(borderLeftWidth, 10);\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= borderAdjustedY) {\n    y = offsetY - parseInt(borderTopWidth, 10);\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */\nfunction relativeOffset(ancestor: HTMLElement, child: HTMLElement, axis: 'left'|'top') {\n  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n  let sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      // Stop once we have found the ancestor we are interested in.\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      // If the ancestor is not `position:relative`, then we stop at\n      // _its_ offset parent, and we subtract off _its_ offset, so that\n      // we end up with the proper offset from child to ancestor.\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent as HTMLElement;\n  }\n  return sum;\n}\n\n/**\n * Scrolls the `targetElement` so it is visible in the viewport. Accepts an optional `opts.containingElement`\n * that will be centered in the viewport prior to scrolling the targetElement into view. If scrolling is prevented on\n * the body (e.g. targetElement is in a popover), this will only scroll the scroll parents of the targetElement up to but not including the body itself.\n */\nexport function scrollIntoViewport(targetElement: Element, opts?: ScrollIntoViewportOpts) {\n  if (document.contains(targetElement)) {\n    let root = document.scrollingElement || document.documentElement;\n    let isScrollPrevented = window.getComputedStyle(root).overflow === 'hidden';\n    // If scrolling is not currently prevented then we arent in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n    if (!isScrollPrevented) {\n      let {left: originalLeft, top: originalTop} = targetElement.getBoundingClientRect();\n\n      // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()\n      // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n      targetElement?.scrollIntoView?.({block: 'nearest'});\n      let {left: newLeft, top: newTop} = targetElement.getBoundingClientRect();\n      // Account for sub pixel differences from rounding\n      if ((Math.abs(originalLeft - newLeft) > 1) || (Math.abs(originalTop - newTop) > 1)) {\n        opts?.containingElement?.scrollIntoView?.({block: 'center', inline: 'center'});\n        targetElement.scrollIntoView?.({block: 'nearest'});\n      }\n    } else {\n      let scrollParent = getScrollParent(targetElement);\n      // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {\n        scrollIntoView(scrollParent as HTMLElement, targetElement as HTMLElement);\n        targetElement = scrollParent;\n        scrollParent = getScrollParent(targetElement);\n      }\n    }\n  }\n}\n", "/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAndroid} from './platform';\n\n// Original licensing for the following method can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87\n\n// Keyboards, Assistive Technologies, and element.click() all produce a \"virtual\"\n// click event. This is a method of inferring such clicks. Every browser except\n// IE 11 only sets a zero value of \"detail\" for click events that are \"virtual\".\n// However, IE 11 uses a zero value for all click events. For IE 11 we rely on\n// the quirk that it produces click events that are of type PointerEvent, and\n// where only the \"virtual\" click lacks a pointerType field.\n\nexport function isVirtualClick(event: MouseEvent | PointerEvent): boolean {\n  // JAWS/NVDA with Firefox.\n  if ((event as any).mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n\n  // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n  // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n  // to detect TalkBack virtual clicks.\n  if (isAndroid() && (event as PointerEvent).pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n\n  return event.detail === 0 && !(event as PointerEvent).pointerType;\n}\n\nexport function isVirtualPointerEvent(event: PointerEvent) {\n  // If the pointer size is zero, then we assume it's from a screen reader.\n  // Android TalkBack double tap will sometimes return a event with width and height of 1\n  // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n  // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n  // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n  // Talkback double tap from Windows Firefox touch screen press\n  return (\n    (!isAndroid() && event.width === 0 && event.height === 0) ||\n    (event.width === 1 &&\n      event.height === 1 &&\n      event.pressure === 0 &&\n      event.detail === 0 &&\n      event.pointerType === 'mouse'\n    )\n  );\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/* eslint-disable rulesdir/pure-render */\n\nimport {useRef} from 'react';\n\nexport function useDeepMemo<T>(value: T, isEqual: (a: T, b: T) => boolean): T {\n  // Using a ref during render is ok here because it's only an optimization  both values are equivalent.\n  // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n  let lastValue = useRef(null);\n  if (value && lastValue.current && isEqual(value, lastValue.current)) {\n    value = lastValue.current;\n  }\n\n  lastValue.current = value;\n  return value;\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {RefObject, useEffect, useRef} from 'react';\nimport {useEffectEvent} from './useEffectEvent';\n\nexport function useFormReset<T>(\n  ref: RefObject<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>,\n  initialValue: T,\n  onReset: (value: T) => void\n) {\n  let resetValue = useRef(initialValue);\n  let handleReset = useEffectEvent(() => {\n    if (onReset) {\n      onReset(resetValue.current);\n    }\n  });\n\n  useEffect(() => {\n    let form = ref?.current?.form;\n    form?.addEventListener('reset', handleReset);\n    return () => {\n      form?.removeEventListener('reset', handleReset);\n    };\n  }, [ref, handleReset]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {Pressable} from './Pressable';\nexport {PressResponder, ClearPressResponder} from './PressResponder';\nexport {useFocus} from './useFocus';\nexport {\n  isFocusVisible,\n  getInteractionModality,\n  setInteractionModality,\n  useInteractionModality,\n  useFocusVisible,\n  useFocusVisibleListener\n} from './useFocusVisible';\nexport {useFocusWithin} from './useFocusWithin';\nexport {useHover} from './useHover';\nexport {useInteractOutside} from './useInteractOutside';\nexport {useKeyboard} from './useKeyboard';\nexport {useMove} from './useMove';\nexport {usePress} from './usePress';\nexport {useScrollWheel} from './useScrollWheel';\nexport {useLongPress} from './useLongPress';\n\nexport type {FocusProps, FocusResult} from './useFocus';\nexport type {FocusVisibleHandler, FocusVisibleProps, FocusVisibleResult, Modality} from './useFocusVisible';\nexport type {FocusWithinProps, FocusWithinResult} from './useFocusWithin';\nexport type {HoverProps, HoverResult} from './useHover';\nexport type {InteractOutsideProps} from './useInteractOutside';\nexport type {KeyboardProps, KeyboardResult} from './useKeyboard';\nexport type {PressProps, PressHookProps, PressResult} from './usePress';\nexport type {PressEvent, PressEvents, MoveStartEvent, MoveMoveEvent, MoveEndEvent, MoveEvents, HoverEvent, HoverEvents, FocusEvents, KeyboardEvents} from '@react-types/shared';\nexport type {MoveResult} from './useMove';\nexport type {LongPressProps, LongPressResult} from './useLongPress';\nexport type {ScrollWheelProps} from './useScrollWheel';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes} from '@react-types/shared';\nimport {mergeProps, useObjectRef} from '@react-aria/utils';\nimport {PressProps, usePress} from './usePress';\nimport React, {ForwardedRef, ReactElement} from 'react';\n\ninterface PressableProps extends PressProps {\n  children: ReactElement<DOMAttributes, string>\n}\n\nexport const Pressable = React.forwardRef(({children, ...props}: PressableProps, ref: ForwardedRef<HTMLElement>) => {\n  ref = useObjectRef(ref);\n  let {pressProps} = usePress({...props, ref});\n  let child = React.Children.only(children);\n  return React.cloneElement(\n    child,\n    // @ts-ignore\n    {ref, ...mergeProps(child.props, pressProps)}\n  );\n});\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, getOwnerWindow, isMac, isVirtualClick, isVirtualPointerEvent, mergeProps, openLink, useEffectEvent, useGlobalListeners, useSyncRef} from '@react-aria/utils';\nimport {PressResponderContext} from './context';\nimport {RefObject, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  ignoreClickAfterPress: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase) {\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _, // Removing `ref` from `domProps` because TypeScript is dumb\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.isOverTarget && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target as Element)) {\n          if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred.\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', onKeyUp, false);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onKeyUp(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target as Element) && state.target) {\n          triggerPressUp(createEvent(state.target, e), 'keyboard');\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            // Ensure the element receives focus (VoiceOver on iOS does not do this)\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n          e.preventDefault();\n        }\n\n        let target = e.target as Element;\n        let shouldStopPropagation = triggerPressEnd(createEvent(state.target, e), 'keyboard', state.target.contains(target));\n        removeAllGlobalListeners();\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on pointer down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget as Element)) {\n          e.preventDefault();\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointermove', onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e.button === 0) {\n          // Chrome and Firefox on touch Windows devices require mouse down events\n          // to be canceled in addition to pointer events, or an extra asynchronous\n          // focus event will be fired.\n          if (shouldPreventDefault(e.currentTarget as Element)) {\n            e.preventDefault();\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!e.currentTarget.contains(e.target as Element) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks\n        // Safari on iOS sometimes fires pointerup events, even\n        // when the touch isn't over the target, so double check.\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n      // Use pointer move events instead to implement our own hit testing.\n      // See https://bugs.webkit.org/show_bug.cgi?id=199803\n      let onPointerMove = (e: PointerEvent) => {\n        if (e.pointerId !== state.activePointerId) {\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target) && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          }\n\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else {\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on mouse down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        state.isPressed = false;\n        removeAllGlobalListeners();\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target) && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n        // on the emulated mouse event and handle focusing the pressable element ourselves.\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && (e.target as Element).contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp\n  ]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        restoreTextSelection(ref.current.target ?? undefined);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefault(target: Element) {\n  // We cannot prevent default if the target is a draggable element.\n  return !(target instanceof HTMLElement) || !target.hasAttribute('draggable');\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getOwnerDocument, isIOS, runAfterTransition} from '@react-aria/utils';\n\n// Safari on iOS starts selecting text on long press. The only way to avoid this, it seems,\n// is to add user-select: none to the entire page. Adding it to the pressable element prevents\n// that element from being selected, but nearby elements may still receive selection. We add\n// user-select: none on touch start, and remove it again on touch end to prevent this.\n// This must be implemented using global state to avoid race conditions between multiple elements.\n\n// There are three possible states due to the delay before removing user-select: none after\n// pointer up. The 'default' state always transitions to the 'disabled' state, which transitions\n// to 'restoring'. The 'restoring' state can either transition back to 'disabled' or 'default'.\n\n// For non-iOS devices, we apply user-select: none to the pressed element instead to avoid possible\n// performance issues that arise from applying and removing user-select: none to the entire page\n// (see https://github.com/adobe/react-spectrum/issues/1609).\ntype State = 'default' | 'disabled' | 'restoring';\n\n// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet state: State = 'default';\nlet savedUserSelect = '';\nlet modifiedElementMap = new WeakMap<Element, string>();\n\nexport function disableTextSelection(target?: Element) {\n  if (isIOS()) {\n    if (state === 'default') {\n      // eslint-disable-next-line no-restricted-globals\n      const documentObject = getOwnerDocument(target);\n      savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n      documentObject.documentElement.style.webkitUserSelect = 'none';\n    }\n\n    state = 'disabled';\n  } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n    // If not iOS, store the target's original user-select and change to user-select: none\n    // Ignore state since it doesn't apply for non iOS\n    modifiedElementMap.set(target, target.style.userSelect);\n    target.style.userSelect = 'none';\n  }\n}\n\nexport function restoreTextSelection(target?: Element) {\n  if (isIOS()) {\n    // If the state is already default, there's nothing to do.\n    // If it is restoring, then there's no need to queue a second restore.\n    if (state !== 'disabled') {\n      return;\n    }\n\n    state = 'restoring';\n\n    // There appears to be a delay on iOS where selection still might occur\n    // after pointer up, so wait a bit before removing user-select.\n    setTimeout(() => {\n      // Wait for any CSS transitions to complete so we don't recompute style\n      // for the whole page in the middle of the animation and cause jank.\n      runAfterTransition(() => {\n        // Avoid race conditions\n        if (state === 'restoring') {\n          // eslint-disable-next-line no-restricted-globals\n          const documentObject = getOwnerDocument(target);\n          if (documentObject.documentElement.style.webkitUserSelect === 'none') {\n            documentObject.documentElement.style.webkitUserSelect = savedUserSelect || '';\n          }\n\n          savedUserSelect = '';\n          state = 'default';\n        }\n      });\n    }, 300);\n  } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n    // If not iOS, restore the target's original user-select if any\n    // Ignore state since it doesn't apply for non iOS\n    if (target && modifiedElementMap.has(target)) {\n      let targetOldUserSelect = modifiedElementMap.get(target) as string;\n\n      if (target.style.userSelect === 'none') {\n        target.style.userSelect = targetOldUserSelect;\n      }\n\n      if (target.getAttribute('style') === '') {\n        target.removeAttribute('style');\n      }\n      modifiedElementMap.delete(target);\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {PressProps} from './usePress';\nimport React, {MutableRefObject} from 'react';\n\ninterface IPressResponderContext extends PressProps {\n  register(): void,\n  ref?: MutableRefObject<FocusableElement>\n}\n\nexport const PressResponderContext = React.createContext<IPressResponderContext>({register: () => {}});\nPressResponderContext.displayName = 'PressResponderContext';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {mergeProps, useObjectRef, useSyncRef} from '@react-aria/utils';\nimport {PressProps} from './usePress';\nimport {PressResponderContext} from './context';\nimport React, {ForwardedRef, ReactNode, useContext, useEffect, useMemo, useRef} from 'react';\n\ninterface PressResponderProps extends PressProps {\n  children: ReactNode\n}\n\nexport const PressResponder = React.forwardRef(({children, ...props}: PressResponderProps, ref: ForwardedRef<FocusableElement>) => {\n  let isRegistered = useRef(false);\n  let prevContext = useContext(PressResponderContext);\n  ref = useObjectRef(ref || prevContext?.ref);\n  let context = mergeProps(prevContext || {}, {\n    ...props,\n    ref,\n    register() {\n      isRegistered.current = true;\n      if (prevContext) {\n        prevContext.register();\n      }\n    }\n  });\n\n  useSyncRef(prevContext, ref);\n\n  useEffect(() => {\n    if (!isRegistered.current) {\n      console.warn(\n        'A PressResponder was rendered without a pressable child. ' +\n        'Either call the usePress hook, or wrap your DOM node with <Pressable> component.'\n      );\n      isRegistered.current = true; // only warn once in strict mode.\n    }\n  }, []);\n\n  return (\n    <PressResponderContext.Provider value={context}>\n      {children}\n    </PressResponderContext.Provider>\n  );\n});\n\nexport function ClearPressResponder({children}: {children: ReactNode}) {\n  let context = useMemo(() => ({register: () => {}}), []);\n  return (\n    <PressResponderContext.Provider value={context}>\n      {children}\n    </PressResponderContext.Provider>\n  );\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, FocusableElement, FocusEvents} from '@react-types/shared';\nimport {FocusEvent, useCallback} from 'react';\nimport {useSyntheticBlurEvent} from './utils';\n\nexport interface FocusProps<Target = FocusableElement> extends FocusEvents<Target> {\n  /** Whether the focus events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface FocusResult<Target = FocusableElement> {\n  /** Props to spread onto the target element. */\n  focusProps: DOMAttributes<Target>\n}\n\n/**\n * Handles focus events for the immediate target.\n * Focus events on child elements will be ignored.\n */\nexport function useFocus<Target extends FocusableElement = FocusableElement>(props: FocusProps<Target>): FocusResult<Target> {\n  let {\n    isDisabled,\n    onFocus: onFocusProp,\n    onBlur: onBlurProp,\n    onFocusChange\n  } = props;\n\n  const onBlur: FocusProps<Target>['onBlur'] = useCallback((e: FocusEvent<Target>) => {\n    if (e.target === e.currentTarget) {\n      if (onBlurProp) {\n        onBlurProp(e);\n      }\n\n      if (onFocusChange) {\n        onFocusChange(false);\n      }\n\n      return true;\n    }\n  }, [onBlurProp, onFocusChange]);\n\n\n  const onSyntheticFocus = useSyntheticBlurEvent<Target>(onBlur);\n\n  const onFocus: FocusProps<Target>['onFocus'] = useCallback((e: FocusEvent<Target>) => {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (e.target === e.currentTarget && document.activeElement === e.target) {\n      if (onFocusProp) {\n        onFocusProp(e);\n      }\n\n      if (onFocusChange) {\n        onFocusChange(true);\n      }\n\n      onSyntheticFocus(e);\n    }\n  }, [onFocusChange, onFocusProp, onSyntheticFocus]);\n\n  return {\n    focusProps: {\n      onFocus: (!isDisabled && (onFocusProp || onFocusChange || onBlurProp)) ? onFocus : undefined,\n      onBlur: (!isDisabled && (onBlurProp || onFocusChange)) ? onBlur : undefined\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent as ReactFocusEvent, useCallback, useRef} from 'react';\nimport {useEffectEvent, useLayoutEffect} from '@react-aria/utils';\n\nexport class SyntheticFocusEvent<Target = Element> implements ReactFocusEvent<Target> {\n  nativeEvent: FocusEvent;\n  target: EventTarget & Target;\n  currentTarget: EventTarget & Target;\n  relatedTarget: Element;\n  bubbles: boolean;\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  eventPhase: number;\n  isTrusted: boolean;\n  timeStamp: number;\n  type: string;\n\n  constructor(type: string, nativeEvent: FocusEvent) {\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEvent.target as EventTarget & Target;\n    this.currentTarget = nativeEvent.currentTarget as EventTarget & Target;\n    this.relatedTarget = nativeEvent.relatedTarget as Element;\n    this.bubbles = nativeEvent.bubbles;\n    this.cancelable = nativeEvent.cancelable;\n    this.defaultPrevented = nativeEvent.defaultPrevented;\n    this.eventPhase = nativeEvent.eventPhase;\n    this.isTrusted = nativeEvent.isTrusted;\n    this.timeStamp = nativeEvent.timeStamp;\n    this.type = type;\n  }\n\n  isDefaultPrevented(): boolean {\n    return this.nativeEvent.defaultPrevented;\n  }\n\n  preventDefault(): void {\n    this.defaultPrevented = true;\n    this.nativeEvent.preventDefault();\n  }\n\n  stopPropagation(): void {\n    this.nativeEvent.stopPropagation();\n    this.isPropagationStopped = () => true;\n  }\n\n  isPropagationStopped(): boolean {\n    return false;\n  }\n\n  persist() {}\n}\n\nexport function useSyntheticBlurEvent<Target = Element>(onBlur: (e: ReactFocusEvent<Target>) => void) {\n  let stateRef = useRef({\n    isFocused: false,\n    observer: null as MutationObserver | null\n  });\n\n  // Clean up MutationObserver on unmount. See below.\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    const state = stateRef.current;\n    return () => {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n\n  let dispatchBlur = useEffectEvent((e: SyntheticFocusEvent<Target>) => {\n    onBlur?.(e);\n  });\n\n  // This function is called during a React onFocus event.\n  return useCallback((e: ReactFocusEvent<Target>) => {\n    // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n    // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n    // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n    // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n    if (\n      e.target instanceof HTMLButtonElement ||\n      e.target instanceof HTMLInputElement ||\n      e.target instanceof HTMLTextAreaElement ||\n      e.target instanceof HTMLSelectElement\n    ) {\n      stateRef.current.isFocused = true;\n\n      let target = e.target;\n      let onBlurHandler: EventListenerOrEventListenerObject | null = (e) => {\n        stateRef.current.isFocused = false;\n\n        if (target.disabled) {\n          // For backward compatibility, dispatch a (fake) React synthetic event.\n          dispatchBlur(new SyntheticFocusEvent('blur', e as FocusEvent));\n        }\n\n        // We no longer need the MutationObserver once the target is blurred.\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n\n      target.addEventListener('focusout', onBlurHandler, {once: true});\n\n      stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          stateRef.current.observer?.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent('blur', {relatedTarget: relatedTargetEl}));\n          target.dispatchEvent(new FocusEvent('focusout', {bubbles: true, relatedTarget: relatedTargetEl}));\n        }\n      });\n\n      stateRef.current.observer.observe(target, {attributes: true, attributeFilter: ['disabled']});\n    }\n  }, [dispatchBlur]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {isMac, isVirtualClick} from '@react-aria/utils';\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\ntype HandlerEvent = PointerEvent | MouseEvent | KeyboardEvent | FocusEvent | null;\ntype Handler = (modality: Modality, e: HandlerEvent) => void;\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusVisibleResult {\n  /** Whether keyboard focus is visible globally. */\n  isFocusVisible: boolean\n}\n\nlet currentModality: null | Modality = null;\nlet changeHandlers = new Set<Handler>();\nlet hasSetupGlobalListeners = false;\nlet hasEventBeforeFocus = false;\nlet hasBlurredWindowRecently = false;\n\n// Only Tab or Esc keys will make focus visible on text input elements\nconst FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction triggerChangeHandlers(modality: Modality, e: HandlerEvent) {\n  for (let handler of changeHandlers) {\n    handler(modality, e);\n  }\n}\n\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction isValidKey(e: KeyboardEvent) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || (!isMac() && e.altKey) || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\n\nfunction handleKeyboardEvent(e: KeyboardEvent) {\n  hasEventBeforeFocus = true;\n  if (isValidKey(e)) {\n    currentModality = 'keyboard';\n    triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction handlePointerEvent(e: PointerEvent | MouseEvent) {\n  currentModality = 'pointer';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    hasEventBeforeFocus = true;\n    triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction handleClickEvent(e: MouseEvent) {\n  if (isVirtualClick(e)) {\n    hasEventBeforeFocus = true;\n    currentModality = 'virtual';\n  }\n}\n\nfunction handleFocusEvent(e: FocusEvent) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document) {\n    return;\n  }\n\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {\n    currentModality = 'virtual';\n    triggerChangeHandlers('virtual', e);\n  }\n\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = false;\n}\n\nfunction handleWindowBlur() {\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = true;\n}\n\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction setupGlobalFocusEvents() {\n  if (typeof window === 'undefined' || hasSetupGlobalListeners) {\n    return;\n  }\n\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function () {\n    hasEventBeforeFocus = true;\n    focus.apply(this, arguments as unknown as [options?: FocusOptions | undefined]);\n  };\n\n  document.addEventListener('keydown', handleKeyboardEvent, true);\n  document.addEventListener('keyup', handleKeyboardEvent, true);\n  document.addEventListener('click', handleClickEvent, true);\n\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  window.addEventListener('focus', handleFocusEvent, true);\n  window.addEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerdown', handlePointerEvent, true);\n    document.addEventListener('pointermove', handlePointerEvent, true);\n    document.addEventListener('pointerup', handlePointerEvent, true);\n  } else {\n    document.addEventListener('mousedown', handlePointerEvent, true);\n    document.addEventListener('mousemove', handlePointerEvent, true);\n    document.addEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  hasSetupGlobalListeners = true;\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalFocusEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalFocusEvents);\n  }\n}\n\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean {\n  return currentModality !== 'pointer';\n}\n\nexport function getInteractionModality(): Modality | null {\n  return currentModality;\n}\n\nexport function setInteractionModality(modality: Modality) {\n  currentModality = modality;\n  triggerChangeHandlers(modality, null);\n}\n\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null {\n  setupGlobalFocusEvents();\n\n  let [modality, setModality] = useState(currentModality);\n  useEffect(() => {\n    let handler = () => {\n      setModality(currentModality);\n    };\n\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  }, []);\n\n  return useIsSSR() ? null : modality;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction isKeyboardFocusEvent(isTextInput: boolean, modality: Modality, e: HandlerEvent) {\n  isTextInput = isTextInput || \n    (e?.target instanceof HTMLInputElement && !nonTextInputTypes.has(e?.target?.type)) ||\n    e?.target instanceof HTMLTextAreaElement ||\n    (e?.target instanceof HTMLElement && e?.target.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof KeyboardEvent && !FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props: FocusVisibleProps = {}): FocusVisibleResult {\n  let {isTextInput, autoFocus} = props;\n  let [isFocusVisibleState, setFocusVisible] = useState(autoFocus || isFocusVisible());\n  useFocusVisibleListener((isFocusVisible) => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {isTextInput});\n\n  return {isFocusVisible: isFocusVisibleState};\n}\n\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {isTextInput?: boolean}): void {\n  setupGlobalFocusEvents();\n\n  useEffect(() => {\n    let handler = (modality: Modality, e: HandlerEvent) => {\n      if (!isKeyboardFocusEvent(!!(opts?.isTextInput), modality, e)) {\n        return;\n      }\n      fn(isFocusVisible());\n    };\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes} from '@react-types/shared';\nimport {FocusEvent, useCallback, useRef} from 'react';\nimport {useSyntheticBlurEvent} from './utils';\n\nexport interface FocusWithinProps {\n  /** Whether the focus within events should be disabled. */\n  isDisabled?: boolean,\n  /** Handler that is called when the target element or a descendant receives focus. */\n  onFocusWithin?: (e: FocusEvent) => void,\n  /** Handler that is called when the target element and all descendants lose focus. */\n  onBlurWithin?: (e: FocusEvent) => void,\n  /** Handler that is called when the the focus within state changes. */\n  onFocusWithinChange?: (isFocusWithin: boolean) => void\n}\n\nexport interface FocusWithinResult {\n  /** Props to spread onto the target element. */\n  focusWithinProps: DOMAttributes\n}\n\n/**\n * Handles focus events for the target and its descendants.\n */\nexport function useFocusWithin(props: FocusWithinProps): FocusWithinResult {\n  let {\n    isDisabled,\n    onBlurWithin,\n    onFocusWithin,\n    onFocusWithinChange\n  } = props;\n  let state = useRef({\n    isFocusWithin: false\n  });\n\n  let onBlur = useCallback((e: FocusEvent) => {\n    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n    // when moving focus inside the element. Only trigger if the currentTarget doesn't\n    // include the relatedTarget (where focus is moving).\n    if (state.current.isFocusWithin && !(e.currentTarget as Element).contains(e.relatedTarget as Element)) {\n      state.current.isFocusWithin = false;\n\n      if (onBlurWithin) {\n        onBlurWithin(e);\n      }\n\n      if (onFocusWithinChange) {\n        onFocusWithinChange(false);\n      }\n    }\n  }, [onBlurWithin, onFocusWithinChange, state]);\n\n  let onSyntheticFocus = useSyntheticBlurEvent(onBlur);\n  let onFocus = useCallback((e: FocusEvent) => {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (!state.current.isFocusWithin && document.activeElement === e.target) {\n      if (onFocusWithin) {\n        onFocusWithin(e);\n      }\n\n      if (onFocusWithinChange) {\n        onFocusWithinChange(true);\n      }\n\n      state.current.isFocusWithin = true;\n      onSyntheticFocus(e);\n    }\n  }, [onFocusWithin, onFocusWithinChange, onSyntheticFocus]);\n\n  if (isDisabled) {\n    return {\n      focusWithinProps: {\n        // These should not have been null, that would conflict in mergeProps\n        onFocus: undefined,\n        onBlur: undefined\n      }\n    };\n  }\n\n  return {\n    focusWithinProps: {\n      onFocus,\n      onBlur\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, HoverEvents} from '@react-types/shared';\nimport {useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface HoverProps extends HoverEvents {\n  /** Whether the hover events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface HoverResult {\n  /** Props to spread on the target element. */\n  hoverProps: DOMAttributes,\n  isHovered: boolean\n}\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet globalIgnoreEmulatedMouseEvents = false;\nlet hoverCount = 0;\n\nfunction setGlobalIgnoreEmulatedMouseEvents() {\n  globalIgnoreEmulatedMouseEvents = true;\n\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(() => {\n    globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\n\nfunction handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') {\n    setGlobalIgnoreEmulatedMouseEvents();\n  }\n}\n\nfunction setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerup', handleGlobalPointerEvent);\n  } else {\n    document.addEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n  }\n\n  hoverCount++;\n  return () => {\n    hoverCount--;\n    if (hoverCount > 0) {\n      return;\n    }\n\n    if (typeof PointerEvent !== 'undefined') {\n      document.removeEventListener('pointerup', handleGlobalPointerEvent);\n    } else {\n      document.removeEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n    }\n  };\n}\n\n/**\n * Handles pointer hover interactions for an element. Normalizes behavior\n * across browsers and platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useHover(props: HoverProps): HoverResult {\n  let {\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled\n  } = props;\n\n  let [isHovered, setHovered] = useState(false);\n  let state = useRef({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n\n  useEffect(setupGlobalTouchEvents, []);\n\n  let {hoverProps, triggerHoverEnd} = useMemo(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) {\n        return;\n      }\n\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n\n      if (onHoverStart) {\n        onHoverStart({\n          type: 'hoverstart',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(true);\n      }\n\n      setHovered(true);\n    };\n\n    let triggerHoverEnd = (event, pointerType) => {\n      state.pointerType = '';\n      state.target = null;\n\n      if (pointerType === 'touch' || !state.isHovered) {\n        return;\n      }\n\n      state.isHovered = false;\n      let target = event.currentTarget;\n      if (onHoverEnd) {\n        onHoverEnd({\n          type: 'hoverend',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(false);\n      }\n\n      setHovered(false);\n    };\n\n    let hoverProps: DOMAttributes = {};\n\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = (e) => {\n        if (globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') {\n          return;\n        }\n\n        triggerHoverStart(e, e.pointerType);\n      };\n\n      hoverProps.onPointerLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      };\n    } else {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n\n      hoverProps.onMouseEnter = (e) => {\n        if (!state.ignoreEmulatedMouseEvents && !globalIgnoreEmulatedMouseEvents) {\n          triggerHoverStart(e, 'mouse');\n        }\n\n        state.ignoreEmulatedMouseEvents = false;\n      };\n\n      hoverProps.onMouseLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, 'mouse');\n        }\n      };\n    }\n    return {hoverProps, triggerHoverEnd};\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state]);\n\n  useEffect(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) {\n      triggerHoverEnd({currentTarget: state.target}, state.pointerType);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n\n  return {\n    hoverProps,\n    isHovered\n  };\n}\n\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, useEffectEvent} from '@react-aria/utils';\nimport {RefObject, useEffect, useRef} from 'react';\n\nexport interface InteractOutsideProps {\n  ref: RefObject<Element>,\n  onInteractOutside?: (e: PointerEvent) => void,\n  onInteractOutsideStart?: (e: PointerEvent) => void,\n  /** Whether the interact outside events should be disabled. */\n  isDisabled?: boolean\n}\n\n/**\n * Example, used in components like Dialogs and Popovers so they can close\n * when a user clicks outside them.\n */\nexport function useInteractOutside(props: InteractOutsideProps) {\n  let {ref, onInteractOutside, isDisabled, onInteractOutsideStart} = props;\n  let stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n\n  let onPointerDown = useEffectEvent((e) => {\n    if (onInteractOutside && isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) {\n        onInteractOutsideStart(e);\n      }\n      stateRef.current.isPointerDown = true;\n    }\n  });\n\n  let triggerInteractOutside = useEffectEvent((e: PointerEvent) => {\n    if (onInteractOutside) {\n      onInteractOutside(e);\n    }\n  });\n\n  useEffect(() => {\n    let state = stateRef.current;\n    if (isDisabled) {\n      return;\n    }\n\n    const element = ref.current;\n    const documentObject = getOwnerDocument(element);\n\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== 'undefined') {\n      let onPointerUp = (e) => {\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      // changing these to capture phase fixed combobox\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('pointerup', onPointerUp, true);\n\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('pointerup', onPointerUp, true);\n      };\n    } else {\n      let onMouseUp = (e) => {\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n        } else if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      let onTouchEnd = (e) => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\n\nfunction isValidEvent(event, ref) {\n  if (event.button > 0) {\n    return false;\n  }\n\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) {\n      return false;\n    }\n\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest('[data-react-aria-top-layer]')) {\n      return false;\n    }\n  }\n\n  return ref.current && !ref.current.contains(event.target);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createEventHandler} from './createEventHandler';\nimport {DOMAttributes, KeyboardEvents} from '@react-types/shared';\n\nexport interface KeyboardProps extends KeyboardEvents {\n  /** Whether the keyboard events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface KeyboardResult {\n  /** Props to spread onto the target element. */\n  keyboardProps: DOMAttributes\n}\n\n/**\n * Handles keyboard interactions for a focusable element.\n */\nexport function useKeyboard(props: KeyboardProps): KeyboardResult {\n  return {\n    keyboardProps: props.isDisabled ? {} : {\n      onKeyDown: createEventHandler(props.onKeyDown),\n      onKeyUp: createEventHandler(props.onKeyUp)\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {BaseEvent} from '@react-types/shared';\nimport {SyntheticEvent} from 'react';\n\n/**\n * This function wraps a React event handler to make stopPropagation the default, and support continuePropagation instead.\n */\nexport function createEventHandler<T extends SyntheticEvent>(handler?: (e: BaseEvent<T>) => void): ((e: T) => void) | undefined {\n  if (!handler) {\n    return undefined;\n  }\n\n  let shouldStopPropagation = true;\n  return (e: T) => {\n    let event: BaseEvent<T> = {\n      ...e,\n      preventDefault() {\n        e.preventDefault();\n      },\n      isDefaultPrevented() {\n        return e.isDefaultPrevented();\n      },\n      stopPropagation() {\n        console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');\n      },\n      continuePropagation() {\n        shouldStopPropagation = false;\n      }\n    };\n\n    handler(event);\n\n    if (shouldStopPropagation) {\n      e.stopPropagation();\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {disableTextSelection, restoreTextSelection}  from './textSelection';\nimport {DOMAttributes, MoveEvents, PointerType} from '@react-types/shared';\nimport React, {useMemo, useRef} from 'react';\nimport {useEffectEvent, useGlobalListeners} from '@react-aria/utils';\n\nexport interface MoveResult {\n  /** Props to spread on the target element. */\n  moveProps: DOMAttributes\n}\n\ninterface EventBase {\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean\n}\n\n/**\n * Handles move interactions across mouse, touch, and keyboard, including dragging with\n * the mouse or touch, and using the arrow keys. Normalizes behavior across browsers and\n * platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useMove(props: MoveEvents): MoveResult {\n  let {onMoveStart, onMove, onMoveEnd} = props;\n\n  let state = useRef<{\n    didMove: boolean,\n    lastPosition: {pageX: number, pageY: number} | null,\n    id: number | null\n  }>({didMove: false, lastPosition: null, id: null});\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let move = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, deltaX: number, deltaY: number) => {\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    if (!state.current.didMove) {\n      state.current.didMove = true;\n      onMoveStart?.({\n        type: 'movestart',\n        pointerType,\n        shiftKey: originalEvent.shiftKey,\n        metaKey: originalEvent.metaKey,\n        ctrlKey: originalEvent.ctrlKey,\n        altKey: originalEvent.altKey\n      });\n    }\n    onMove?.({\n      type: 'move',\n      pointerType,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      shiftKey: originalEvent.shiftKey,\n      metaKey: originalEvent.metaKey,\n      ctrlKey: originalEvent.ctrlKey,\n      altKey: originalEvent.altKey\n    });\n  });\n\n  let end = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    restoreTextSelection();\n    if (state.current.didMove) {\n      onMoveEnd?.({\n        type: 'moveend',\n        pointerType,\n        shiftKey: originalEvent.shiftKey,\n        metaKey: originalEvent.metaKey,\n        ctrlKey: originalEvent.ctrlKey,\n        altKey: originalEvent.altKey\n      });\n    }\n  });\n\n  let moveProps = useMemo(() => {\n    let moveProps: DOMAttributes = {};\n\n    let start = () => {\n      disableTextSelection();\n      state.current.didMove = false;\n    };\n\n    if (typeof PointerEvent === 'undefined') {\n      let onMouseMove = (e: MouseEvent) => {\n        if (e.button === 0) {\n          move(e, 'mouse', e.pageX - (state.current.lastPosition?.pageX ?? 0), e.pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n        }\n      };\n      let onMouseUp = (e: MouseEvent) => {\n        if (e.button === 0) {\n          end(e, 'mouse');\n          removeGlobalListener(window, 'mousemove', onMouseMove, false);\n          removeGlobalListener(window, 'mouseup', onMouseUp, false);\n        }\n      };\n      moveProps.onMouseDown = (e: React.MouseEvent) => {\n        if (e.button === 0) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n          addGlobalListener(window, 'mousemove', onMouseMove, false);\n          addGlobalListener(window, 'mouseup', onMouseUp, false);\n        }\n      };\n\n      let onTouchMove = (e: TouchEvent) => {\n        let touch = [...e.changedTouches].findIndex(({identifier}) => identifier === state.current.id);\n        if (touch >= 0) {\n          let {pageX, pageY} = e.changedTouches[touch];\n          move(e, 'touch', pageX - (state.current.lastPosition?.pageX ?? 0), pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX, pageY};\n        }\n      };\n      let onTouchEnd = (e: TouchEvent) => {\n        let touch = [...e.changedTouches].findIndex(({identifier}) => identifier === state.current.id);\n        if (touch >= 0) {\n          end(e, 'touch');\n          state.current.id = null;\n          removeGlobalListener(window, 'touchmove', onTouchMove);\n          removeGlobalListener(window, 'touchend', onTouchEnd);\n          removeGlobalListener(window, 'touchcancel', onTouchEnd);\n        }\n      };\n      moveProps.onTouchStart = (e: React.TouchEvent) => {\n        if (e.changedTouches.length === 0 || state.current.id != null) {\n          return;\n        }\n\n        let {pageX, pageY, identifier} = e.changedTouches[0];\n        start();\n        e.stopPropagation();\n        e.preventDefault();\n        state.current.lastPosition = {pageX, pageY};\n        state.current.id = identifier;\n        addGlobalListener(window, 'touchmove', onTouchMove, false);\n        addGlobalListener(window, 'touchend', onTouchEnd, false);\n        addGlobalListener(window, 'touchcancel', onTouchEnd, false);\n      };\n    } else {\n      let onPointerMove = (e: PointerEvent) => {\n        if (e.pointerId === state.current.id) {\n          let pointerType = (e.pointerType || 'mouse') as PointerType;\n\n          // Problems with PointerEvent#movementX/movementY:\n          // 1. it is always 0 on macOS Safari.\n          // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n          move(e, pointerType, e.pageX - (state.current.lastPosition?.pageX ?? 0), e.pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.current.id) {\n          let pointerType = (e.pointerType || 'mouse') as PointerType;\n          end(e, pointerType);\n          state.current.id = null;\n          removeGlobalListener(window, 'pointermove', onPointerMove, false);\n          removeGlobalListener(window, 'pointerup', onPointerUp, false);\n          removeGlobalListener(window, 'pointercancel', onPointerUp, false);\n        }\n      };\n\n      moveProps.onPointerDown = (e: React.PointerEvent) => {\n        if (e.button === 0 && state.current.id == null) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n          state.current.id = e.pointerId;\n          addGlobalListener(window, 'pointermove', onPointerMove, false);\n          addGlobalListener(window, 'pointerup', onPointerUp, false);\n          addGlobalListener(window, 'pointercancel', onPointerUp, false);\n        }\n      };\n    }\n\n    let triggerKeyboardMove = (e: EventBase, deltaX: number, deltaY: number) => {\n      start();\n      move(e, 'keyboard', deltaX, deltaY);\n      end(e, 'keyboard');\n    };\n\n    moveProps.onKeyDown = (e) => {\n      switch (e.key) {\n        case 'Left':\n        case 'ArrowLeft':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, -1, 0);\n          break;\n        case 'Right':\n        case 'ArrowRight':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 1, 0);\n          break;\n        case 'Up':\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, -1);\n          break;\n        case 'Down':\n        case 'ArrowDown':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, 1);\n          break;\n      }\n    };\n\n    return moveProps;\n  }, [state, addGlobalListener, removeGlobalListener, move, end]);\n\n  return {moveProps};\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject, useCallback} from 'react';\nimport {ScrollEvents} from '@react-types/shared';\nimport {useEvent} from '@react-aria/utils';\n\nexport interface ScrollWheelProps extends ScrollEvents {\n  /** Whether the scroll listener should be disabled. */\n  isDisabled?: boolean\n}\n\n// scroll wheel needs to be added not passively so it's cancelable, small helper hook to remember that\nexport function useScrollWheel(props: ScrollWheelProps, ref: RefObject<HTMLElement>): void {\n  let {onScroll, isDisabled} = props;\n  let onScrollHandler = useCallback((e) => {\n    // If the ctrlKey is pressed, this is a zoom event, do nothing.\n    if (e.ctrlKey) {\n      return;\n    }\n\n    // stop scrolling the page\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (onScroll) {\n      onScroll({deltaX: e.deltaX, deltaY: e.deltaY});\n    }\n  }, [onScroll]);\n\n  useEvent(ref, 'wheel', isDisabled ? undefined : onScrollHandler);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, LongPressEvent} from '@react-types/shared';\nimport {mergeProps, useDescription, useGlobalListeners} from '@react-aria/utils';\nimport {usePress} from './usePress';\nimport {useRef} from 'react';\n\nexport interface LongPressProps {\n  /** Whether long press events should be disabled. */\n  isDisabled?: boolean,\n  /** Handler that is called when a long press interaction starts. */\n  onLongPressStart?: (e: LongPressEvent) => void,\n  /**\n   * Handler that is called when a long press interaction ends, either\n   * over the target or when the pointer leaves the target.\n   */\n  onLongPressEnd?: (e: LongPressEvent) => void,\n  /**\n   * Handler that is called when the threshold time is met while\n   * the press is over the target.\n   */\n  onLongPress?: (e: LongPressEvent) => void,\n  /**\n   * The amount of time in milliseconds to wait before triggering a long press.\n   * @default 500ms\n   */\n  threshold?: number,\n  /**\n   * A description for assistive techology users indicating that a long press\n   * action is available, e.g. \"Long press to open menu\".\n   */\n  accessibilityDescription?: string\n}\n\nexport interface LongPressResult {\n  /** Props to spread on the target element. */\n  longPressProps: DOMAttributes\n}\n\nconst DEFAULT_THRESHOLD = 500;\n\n/**\n * Handles long press interactions across mouse and touch devices. Supports a customizable time threshold,\n * accessibility description, and normalizes behavior across browsers and devices.\n */\nexport function useLongPress(props: LongPressProps): LongPressResult {\n  let {\n    isDisabled,\n    onLongPressStart,\n    onLongPressEnd,\n    onLongPress,\n    threshold = DEFAULT_THRESHOLD,\n    accessibilityDescription\n  } = props;\n\n  const timeRef = useRef<ReturnType<typeof setTimeout> | undefined>();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let {pressProps} = usePress({\n    isDisabled,\n    onPressStart(e) {\n      e.continuePropagation();\n      if (e.pointerType === 'mouse' || e.pointerType === 'touch') {\n        if (onLongPressStart) {\n          onLongPressStart({\n            ...e,\n            type: 'longpressstart'\n          });\n        }\n\n        timeRef.current = setTimeout(() => {\n          // Prevent other usePress handlers from also handling this event.\n          e.target.dispatchEvent(new PointerEvent('pointercancel', {bubbles: true}));\n          if (onLongPress) {\n            onLongPress({\n              ...e,\n              type: 'longpress'\n            });\n          }\n          timeRef.current = undefined;\n        }, threshold);\n\n        // Prevent context menu, which may be opened on long press on touch devices\n        if (e.pointerType === 'touch') {\n          let onContextMenu = e => {\n            e.preventDefault();\n          };\n\n          addGlobalListener(e.target, 'contextmenu', onContextMenu, {once: true});\n          addGlobalListener(window, 'pointerup', () => {\n            // If no contextmenu event is fired quickly after pointerup, remove the handler\n            // so future context menu events outside a long press are not prevented.\n            setTimeout(() => {\n              removeGlobalListener(e.target, 'contextmenu', onContextMenu);\n            }, 30);\n          }, {once: true});\n        }\n      }\n    },\n    onPressEnd(e) {\n      if (timeRef.current) {\n        clearTimeout(timeRef.current);\n      }\n\n      if (onLongPressEnd && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        onLongPressEnd({\n          ...e,\n          type: 'longpressend'\n        });\n      }\n    }\n  });\n\n  let descriptionProps = useDescription(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n\n  return {\n    longPressProps: mergeProps(pressProps, descriptionProps)\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {FocusScope, useFocusManager, getFocusableTreeWalker, createFocusManager, isElementInChildOfActiveScope} from './FocusScope';\nexport {FocusRing} from './FocusRing';\nexport {FocusableProvider, useFocusable} from './useFocusable';\nexport {useFocusRing} from './useFocusRing';\nexport {focusSafely} from './focusSafely';\nexport {useHasTabbableChild} from './useHasTabbableChild';\n\nexport type {FocusScopeProps, FocusManager, FocusManagerOptions} from './FocusScope';\nexport type {FocusRingProps} from './FocusRing';\nexport type {FocusableAria, FocusableOptions, FocusableProviderProps} from './useFocusable';\nexport type {AriaFocusRingProps, FocusRingAria} from './useFocusRing';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n    /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[]> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>();\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>();\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef)) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (ownerDocument.body.contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  focusElement(nextNode as FocusableElement);\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n      isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef)) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(ownerDocument.body, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n           // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n           // then move focus to the body.\n           // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          isElementInScope(ownerDocument.activeElement, scopeRef.current)\n          || (ownerDocument.activeElement === ownerDocument.body && shouldRestoreFocus(scopeRef))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === ownerDocument.body) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                focusElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                focusFirstInScope(treeNode.scopeRef.current, true);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = getOwnerDocument(root).createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getOwnerDocument(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getOwnerWindow} from '@react-aria/utils';\n\nfunction isStyleVisible(element: Element) {\n  const windowObject = getOwnerWindow(element);\n  if (!(element instanceof windowObject.HTMLElement) && !(element instanceof windowObject.SVGElement)) {\n    return false;\n  }\n\n  let {display, visibility} = element.style;\n\n  let isVisible = (\n    display !== 'none' &&\n    visibility !== 'hidden' &&\n    visibility !== 'collapse'\n  );\n\n  if (isVisible) {\n    const {getComputedStyle} = element.ownerDocument.defaultView as unknown as Window;\n    let {display: computedDisplay, visibility: computedVisibility} = getComputedStyle(element);\n\n    isVisible = (\n      computedDisplay !== 'none' &&\n      computedVisibility !== 'hidden' &&\n      computedVisibility !== 'collapse'\n    );\n  }\n\n  return isVisible;\n}\n\nfunction isAttributeVisible(element: Element, childElement?: Element) {\n  return (\n    !element.hasAttribute('hidden') &&\n    (element.nodeName === 'DETAILS' &&\n      childElement &&\n      childElement.nodeName !== 'SUMMARY'\n      ? element.hasAttribute('open')\n      : true)\n  );\n}\n\n/**\n * Adapted from https://github.com/testing-library/jest-dom and\n * https://github.com/vuejs/vue-test-utils-next/.\n * Licensed under the MIT License.\n * @param element - Element to evaluate for display or visibility.\n */\nexport function isElementVisible(element: Element, childElement?: Element) {\n  return (\n    element.nodeName !== '#comment' &&\n    isStyleVisible(element) &&\n    isAttributeVisible(element, childElement) &&\n    (!element.parentElement || isElementVisible(element.parentElement, element))\n  );\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport clsx from 'clsx';\nimport {mergeProps} from '@react-aria/utils';\nimport React, {ReactElement} from 'react';\nimport {useFocusRing} from './useFocusRing';\n\nexport interface FocusRingProps {\n  /** Child element to apply CSS classes to. */\n  children: ReactElement,\n  /** CSS class to apply when the element is focused. */\n  focusClass?: string,\n  /** CSS class to apply when the element has keyboard focus. */\n  focusRingClass?: string,\n  /**\n   * Whether to show the focus ring when something\n   * inside the container element has focus (true), or\n   * only if the container itself has focus (false).\n   * @default false\n   */\n  within?: boolean,\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\n/**\n * A utility component that applies a CSS class when an element has keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function FocusRing(props: FocusRingProps) {\n  let {children, focusClass, focusRingClass} = props;\n  let {isFocused, isFocusVisible, focusProps} = useFocusRing(props);\n  let child = React.Children.only(children);\n\n  return React.cloneElement(child, mergeProps(child.props, {\n    ...focusProps,\n    className: clsx({\n      [focusClass || '']: isFocused,\n      [focusRingClass || '']: isFocusVisible\n    })\n  }));\n}\n", "import {DOMAttributes} from '@react-types/shared';\nimport {isFocusVisible, useFocus, useFocusVisibleListener, useFocusWithin} from '@react-aria/interactions';\nimport {useCallback, useRef, useState} from 'react';\n\nexport interface AriaFocusRingProps {\n  /**\n   * Whether to show the focus ring when something\n   * inside the container element has focus (true), or\n   * only if the container itself has focus (false).\n   * @default 'false'\n   */\n  within?: boolean,\n\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusRingAria {\n  /** Whether the element is currently focused. */\n  isFocused: boolean,\n\n  /** Whether keyboard focus should be visible. */\n  isFocusVisible: boolean,\n\n  /** Props to apply to the container element with the focus ring. */\n  focusProps: DOMAttributes\n}\n\n/**\n * Determines whether a focus ring should be shown to indicate keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function useFocusRing(props: AriaFocusRingProps = {}): FocusRingAria {\n  let {\n    autoFocus = false,\n    isTextInput,\n    within\n  } = props;\n  let state = useRef({\n    isFocused: false,\n    isFocusVisible: autoFocus || isFocusVisible()\n  });\n  let [isFocused, setFocused] = useState(false);\n  let [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible);\n\n  let updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n\n  let onFocusChange = useCallback(isFocused => {\n    state.current.isFocused = isFocused;\n    setFocused(isFocused);\n    updateState();\n  }, [updateState]);\n\n  useFocusVisibleListener((isFocusVisible) => {\n    state.current.isFocusVisible = isFocusVisible;\n    updateState();\n  }, [], {isTextInput});\n\n  let {focusProps} = useFocus({\n    isDisabled: within,\n    onFocusChange\n  });\n\n  let {focusWithinProps} = useFocusWithin({\n    isDisabled: !within,\n    onFocusWithinChange: onFocusChange\n  });\n\n  return {\n    isFocused,\n    isFocusVisible: isFocusVisibleState,\n    focusProps: within ? focusWithinProps : focusProps\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableDOMProps, FocusableElement, FocusableProps} from '@react-types/shared';\nimport {focusSafely} from './';\nimport {mergeProps, useObjectRef, useSyncRef} from '@react-aria/utils';\nimport React, {ForwardedRef, MutableRefObject, ReactNode, RefObject, useContext, useEffect, useRef} from 'react';\nimport {useFocus, useKeyboard} from '@react-aria/interactions';\n\nexport interface FocusableOptions extends FocusableProps, FocusableDOMProps {\n  /** Whether focus should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface FocusableProviderProps extends DOMAttributes {\n  /** The child element to provide DOM props to. */\n  children?: ReactNode\n}\n\ninterface FocusableContextValue extends FocusableProviderProps {\n  ref?: MutableRefObject<FocusableElement>\n}\n\nlet FocusableContext = React.createContext<FocusableContextValue | null>(null);\n\nfunction useFocusableContext(ref: RefObject<FocusableElement>): FocusableContextValue {\n  let context = useContext(FocusableContext) || {};\n  useSyncRef(context, ref);\n\n  // eslint-disable-next-line\n  let {ref: _, ...otherProps} = context;\n  return otherProps;\n}\n\n/**\n * Provides DOM props to the nearest focusable child.\n */\nfunction FocusableProvider(props: FocusableProviderProps, ref: ForwardedRef<FocusableElement>) {\n  let {children, ...otherProps} = props;\n  let objRef = useObjectRef(ref);\n  let context = {\n    ...otherProps,\n    ref: objRef\n  };\n\n  return (\n    <FocusableContext.Provider value={context}>\n      {children}\n    </FocusableContext.Provider>\n  );\n}\n\nlet _FocusableProvider = React.forwardRef(FocusableProvider);\nexport {_FocusableProvider as FocusableProvider};\n\nexport interface FocusableAria {\n  /** Props for the focusable element. */\n  focusableProps: DOMAttributes\n}\n\n/**\n * Used to make an element focusable and capable of auto focus.\n */\nexport function useFocusable(props: FocusableOptions, domRef: RefObject<FocusableElement>): FocusableAria {\n  let {focusProps} = useFocus(props);\n  let {keyboardProps} = useKeyboard(props);\n  let interactions = mergeProps(focusProps, keyboardProps);\n  let domProps = useFocusableContext(domRef);\n  let interactionProps = props.isDisabled ? {} : domProps;\n  let autoFocusRef = useRef(props.autoFocus);\n\n  useEffect(() => {\n    if (autoFocusRef.current && domRef.current) {\n      focusSafely(domRef.current);\n    }\n    autoFocusRef.current = false;\n  }, [domRef]);\n\n  return {\n    focusableProps: mergeProps(\n      {\n        ...interactions,\n        tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n      },\n      interactionProps\n    )\n  };\n}\n", "/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFocusableTreeWalker} from './FocusScope';\nimport {RefObject, useState} from 'react';\nimport {useLayoutEffect} from '@react-aria/utils';\n\ninterface AriaHasTabbableChildOptions {\n  isDisabled?: boolean\n}\n\n// This was created for a special empty case of a component that can have child or\n// be empty, like Collection/Virtualizer/Table/ListView/etc. When these components\n// are empty they can have a message with a tabbable element, which is like them\n// being not empty, when it comes to focus and tab order.\n\n/**\n * Returns whether an element has a tabbable child, and updates as children change.\n * @private\n */\nexport function useHasTabbableChild(ref: RefObject<Element>, options?: AriaHasTabbableChildOptions): boolean {\n  let isDisabled = options?.isDisabled;\n  let [hasTabbableChild, setHasTabbableChild] = useState(false);\n\n  useLayoutEffect(() => {\n    if (ref?.current && !isDisabled) {\n      let update = () => {\n        if (ref.current) {\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          setHasTabbableChild(!!walker.nextNode());\n        }\n      };\n\n      update();\n\n      // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n      let observer = new MutationObserver(update);\n      observer.observe(ref.current, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        attributeFilter: ['tabIndex', 'disabled']\n      });\n\n      return () => {\n        // Disconnect mutation observer when a React update occurs on the top-level component\n        // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n        // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n        // so we also update if a child component re-renders and adds/removes something tabbable.\n        observer.disconnect();\n      };\n    }\n  });\n\n  return isDisabled ? false : hasTabbableChild;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useId, mergeIds, useSlotId} from './useId';\nexport {chain} from './chain';\nexport {getOwnerDocument, getOwnerWindow} from './domHelpers';\nexport {mergeProps} from './mergeProps';\nexport {mergeRefs} from './mergeRefs';\nexport {filterDOMProps} from './filterDOMProps';\nexport {focusWithoutScrolling} from './focusWithoutScrolling';\nexport {getOffset} from './getOffset';\nexport {openLink, getSyntheticLinkProps, RouterProvider, shouldClientNavigate, useRouter} from './openLink';\nexport {runAfterTransition} from './runAfterTransition';\nexport {useDrag1D} from './useDrag1D';\nexport {useGlobalListeners} from './useGlobalListeners';\nexport {useLabels} from './useLabels';\nexport {useObjectRef} from './useObjectRef';\nexport {useUpdateEffect} from './useUpdateEffect';\nexport {useLayoutEffect} from './useLayoutEffect';\nexport {useResizeObserver} from './useResizeObserver';\nexport {useSyncRef} from './useSyncRef';\nexport {getScrollParent, isScrollable} from './getScrollParent';\nexport {useViewportSize} from './useViewportSize';\nexport {useDescription} from './useDescription';\nexport {isMac, isIPhone, isIPad, isIOS, isAppleDevice, isWebKit, isChrome, isAndroid} from './platform';\nexport {useEvent} from './useEvent';\nexport {useValueEffect} from './useValueEffect';\nexport {scrollIntoView, scrollIntoViewport} from './scrollIntoView';\nexport {clamp, snapValueToStep} from '@react-stately/utils';\nexport {isVirtualClick, isVirtualPointerEvent} from './isVirtualEvent';\nexport {useEffectEvent} from './useEffectEvent';\nexport {useDeepMemo} from './useDeepMemo';\nexport {useFormReset} from './useFormReset';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\nimport {useSSRSafeId} from '@react-aria/ssr';\nimport {useValueEffect} from './';\n\n// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing\nlet canUseDOM = Boolean(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nlet idsUpdaterMap: Map<string, (v: string) => void> = new Map();\n\n/**\n * If a default is not provided, generate an id.\n * @param defaultId - Default component id.\n */\nexport function useId(defaultId?: string): string {\n  let [value, setValue] = useState(defaultId);\n  let nextId = useRef(null);\n\n  let res = useSSRSafeId(value);\n\n  let updateValue = useCallback((val) => {\n    nextId.current = val;\n  }, []);\n\n  if (canUseDOM) {\n    idsUpdaterMap.set(res, updateValue);\n  }\n\n  useLayoutEffect(() => {\n    let r = res;\n    return () => {\n      idsUpdaterMap.delete(r);\n    };\n  }, [res]);\n\n  // This cannot cause an infinite loop because the ref is updated first.\n  // eslint-disable-next-line\n  useEffect(() => {\n    let newId = nextId.current;\n    if (newId) {\n      nextId.current = null;\n      setValue(newId);\n    }\n  });\n\n  return res;\n}\n\n/**\n * Merges two ids.\n * Different ids will trigger a side-effect and re-render components hooked up with `useId`.\n */\nexport function mergeIds(idA: string, idB: string): string {\n  if (idA === idB) {\n    return idA;\n  }\n\n  let setIdA = idsUpdaterMap.get(idA);\n  if (setIdA) {\n    setIdA(idB);\n    return idB;\n  }\n\n  let setIdB = idsUpdaterMap.get(idB);\n  if (setIdB) {\n    setIdB(idA);\n    return idA;\n  }\n\n  return idB;\n}\n\n/**\n * Used to generate an id, and after render, check if that id is rendered so we know\n * if we can use it in places such as labelledby.\n * @param depArray - When to recalculate if the id is in the DOM.\n */\nexport function useSlotId(depArray: ReadonlyArray<any> = []): string {\n  let id = useId();\n  let [resolvedId, setResolvedId] = useValueEffect(id);\n  let updateId = useCallback(() => {\n    setResolvedId(function *() {\n      yield id;\n\n      yield document.getElementById(id) ? id : undefined;\n    });\n  }, [id, setResolvedId]);\n\n  useLayoutEffect(updateId, [id, updateId, ...depArray]);\n\n  return resolvedId;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React from 'react';\n\n// During SSR, React emits a warning when calling useLayoutEffect.\n// Since neither useLayoutEffect nor useEffect run on the server,\n// we can suppress this by replace it with a noop on the server.\nexport const useLayoutEffect = typeof document !== 'undefined'\n  ? React.useLayoutEffect\n  : () => {};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Dispatch, useRef, useState} from 'react';\nimport {useEffectEvent, useLayoutEffect} from './';\n\ntype SetValueAction<S> = (prev: S) => Generator<any, void, unknown>;\n\n// This hook works like `useState`, but when setting the value, you pass a generator function\n// that can yield multiple values. Each yielded value updates the state and waits for the next\n// layout effect, then continues the generator. This allows sequential updates to state to be\n// written linearly.\nexport function useValueEffect<S>(defaultValue: S | (() => S)): [S, Dispatch<SetValueAction<S>>] {\n  let [value, setValue] = useState(defaultValue);\n  let effect = useRef(null);\n\n  // Store the function in a ref so we can always access the current version\n  // which has the proper `value` in scope.\n  let nextRef = useEffectEvent(() => {\n    // Run the generator to the next yield.\n    let newValue = effect.current.next();\n\n    // If the generator is done, reset the effect.\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n\n    // If the value is the same as the current value,\n    // then continue to the next yield. Otherwise,\n    // set the value in state and wait for the next layout effect.\n    if (value === newValue.value) {\n      nextRef();\n    } else {\n      setValue(newValue.value);\n    }\n  });\n\n  useLayoutEffect(() => {\n    // If there is an effect currently running, continue to the next yield.\n    if (effect.current) {\n      nextRef();\n    }\n  });\n\n  let queue = useEffectEvent(fn => {\n    effect.current = fn(value);\n    nextRef();\n  });\n\n  return [value, queue];\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\n\nexport function useEffectEvent<T extends Function>(fn: T): T {\n  const ref = useRef<T | null>(null);\n  useLayoutEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  // @ts-ignore\n  return useCallback<T>((...args) => {\n    const f = ref.current!;\n    return f(...args);\n  }, []);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Calls all functions in the order they were chained with the same arguments.\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (let callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n", "export const getOwnerDocument = (el: Element | null | undefined): Document => {\n  return el?.ownerDocument ?? document;\n};\n\nexport const getOwnerWindow = (\n  el: (Window & typeof global) | Element | null | undefined\n): Window & typeof global => {\n  if (el && 'window' in el && el.window === el) {\n    return el;\n  }\n\n  const doc = getOwnerDocument(el as Element | null | undefined);\n  return doc.defaultView || window;\n};\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain} from './chain';\nimport clsx from 'clsx';\nimport {mergeIds} from './useId';\n\ninterface Props {\n  [key: string]: any\n}\n\ntype PropsArg = Props | null | undefined;\n\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? NullToObject<V> : never;\ntype NullToObject<T> = T extends (null | undefined) ? {} : T;\n// eslint-disable-next-line no-undef, @typescript-eslint/no-unused-vars\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n */\nexport function mergeProps<T extends PropsArg[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  let result: Props = {...args[0]};\n  for (let i = 1; i < args.length; i++) {\n    let props = args[i];\n    for (let key in props) {\n      let a = result[key];\n      let b = props[key];\n\n      // Chain events\n      if (\n        typeof a === 'function' &&\n        typeof b === 'function' &&\n        // This is a lot faster than a regex.\n        key[0] === 'o' &&\n        key[1] === 'n' &&\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\n        key.charCodeAt(2) <= /* 'Z' */ 90\n      ) {\n        result[key] = chain(a, b);\n\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        (key === 'className' || key === 'UNSAFE_className') &&\n        typeof a === 'string' &&\n        typeof b === 'string'\n      ) {\n        result[key] = clsx(a, b);\n      } else if (key === 'id' && a && b) {\n        result.id = mergeIds(a, b);\n        // Override others\n      } else {\n        result[key] = b !== undefined ? b : a;\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ForwardedRef} from 'react';\n\n/**\n * Merges multiple refs into one. Works with either callback or object refs.\n */\nexport function mergeRefs<T>(...refs: ForwardedRef<T>[]): ForwardedRef<T> {\n  if (refs.length === 1) {\n    return refs[0];\n  }\n\n  return (value: T) => {\n    for (let ref of refs) {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMProps, LinkDOMProps} from '@react-types/shared';\n\nconst DOMPropNames = new Set([\n  'id'\n]);\n\nconst labelablePropNames = new Set([\n  'aria-label',\n  'aria-labelledby',\n  'aria-describedby',\n  'aria-details'\n]);\n\n// See LinkDOMProps in dom.d.ts.\nconst linkPropNames = new Set([\n  'href',\n  'target',\n  'rel',\n  'download',\n  'ping',\n  'referrerPolicy'\n]);\n\ninterface Options {\n  /**\n   * If labelling associated aria properties should be included in the filter.\n   */\n  labelable?: boolean,\n  /** Whether the element is a link and should include DOM props for <a> elements. */\n  isLink?: boolean,\n  /**\n   * A Set of other property names that should be included in the filter.\n   */\n  propNames?: Set<string>\n}\n\nconst propRe = /^(data-.*)$/;\n\n/**\n * Filters out all props that aren't valid DOM props or defined via override prop obj.\n * @param props - The component props to be filtered.\n * @param opts - Props to override.\n */\nexport function filterDOMProps(props: DOMProps & AriaLabelingProps & LinkDOMProps, opts: Options = {}): DOMProps & AriaLabelingProps {\n  let {labelable, isLink, propNames} = opts;\n  let filteredProps = {};\n\n  for (const prop in props) {\n    if (\n      Object.prototype.hasOwnProperty.call(props, prop) && (\n        DOMPropNames.has(prop) ||\n        (labelable && labelablePropNames.has(prop)) ||\n        (isLink && linkPropNames.has(prop)) ||\n        propNames?.has(prop) ||\n        propRe.test(prop)\n      )\n    ) {\n      filteredProps[prop] = props[prop];\n    }\n  }\n\n  return filteredProps;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\n\n// This is a polyfill for element.focus({preventScroll: true});\n// Currently necessary for Safari and old Edge:\n// https://caniuse.com/#feat=mdn-api_htmlelement_focus_preventscroll_option\n// See https://bugs.webkit.org/show_bug.cgi?id=178583\n//\n\n// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n\ninterface ScrollableElement {\n  element: HTMLElement,\n  scrollTop: number,\n  scrollLeft: number\n}\n\nexport function focusWithoutScrolling(element: FocusableElement) {\n  if (supportsPreventScroll()) {\n    element.focus({preventScroll: true});\n  } else {\n    let scrollableElements = getScrollableElements(element);\n    element.focus();\n    restoreScrollPosition(scrollableElements);\n  }\n}\n\nlet supportsPreventScrollCached: boolean = null;\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n    try {\n      var focusElem = document.createElement('div');\n      focusElem.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        }\n      });\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached;\n}\n\nfunction getScrollableElements(element: FocusableElement): ScrollableElement[] {\n  var parent = element.parentNode;\n  var scrollableElements: ScrollableElement[] = [];\n  var rootScrollingElement = document.scrollingElement || document.documentElement;\n\n  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft\n      });\n    }\n    parent = parent.parentNode;\n  }\n\n  if (rootScrollingElement instanceof HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft\n    });\n  }\n\n  return scrollableElements;\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (let {element, scrollTop, scrollLeft} of scrollableElements) {\n    element.scrollTop = scrollTop;\n    element.scrollLeft = scrollLeft;\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function getOffset(element, reverse, orientation = 'horizontal') {\n  let rect = element.getBoundingClientRect();\n  if (reverse) {\n    return orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n  return orientation === 'horizontal' ? rect.left : rect.top;\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusWithoutScrolling, isMac, isWebKit} from './index';\nimport {isFirefox, isIPad} from './platform';\nimport {LinkDOMProps} from '@react-types/shared';\nimport React, {createContext, ReactNode, useContext, useMemo} from 'react';\n\ninterface Router {\n  isNative: boolean,\n  open: (target: Element, modifiers: Modifiers) => void\n}\n\nconst RouterContext = createContext<Router>({\n  isNative: true,\n  open: openSyntheticLink\n});\n\ninterface RouterProviderProps {\n  navigate: (path: string) => void,\n  children: ReactNode\n}\n\n/**\n * A RouterProvider accepts a `navigate` function from a framework or client side router,\n * and provides it to all nested React Aria links to enable client side navigation.\n */\nexport function RouterProvider(props: RouterProviderProps) {\n  let {children, navigate} = props;\n\n  let ctx = useMemo(() => ({\n    isNative: false,\n    open: (target: Element, modifiers: Modifiers) => {\n      getSyntheticLink(target, link => {\n        if (shouldClientNavigate(link, modifiers)) {\n          navigate(link.pathname + link.search + link.hash);\n        } else {\n          openLink(link, modifiers);\n        }\n      });\n    }\n  }), [navigate]);\n\n  return (\n    <RouterContext.Provider value={ctx}>\n      {children}\n    </RouterContext.Provider>\n  );\n}\n\nexport function useRouter(): Router {\n  return useContext(RouterContext);\n}\n\ninterface Modifiers {\n  metaKey?: boolean,\n  ctrlKey?: boolean,\n  altKey?: boolean,\n  shiftKey?: boolean\n}\n\nexport function shouldClientNavigate(link: HTMLAnchorElement, modifiers: Modifiers) {\n  // Use getAttribute here instead of link.target. Firefox will default link.target to \"_parent\" when inside an iframe.\n  let target = link.getAttribute('target');\n  return (\n    (!target || target === '_self') &&\n    link.origin === location.origin &&\n    !link.hasAttribute('download') &&\n    !modifiers.metaKey && // open in new tab (mac)\n    !modifiers.ctrlKey && // open in new tab (windows)\n    !modifiers.altKey && // download\n    !modifiers.shiftKey\n  );\n}\n\nexport function openLink(target: HTMLAnchorElement, modifiers: Modifiers, setOpening = true) {\n  let {metaKey, ctrlKey, altKey, shiftKey} = modifiers;\n\n  // Firefox does not recognize keyboard events as a user action by default, and the popup blocker\n  // will prevent links with target=\"_blank\" from opening. However, it does allow the event if the\n  // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.\n  if (isFirefox() && window.event?.type?.startsWith('key') && target.target === '_blank') {\n    if (isMac()) {\n      metaKey = true;\n    } else {\n      ctrlKey = true;\n    }\n  }\n\n  // WebKit does not support firing click events with modifier keys, but does support keyboard events.\n  // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184\n  let event = isWebKit() && isMac() && !isIPad() && process.env.NODE_ENV !== 'test'\n    // @ts-ignore - keyIdentifier is a non-standard property, but it's what webkit expects\n    ? new KeyboardEvent('keydown', {keyIdentifier: 'Enter', metaKey, ctrlKey, altKey, shiftKey})\n    : new MouseEvent('click', {metaKey, ctrlKey, altKey, shiftKey, bubbles: true, cancelable: true});\n  (openLink as any).isOpening = setOpening;\n  focusWithoutScrolling(target);\n  target.dispatchEvent(event);\n  (openLink as any).isOpening = false;\n}\n// https://github.com/parcel-bundler/parcel/issues/8724\n(openLink as any).isOpening = false;\n\nfunction getSyntheticLink(target: Element, open: (link: HTMLAnchorElement) => void) {\n  if (target instanceof HTMLAnchorElement) {\n    open(target);\n  } else if (target.hasAttribute('data-href')) {\n    let link = document.createElement('a');\n    link.href = target.getAttribute('data-href');\n    if (target.hasAttribute('data-target')) {\n      link.target = target.getAttribute('data-target');\n    }\n    if (target.hasAttribute('data-rel')) {\n      link.rel = target.getAttribute('data-rel');\n    }\n    if (target.hasAttribute('data-download')) {\n      link.download = target.getAttribute('data-download');\n    }\n    if (target.hasAttribute('data-ping')) {\n      link.ping = target.getAttribute('data-ping');\n    }\n    if (target.hasAttribute('data-referrer-policy')) {\n      link.referrerPolicy = target.getAttribute('data-referrer-policy');\n    }\n    target.appendChild(link);\n    open(link);\n    target.removeChild(link);\n  }\n}\n\nfunction openSyntheticLink(target: Element, modifiers: Modifiers) {\n  getSyntheticLink(target, link => openLink(link, modifiers));\n}\n\nexport function getSyntheticLinkProps(props: LinkDOMProps) {\n  return {\n    'data-href': props.href,\n    'data-target': props.target,\n    'data-rel': props.rel,\n    'data-download': props.download,\n    'data-ping': props.ping,\n    'data-referrer-policy': props.referrerPolicy\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction testUserAgent(re: RegExp) {\n  if (typeof window === 'undefined' || window.navigator == null) {\n    return false;\n  }\n  return (\n    window.navigator['userAgentData']?.brands.some((brand: {brand: string, version: string}) => re.test(brand.brand))\n  ) ||\n  re.test(window.navigator.userAgent);\n}\n\nfunction testPlatform(re: RegExp) {\n  return typeof window !== 'undefined' && window.navigator != null\n    ? re.test(window.navigator['userAgentData']?.platform || window.navigator.platform)\n    : false;\n}\n\nexport function isMac() {\n  return testPlatform(/^Mac/i);\n}\n\nexport function isIPhone() {\n  return testPlatform(/^iPhone/i);\n}\n\nexport function isIPad() {\n  return testPlatform(/^iPad/i) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1);\n}\n\nexport function isIOS() {\n  return isIPhone() || isIPad();\n}\n\nexport function isAppleDevice() {\n  return isMac() || isIOS();\n}\n\nexport function isWebKit() {\n  return testUserAgent(/AppleWebKit/i) && !isChrome();\n}\n\nexport function isChrome() {\n  return testUserAgent(/Chrome/i);\n}\n\nexport function isAndroid() {\n  return testUserAgent(/Android/i);\n}\n\nexport function isFirefox() {\n  return testUserAgent(/Firefox/i);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet transitionsByElement = new Map<EventTarget, Set<string>>();\n\n// A list of callbacks to call once there are no transitioning elements.\nlet transitionCallbacks = new Set<() => void>();\n\nfunction setupGlobalEvents() {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  let onTransitionStart = (e: TransitionEvent) => {\n    // Add the transitioning property to the list for this element.\n    let transitions = transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      transitionsByElement.set(e.target, transitions);\n\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener('transitioncancel', onTransitionEnd);\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  let onTransitionEnd = (e: TransitionEvent) => {\n    // Remove property from list of transitioning properties.\n    let properties = transitionsByElement.get(e.target);\n    if (!properties) {\n      return;\n    }\n\n    properties.delete(e.propertyName);\n\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      transitionsByElement.delete(e.target);\n    }\n\n    // If no transitioning elements, call all of the queued callbacks.\n    if (transitionsByElement.size === 0) {\n      for (let cb of transitionCallbacks) {\n        cb();\n      }\n\n      transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalEvents);\n  }\n}\n\nexport function runAfterTransition(fn: () => void) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if (transitionsByElement.size === 0) {\n      fn();\n    } else {\n      transitionCallbacks.add(fn);\n    }\n  });\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n /* eslint-disable rulesdir/pure-render */\n\nimport {getOffset} from './getOffset';\nimport {Orientation} from '@react-types/shared';\nimport React, {HTMLAttributes, MutableRefObject, useRef} from 'react';\n\ninterface UseDrag1DProps {\n  containerRef: MutableRefObject<HTMLElement>,\n  reverse?: boolean,\n  orientation?: Orientation,\n  onHover?: (hovered: boolean) => void,\n  onDrag?: (dragging: boolean) => void,\n  onPositionChange?: (position: number) => void,\n  onIncrement?: () => void,\n  onDecrement?: () => void,\n  onIncrementToMax?: () => void,\n  onDecrementToMin?: () => void,\n  onCollapseToggle?: () => void\n}\n\n// Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst draggingElements: HTMLElement[] = [];\n\n// created for splitview, this should be reusable for things like sliders/dials\n// It also handles keyboard events on the target allowing for increment/decrement by a given stepsize as well as minifying/maximizing and toggling between minified and previous size\n// It can also take a 'reverse' param to say if we should measure from the right/bottom instead of the top/left\n// It can also handle either a vertical or horizontal movement, but not both at the same time\n\nexport function useDrag1D(props: UseDrag1DProps): HTMLAttributes<HTMLElement> {\n  console.warn('useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html');\n  let {containerRef, reverse, orientation, onHover, onDrag, onPositionChange, onIncrement, onDecrement, onIncrementToMax, onDecrementToMin, onCollapseToggle} = props;\n  let getPosition = (e) => orientation === 'horizontal' ? e.clientX : e.clientY;\n  let getNextOffset = (e: MouseEvent) => {\n    let containerOffset = getOffset(containerRef.current, reverse, orientation);\n    let mouseOffset = getPosition(e);\n    let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n    return nextOffset;\n  };\n  let dragging = useRef(false);\n  let prevPosition = useRef(0);\n\n  // Keep track of the current handlers in a ref so that the events can access them.\n  let handlers = useRef({onPositionChange, onDrag});\n  handlers.current.onDrag = onDrag;\n  handlers.current.onPositionChange = onPositionChange;\n\n  let onMouseDragged = (e: MouseEvent) => {\n    e.preventDefault();\n    let nextOffset = getNextOffset(e);\n    if (!dragging.current) {\n      dragging.current = true;\n      if (handlers.current.onDrag) {\n        handlers.current.onDrag(true);\n      }\n      if (handlers.current.onPositionChange) {\n        handlers.current.onPositionChange(nextOffset);\n      }\n    }\n    if (prevPosition.current === nextOffset) {\n      return;\n    }\n    prevPosition.current = nextOffset;\n    if (onPositionChange) {\n      onPositionChange(nextOffset);\n    }\n  };\n\n  let onMouseUp = (e: MouseEvent) => {\n    const target = e.target as HTMLElement;\n    dragging.current = false;\n    let nextOffset = getNextOffset(e);\n    if (handlers.current.onDrag) {\n      handlers.current.onDrag(false);\n    }\n    if (handlers.current.onPositionChange) {\n      handlers.current.onPositionChange(nextOffset);\n    }\n\n    draggingElements.splice(draggingElements.indexOf(target), 1);\n    window.removeEventListener('mouseup', onMouseUp, false);\n    window.removeEventListener('mousemove', onMouseDragged, false);\n  };\n\n  let onMouseDown = (e: React.MouseEvent<HTMLElement>) => {\n    const target = e.currentTarget;\n    // If we're already handling dragging on a descendant with useDrag1D, then\n    // we don't want to handle the drag motion on this target as well.\n    if (draggingElements.some(elt => target.contains(elt))) {\n      return;\n    }\n    draggingElements.push(target);\n    window.addEventListener('mousemove', onMouseDragged, false);\n    window.addEventListener('mouseup', onMouseUp, false);\n  };\n\n  let onMouseEnter = () => {\n    if (onHover) {\n      onHover(true);\n    }\n  };\n\n  let onMouseOut = () => {\n    if (onHover) {\n      onHover(false);\n    }\n  };\n\n  let onKeyDown = (e) => {\n    switch (e.key) {\n      case 'Left':\n      case 'ArrowLeft':\n        if (orientation === 'horizontal') {\n          e.preventDefault();\n          if (onDecrement && !reverse) {\n            onDecrement();\n          } else if (onIncrement && reverse) {\n            onIncrement();\n          }\n        }\n        break;\n      case 'Up':\n      case 'ArrowUp':\n        if (orientation === 'vertical') {\n          e.preventDefault();\n          if (onDecrement && !reverse) {\n            onDecrement();\n          } else if (onIncrement && reverse) {\n            onIncrement();\n          }\n        }\n        break;\n      case 'Right':\n      case 'ArrowRight':\n        if (orientation === 'horizontal') {\n          e.preventDefault();\n          if (onIncrement && !reverse) {\n            onIncrement();\n          } else if (onDecrement && reverse) {\n            onDecrement();\n          }\n        }\n        break;\n      case 'Down':\n      case 'ArrowDown':\n        if (orientation === 'vertical') {\n          e.preventDefault();\n          if (onIncrement && !reverse) {\n            onIncrement();\n          } else if (onDecrement && reverse) {\n            onDecrement();\n          }\n        }\n        break;\n      case 'Home':\n        e.preventDefault();\n        if (onDecrementToMin) {\n          onDecrementToMin();\n        }\n        break;\n      case 'End':\n        e.preventDefault();\n        if (onIncrementToMax) {\n          onIncrementToMax();\n        }\n        break;\n      case 'Enter':\n        e.preventDefault();\n        if (onCollapseToggle) {\n          onCollapseToggle();\n        }\n        break;\n    }\n  };\n\n  return {onMouseDown, onMouseEnter, onMouseOut, onKeyDown};\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useEffect, useRef} from 'react';\n\ninterface GlobalListeners {\n  addGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void,\n  addGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void,\n  removeGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void,\n  removeGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void,\n  removeAllGlobalListeners(): void\n}\n\nexport function useGlobalListeners(): GlobalListeners {\n  let globalListeners = useRef(new Map());\n  let addGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    // Make sure we remove the listener after it is called with the `once` option.\n    let fn = options?.once ? (...args) => {\n      globalListeners.current.delete(listener);\n      listener(...args);\n    } : listener;\n    globalListeners.current.set(listener, {type, eventTarget, fn, options});\n    eventTarget.addEventListener(type, listener, options);\n  }, []);\n  let removeGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    let fn = globalListeners.current.get(listener)?.fn || listener;\n    eventTarget.removeEventListener(type, fn, options);\n    globalListeners.current.delete(listener);\n  }, []);\n  let removeAllGlobalListeners = useCallback(() => {\n    globalListeners.current.forEach((value, key) => {\n      removeGlobalListener(value.eventTarget, value.type, key, value.options);\n    });\n  }, [removeGlobalListener]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return removeAllGlobalListeners;\n  }, [removeAllGlobalListeners]);\n\n  return {addGlobalListener, removeGlobalListener, removeAllGlobalListeners};\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMProps} from '@react-types/shared';\nimport {useId} from './useId';\n\n/**\n * Merges aria-label and aria-labelledby into aria-labelledby when both exist.\n * @param props - Aria label props.\n * @param defaultLabel - Default value for aria-label when not present.\n */\nexport function useLabels(props: DOMProps & AriaLabelingProps, defaultLabel?: string): DOMProps & AriaLabelingProps {\n  let {\n    id,\n    'aria-label': label,\n    'aria-labelledby': labelledBy\n  } = props;\n\n  // If there is both an aria-label and aria-labelledby,\n  // combine them by pointing to the element itself.\n  id = useId(id);\n  if (labelledBy && label) {\n    let ids = new Set([id, ...labelledBy.trim().split(/\\s+/)]);\n    labelledBy = [...ids].join(' ');\n  } else if (labelledBy) {\n    labelledBy = labelledBy.trim().split(/\\s+/).join(' ');\n  }\n\n  // If no labels are provided, use the default\n  if (!label && !labelledBy && defaultLabel) {\n    label = defaultLabel;\n  }\n\n  return {\n    id,\n    'aria-label': label,\n    'aria-labelledby': labelledBy\n  };\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {MutableRefObject, useMemo, useRef} from 'react';\n\n/**\n * Offers an object ref for a given callback ref or an object ref. Especially\n * helfpul when passing forwarded refs (created using `React.forwardRef`) to\n * React Aria Hooks.\n *\n * @param forwardedRef The original ref intended to be used.\n * @returns An object ref that updates the given ref.\n * @see https://reactjs.org/docs/forwarding-refs.html\n */\nexport function useObjectRef<T>(forwardedRef?: ((instance: T | null) => void) | MutableRefObject<T | null> | null): MutableRefObject<T> {\n  const objRef = useRef<T>();\n  return useMemo(() => ({\n    get current() {\n      return objRef.current;\n    },\n    set current(value) {\n      objRef.current = value;\n      if (typeof forwardedRef === 'function') {\n        forwardedRef(value);\n      } else if (forwardedRef) {\n        forwardedRef.current = value;\n      }\n    }\n  }), [forwardedRef]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {EffectCallback, useEffect, useRef} from 'react';\n\n// Like useEffect, but only called for updates after the initial render.\nexport function useUpdateEffect(effect: EffectCallback, dependencies: any[]) {\n  const isInitialMount = useRef(true);\n  const lastDeps = useRef<any[] | null>(null);\n\n  useEffect(() => {\n    isInitialMount.current = true;\n    return () => {\n      isInitialMount.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false;\n    } else if (!lastDeps.current || dependencies.some((dep, i) => !Object.is(dep, lastDeps[i]))) {\n      effect();\n    }\n    lastDeps.current = dependencies;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n", "import {RefObject, useEffect} from 'react';\n\nfunction hasResizeObserver() {\n  return typeof window.ResizeObserver !== 'undefined';\n}\n\ntype useResizeObserverOptionsType<T> = {\n  ref: RefObject<T | undefined> | undefined,\n  onResize: () => void\n}\n\nexport function useResizeObserver<T extends Element>(options: useResizeObserverOptionsType<T>) {\n  const {ref, onResize} = options;\n\n  useEffect(() => {\n    let element = ref?.current;\n    if (!element) {\n      return;\n    }\n\n    if (!hasResizeObserver()) {\n      window.addEventListener('resize', onResize, false);\n      return () => {\n        window.removeEventListener('resize', onResize, false);\n      };\n    } else {\n\n      const resizeObserverInstance = new window.ResizeObserver((entries) => {\n        if (!entries.length) {\n          return;\n        }\n\n        onResize();\n      });\n      resizeObserverInstance.observe(element);\n\n      return () => {\n        if (element) {\n          resizeObserverInstance.unobserve(element);\n        }\n      };\n    }\n\n  }, [onResize, ref]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {MutableRefObject, RefObject} from 'react';\nimport {useLayoutEffect} from './';\n\ninterface ContextValue<T> {\n  ref?: MutableRefObject<T>\n}\n\n// Syncs ref from context with ref passed to hook\nexport function useSyncRef<T>(context?: ContextValue<T> | null, ref?: RefObject<T>) {\n  useLayoutEffect(() => {\n    if (context && context.ref && ref) {\n      context.ref.current = ref.current;\n      return () => {\n        context.ref.current = null;\n      };\n    }\n  });\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function getScrollParent(node: Element): Element {\n  if (isScrollable(node)) {\n    node = node.parentElement;\n  }\n\n  while (node && !isScrollable(node)) {\n    node = node.parentElement;\n  }\n\n  return node || document.scrollingElement || document.documentElement;\n}\n\nexport function isScrollable(node: Element): boolean {\n  let style = window.getComputedStyle(node);\n  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\ninterface ViewportSize {\n  width: number,\n  height: number\n}\n\n// @ts-ignore\nlet visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nexport function useViewportSize(): ViewportSize {\n  let isSSR = useIsSSR();\n  let [size, setSize] = useState(() => isSSR ? {width: 0, height: 0} : getViewportSize());\n\n  useEffect(() => {\n    // Use visualViewport api to track available height even on iOS virtual keyboard opening\n    let onResize = () => {\n      setSize(size => {\n        let newSize = getViewportSize();\n        if (newSize.width === size.width && newSize.height === size.height) {\n          return size;\n        }\n        return newSize;\n      });\n    };\n\n    if (!visualViewport) {\n      window.addEventListener('resize', onResize);\n    } else {\n      visualViewport.addEventListener('resize', onResize);\n    }\n\n    return () => {\n      if (!visualViewport) {\n        window.removeEventListener('resize', onResize);\n      } else {\n        visualViewport.removeEventListener('resize', onResize);\n      }\n    };\n  }, []);\n\n  return size;\n}\n\nfunction getViewportSize(): ViewportSize {\n  return {\n    width: visualViewport?.width || window.innerWidth,\n    height: visualViewport?.height || window.innerHeight\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps} from '@react-types/shared';\nimport {useLayoutEffect} from './useLayoutEffect';\nimport {useState} from 'react';\n\nlet descriptionId = 0;\nconst descriptionNodes = new Map<string, {refCount: number, element: Element}>();\n\nexport function useDescription(description?: string): AriaLabelingProps {\n  let [id, setId] = useState(undefined);\n\n  useLayoutEffect(() => {\n    if (!description) {\n      return;\n    }\n\n    let desc = descriptionNodes.get(description);\n    if (!desc) {\n      let id = `react-aria-description-${descriptionId++}`;\n      setId(id);\n\n      let node = document.createElement('div');\n      node.id = id;\n      node.style.display = 'none';\n      node.textContent = description;\n      document.body.appendChild(node);\n      desc = {refCount: 0, element: node};\n      descriptionNodes.set(description, desc);\n    } else {\n      setId(desc.element.id);\n    }\n\n    desc.refCount++;\n    return () => {\n      if (--desc.refCount === 0) {\n        desc.element.remove();\n        descriptionNodes.delete(description);\n      }\n    };\n  }, [description]);\n\n  return {\n    'aria-describedby': description ? id : undefined\n  };\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject, useEffect} from 'react';\nimport {useEffectEvent} from './useEffectEvent';\n\nexport function useEvent<K extends keyof GlobalEventHandlersEventMap>(\n  ref: RefObject<EventTarget>,\n  event: K,\n  handler?: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let handleEvent = useEffectEvent(handler);\n  let isDisabled = handler == null;\n\n  useEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    let element = ref.current;\n    element.addEventListener(event, handleEvent, options);\n    return () => {\n      element.removeEventListener(event, handleEvent, options);\n    };\n  }, [ref, event, options, isDisabled, handleEvent]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getScrollParent} from './';\n\ninterface ScrollIntoViewportOpts {\n  /** The optional containing element of the target to be centered in the viewport. */\n  containingElement?: Element\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nexport function scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  let offsetX = relativeOffset(scrollView, element, 'left');\n  let offsetY = relativeOffset(scrollView, element, 'top');\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n\n  // Account for top/left border offsetting the scroll top/Left\n  let {borderTopWidth, borderLeftWidth} = getComputedStyle(scrollView);\n  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);\n  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);\n  // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width\n  let maxX = borderAdjustedX + scrollView.clientWidth;\n  let maxY = borderAdjustedY + scrollView.clientHeight;\n\n  if (offsetX <= x) {\n    x = offsetX - parseInt(borderLeftWidth, 10);\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= borderAdjustedY) {\n    y = offsetY - parseInt(borderTopWidth, 10);\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */\nfunction relativeOffset(ancestor: HTMLElement, child: HTMLElement, axis: 'left'|'top') {\n  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n  let sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      // Stop once we have found the ancestor we are interested in.\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      // If the ancestor is not `position:relative`, then we stop at\n      // _its_ offset parent, and we subtract off _its_ offset, so that\n      // we end up with the proper offset from child to ancestor.\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent as HTMLElement;\n  }\n  return sum;\n}\n\n/**\n * Scrolls the `targetElement` so it is visible in the viewport. Accepts an optional `opts.containingElement`\n * that will be centered in the viewport prior to scrolling the targetElement into view. If scrolling is prevented on\n * the body (e.g. targetElement is in a popover), this will only scroll the scroll parents of the targetElement up to but not including the body itself.\n */\nexport function scrollIntoViewport(targetElement: Element, opts?: ScrollIntoViewportOpts) {\n  if (document.contains(targetElement)) {\n    let root = document.scrollingElement || document.documentElement;\n    let isScrollPrevented = window.getComputedStyle(root).overflow === 'hidden';\n    // If scrolling is not currently prevented then we arent in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view\n    if (!isScrollPrevented) {\n      let {left: originalLeft, top: originalTop} = targetElement.getBoundingClientRect();\n\n      // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()\n      // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically\n      targetElement?.scrollIntoView?.({block: 'nearest'});\n      let {left: newLeft, top: newTop} = targetElement.getBoundingClientRect();\n      // Account for sub pixel differences from rounding\n      if ((Math.abs(originalLeft - newLeft) > 1) || (Math.abs(originalTop - newTop) > 1)) {\n        opts?.containingElement?.scrollIntoView?.({block: 'center', inline: 'center'});\n        targetElement.scrollIntoView?.({block: 'nearest'});\n      }\n    } else {\n      let scrollParent = getScrollParent(targetElement);\n      // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.\n      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {\n        scrollIntoView(scrollParent as HTMLElement, targetElement as HTMLElement);\n        targetElement = scrollParent;\n        scrollParent = getScrollParent(targetElement);\n      }\n    }\n  }\n}\n", "/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAndroid} from './platform';\n\n// Original licensing for the following method can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/blob/3c713d513195a53788b3f8bb4b70279d68b15bcc/packages/react-interactions/events/src/dom/shared/index.js#L74-L87\n\n// Keyboards, Assistive Technologies, and element.click() all produce a \"virtual\"\n// click event. This is a method of inferring such clicks. Every browser except\n// IE 11 only sets a zero value of \"detail\" for click events that are \"virtual\".\n// However, IE 11 uses a zero value for all click events. For IE 11 we rely on\n// the quirk that it produces click events that are of type PointerEvent, and\n// where only the \"virtual\" click lacks a pointerType field.\n\nexport function isVirtualClick(event: MouseEvent | PointerEvent): boolean {\n  // JAWS/NVDA with Firefox.\n  if ((event as any).mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n\n  // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n  // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n  // to detect TalkBack virtual clicks.\n  if (isAndroid() && (event as PointerEvent).pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n\n  return event.detail === 0 && !(event as PointerEvent).pointerType;\n}\n\nexport function isVirtualPointerEvent(event: PointerEvent) {\n  // If the pointer size is zero, then we assume it's from a screen reader.\n  // Android TalkBack double tap will sometimes return a event with width and height of 1\n  // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n  // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n  // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n  // Talkback double tap from Windows Firefox touch screen press\n  return (\n    (!isAndroid() && event.width === 0 && event.height === 0) ||\n    (event.width === 1 &&\n      event.height === 1 &&\n      event.pressure === 0 &&\n      event.detail === 0 &&\n      event.pointerType === 'mouse'\n    )\n  );\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/* eslint-disable rulesdir/pure-render */\n\nimport {useRef} from 'react';\n\nexport function useDeepMemo<T>(value: T, isEqual: (a: T, b: T) => boolean): T {\n  // Using a ref during render is ok here because it's only an optimization  both values are equivalent.\n  // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.\n  let lastValue = useRef(null);\n  if (value && lastValue.current && isEqual(value, lastValue.current)) {\n    value = lastValue.current;\n  }\n\n  lastValue.current = value;\n  return value;\n}\n", "/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {RefObject, useEffect, useRef} from 'react';\nimport {useEffectEvent} from './useEffectEvent';\n\nexport function useFormReset<T>(\n  ref: RefObject<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>,\n  initialValue: T,\n  onReset: (value: T) => void\n) {\n  let resetValue = useRef(initialValue);\n  let handleReset = useEffectEvent(() => {\n    if (onReset) {\n      onReset(resetValue.current);\n    }\n  });\n\n  useEffect(() => {\n    let form = ref?.current?.form;\n    form?.addEventListener('reset', handleReset);\n    return () => {\n      form?.removeEventListener('reset', handleReset);\n    };\n  }, [ref, handleReset]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {Pressable} from './Pressable';\nexport {PressResponder, ClearPressResponder} from './PressResponder';\nexport {useFocus} from './useFocus';\nexport {\n  isFocusVisible,\n  getInteractionModality,\n  setInteractionModality,\n  useInteractionModality,\n  useFocusVisible,\n  useFocusVisibleListener\n} from './useFocusVisible';\nexport {useFocusWithin} from './useFocusWithin';\nexport {useHover} from './useHover';\nexport {useInteractOutside} from './useInteractOutside';\nexport {useKeyboard} from './useKeyboard';\nexport {useMove} from './useMove';\nexport {usePress} from './usePress';\nexport {useScrollWheel} from './useScrollWheel';\nexport {useLongPress} from './useLongPress';\n\nexport type {FocusProps, FocusResult} from './useFocus';\nexport type {FocusVisibleHandler, FocusVisibleProps, FocusVisibleResult, Modality} from './useFocusVisible';\nexport type {FocusWithinProps, FocusWithinResult} from './useFocusWithin';\nexport type {HoverProps, HoverResult} from './useHover';\nexport type {InteractOutsideProps} from './useInteractOutside';\nexport type {KeyboardProps, KeyboardResult} from './useKeyboard';\nexport type {PressProps, PressHookProps, PressResult} from './usePress';\nexport type {PressEvent, PressEvents, MoveStartEvent, MoveMoveEvent, MoveEndEvent, MoveEvents, HoverEvent, HoverEvents, FocusEvents, KeyboardEvents} from '@react-types/shared';\nexport type {MoveResult} from './useMove';\nexport type {LongPressProps, LongPressResult} from './useLongPress';\nexport type {ScrollWheelProps} from './useScrollWheel';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes} from '@react-types/shared';\nimport {mergeProps, useObjectRef} from '@react-aria/utils';\nimport {PressProps, usePress} from './usePress';\nimport React, {ForwardedRef, ReactElement} from 'react';\n\ninterface PressableProps extends PressProps {\n  children: ReactElement<DOMAttributes, string>\n}\n\nexport const Pressable = React.forwardRef(({children, ...props}: PressableProps, ref: ForwardedRef<HTMLElement>) => {\n  ref = useObjectRef(ref);\n  let {pressProps} = usePress({...props, ref});\n  let child = React.Children.only(children);\n  return React.cloneElement(\n    child,\n    // @ts-ignore\n    {ref, ...mergeProps(child.props, pressProps)}\n  );\n});\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, getOwnerWindow, isMac, isVirtualClick, isVirtualPointerEvent, mergeProps, openLink, useEffectEvent, useGlobalListeners, useSyncRef} from '@react-aria/utils';\nimport {PressResponderContext} from './context';\nimport {RefObject, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  ignoreClickAfterPress: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase) {\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _, // Removing `ref` from `domProps` because TypeScript is dumb\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.isOverTarget && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target as Element)) {\n          if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred.\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', onKeyUp, false);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onKeyUp(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target as Element) && state.target) {\n          triggerPressUp(createEvent(state.target, e), 'keyboard');\n        }\n      },\n      onClick(e) {\n        if (e && !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            // Ensure the element receives focus (VoiceOver on iOS does not do this)\n            if (!isDisabled && !preventFocusOnPress) {\n              focusWithoutScrolling(e.currentTarget);\n            }\n\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(e.target as Element, e.key)) {\n          e.preventDefault();\n        }\n\n        let target = e.target as Element;\n        let shouldStopPropagation = triggerPressEnd(createEvent(state.target, e), 'keyboard', state.target.contains(target));\n        removeAllGlobalListeners();\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on pointer down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget as Element)) {\n          e.preventDefault();\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n\n          if (!isDisabled && !preventFocusOnPress) {\n            focusWithoutScrolling(e.currentTarget);\n          }\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointermove', onPointerMove, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (e.button === 0) {\n          // Chrome and Firefox on touch Windows devices require mouse down events\n          // to be canceled in addition to pointer events, or an extra asynchronous\n          // focus event will be fired.\n          if (shouldPreventDefault(e.currentTarget as Element)) {\n            e.preventDefault();\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!e.currentTarget.contains(e.target as Element) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks\n        // Safari on iOS sometimes fires pointerup events, even\n        // when the touch isn't over the target, so double check.\n        if (e.button === 0 && isOverTarget(e, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n      // Use pointer move events instead to implement our own hit testing.\n      // See https://bugs.webkit.org/show_bug.cgi?id=199803\n      let onPointerMove = (e: PointerEvent) => {\n        if (e.pointerId !== state.activePointerId) {\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            triggerPressStart(createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (isOverTarget(e, state.target) && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType);\n          } else if (state.isOverTarget && state.pointerType != null) {\n            triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          }\n\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) {\n            restoreTextSelection(state.target);\n          }\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else {\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on mouse down and handle focusing the pressable element ourselves.\n        if (shouldPreventDefault(e.currentTarget)) {\n          e.preventDefault();\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        state.isPressed = false;\n        removeAllGlobalListeners();\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && isOverTarget(e, state.target) && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType);\n        } else if (state.target && state.isOverTarget && state.pointerType != null) {\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n        // on the emulated mouse event and handle focusing the pressable element ourselves.\n        if (!isDisabled && !preventFocusOnPress) {\n          focusWithoutScrolling(e.currentTarget);\n        }\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(e);\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && (e.target as Element).contains(state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!e.currentTarget.contains(e.target as Element)) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp\n  ]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        restoreTextSelection(ref.current.target ?? undefined);\n      }\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefault(target: Element) {\n  // We cannot prevent default if the target is a draggable element.\n  return !(target instanceof HTMLElement) || !target.hasAttribute('draggable');\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getOwnerDocument, isIOS, runAfterTransition} from '@react-aria/utils';\n\n// Safari on iOS starts selecting text on long press. The only way to avoid this, it seems,\n// is to add user-select: none to the entire page. Adding it to the pressable element prevents\n// that element from being selected, but nearby elements may still receive selection. We add\n// user-select: none on touch start, and remove it again on touch end to prevent this.\n// This must be implemented using global state to avoid race conditions between multiple elements.\n\n// There are three possible states due to the delay before removing user-select: none after\n// pointer up. The 'default' state always transitions to the 'disabled' state, which transitions\n// to 'restoring'. The 'restoring' state can either transition back to 'disabled' or 'default'.\n\n// For non-iOS devices, we apply user-select: none to the pressed element instead to avoid possible\n// performance issues that arise from applying and removing user-select: none to the entire page\n// (see https://github.com/adobe/react-spectrum/issues/1609).\ntype State = 'default' | 'disabled' | 'restoring';\n\n// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet state: State = 'default';\nlet savedUserSelect = '';\nlet modifiedElementMap = new WeakMap<Element, string>();\n\nexport function disableTextSelection(target?: Element) {\n  if (isIOS()) {\n    if (state === 'default') {\n      // eslint-disable-next-line no-restricted-globals\n      const documentObject = getOwnerDocument(target);\n      savedUserSelect = documentObject.documentElement.style.webkitUserSelect;\n      documentObject.documentElement.style.webkitUserSelect = 'none';\n    }\n\n    state = 'disabled';\n  } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n    // If not iOS, store the target's original user-select and change to user-select: none\n    // Ignore state since it doesn't apply for non iOS\n    modifiedElementMap.set(target, target.style.userSelect);\n    target.style.userSelect = 'none';\n  }\n}\n\nexport function restoreTextSelection(target?: Element) {\n  if (isIOS()) {\n    // If the state is already default, there's nothing to do.\n    // If it is restoring, then there's no need to queue a second restore.\n    if (state !== 'disabled') {\n      return;\n    }\n\n    state = 'restoring';\n\n    // There appears to be a delay on iOS where selection still might occur\n    // after pointer up, so wait a bit before removing user-select.\n    setTimeout(() => {\n      // Wait for any CSS transitions to complete so we don't recompute style\n      // for the whole page in the middle of the animation and cause jank.\n      runAfterTransition(() => {\n        // Avoid race conditions\n        if (state === 'restoring') {\n          // eslint-disable-next-line no-restricted-globals\n          const documentObject = getOwnerDocument(target);\n          if (documentObject.documentElement.style.webkitUserSelect === 'none') {\n            documentObject.documentElement.style.webkitUserSelect = savedUserSelect || '';\n          }\n\n          savedUserSelect = '';\n          state = 'default';\n        }\n      });\n    }, 300);\n  } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n    // If not iOS, restore the target's original user-select if any\n    // Ignore state since it doesn't apply for non iOS\n    if (target && modifiedElementMap.has(target)) {\n      let targetOldUserSelect = modifiedElementMap.get(target);\n\n      if (target.style.userSelect === 'none' && targetOldUserSelect) {\n        target.style.userSelect = targetOldUserSelect;\n      }\n\n      if (target.getAttribute('style') === '') {\n        target.removeAttribute('style');\n      }\n      modifiedElementMap.delete(target);\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {PressProps} from './usePress';\nimport React, {MutableRefObject} from 'react';\n\ninterface IPressResponderContext extends PressProps {\n  register(): void,\n  ref?: MutableRefObject<FocusableElement>\n}\n\nexport const PressResponderContext = React.createContext<IPressResponderContext>({register: () => {}});\nPressResponderContext.displayName = 'PressResponderContext';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {mergeProps, useObjectRef, useSyncRef} from '@react-aria/utils';\nimport {PressProps} from './usePress';\nimport {PressResponderContext} from './context';\nimport React, {ForwardedRef, ReactNode, useContext, useEffect, useMemo, useRef} from 'react';\n\ninterface PressResponderProps extends PressProps {\n  children: ReactNode\n}\n\nexport const PressResponder = React.forwardRef(({children, ...props}: PressResponderProps, ref: ForwardedRef<FocusableElement>) => {\n  let isRegistered = useRef(false);\n  let prevContext = useContext(PressResponderContext);\n  ref = useObjectRef(ref || prevContext?.ref);\n  let context = mergeProps(prevContext || {}, {\n    ...props,\n    ref,\n    register() {\n      isRegistered.current = true;\n      if (prevContext) {\n        prevContext.register();\n      }\n    }\n  });\n\n  useSyncRef(prevContext, ref);\n\n  useEffect(() => {\n    if (!isRegistered.current) {\n      console.warn(\n        'A PressResponder was rendered without a pressable child. ' +\n        'Either call the usePress hook, or wrap your DOM node with <Pressable> component.'\n      );\n      isRegistered.current = true; // only warn once in strict mode.\n    }\n  }, []);\n\n  return (\n    <PressResponderContext.Provider value={context}>\n      {children}\n    </PressResponderContext.Provider>\n  );\n});\n\nexport function ClearPressResponder({children}: {children: ReactNode}) {\n  let context = useMemo(() => ({register: () => {}}), []);\n  return (\n    <PressResponderContext.Provider value={context}>\n      {children}\n    </PressResponderContext.Provider>\n  );\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, FocusableElement, FocusEvents} from '@react-types/shared';\nimport {FocusEvent, useCallback} from 'react';\nimport {useSyntheticBlurEvent} from './utils';\n\nexport interface FocusProps<Target = FocusableElement> extends FocusEvents<Target> {\n  /** Whether the focus events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface FocusResult<Target = FocusableElement> {\n  /** Props to spread onto the target element. */\n  focusProps: DOMAttributes<Target>\n}\n\n/**\n * Handles focus events for the immediate target.\n * Focus events on child elements will be ignored.\n */\nexport function useFocus<Target extends FocusableElement = FocusableElement>(props: FocusProps<Target>): FocusResult<Target> {\n  let {\n    isDisabled,\n    onFocus: onFocusProp,\n    onBlur: onBlurProp,\n    onFocusChange\n  } = props;\n\n  const onBlur: FocusProps<Target>['onBlur'] = useCallback((e: FocusEvent<Target>) => {\n    if (e.target === e.currentTarget) {\n      if (onBlurProp) {\n        onBlurProp(e);\n      }\n\n      if (onFocusChange) {\n        onFocusChange(false);\n      }\n\n      return true;\n    }\n  }, [onBlurProp, onFocusChange]);\n\n\n  const onSyntheticFocus = useSyntheticBlurEvent<Target>(onBlur);\n\n  const onFocus: FocusProps<Target>['onFocus'] = useCallback((e: FocusEvent<Target>) => {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (e.target === e.currentTarget && document.activeElement === e.target) {\n      if (onFocusProp) {\n        onFocusProp(e);\n      }\n\n      if (onFocusChange) {\n        onFocusChange(true);\n      }\n\n      onSyntheticFocus(e);\n    }\n  }, [onFocusChange, onFocusProp, onSyntheticFocus]);\n\n  return {\n    focusProps: {\n      onFocus: (!isDisabled && (onFocusProp || onFocusChange || onBlurProp)) ? onFocus : undefined,\n      onBlur: (!isDisabled && (onBlurProp || onFocusChange)) ? onBlur : undefined\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent as ReactFocusEvent, useCallback, useRef} from 'react';\nimport {useEffectEvent, useLayoutEffect} from '@react-aria/utils';\n\nexport class SyntheticFocusEvent<Target = Element> implements ReactFocusEvent<Target> {\n  nativeEvent: FocusEvent;\n  target: EventTarget & Target;\n  currentTarget: EventTarget & Target;\n  relatedTarget: Element;\n  bubbles: boolean;\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  eventPhase: number;\n  isTrusted: boolean;\n  timeStamp: number;\n  type: string;\n\n  constructor(type: string, nativeEvent: FocusEvent) {\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEvent.target as EventTarget & Target;\n    this.currentTarget = nativeEvent.currentTarget as EventTarget & Target;\n    this.relatedTarget = nativeEvent.relatedTarget as Element;\n    this.bubbles = nativeEvent.bubbles;\n    this.cancelable = nativeEvent.cancelable;\n    this.defaultPrevented = nativeEvent.defaultPrevented;\n    this.eventPhase = nativeEvent.eventPhase;\n    this.isTrusted = nativeEvent.isTrusted;\n    this.timeStamp = nativeEvent.timeStamp;\n    this.type = type;\n  }\n\n  isDefaultPrevented(): boolean {\n    return this.nativeEvent.defaultPrevented;\n  }\n\n  preventDefault(): void {\n    this.defaultPrevented = true;\n    this.nativeEvent.preventDefault();\n  }\n\n  stopPropagation(): void {\n    this.nativeEvent.stopPropagation();\n    this.isPropagationStopped = () => true;\n  }\n\n  isPropagationStopped(): boolean {\n    return false;\n  }\n\n  persist() {}\n}\n\nexport function useSyntheticBlurEvent<Target = Element>(onBlur: (e: ReactFocusEvent<Target>) => void) {\n  let stateRef = useRef({\n    isFocused: false,\n    observer: null as MutationObserver | null\n  });\n\n  // Clean up MutationObserver on unmount. See below.\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    const state = stateRef.current;\n    return () => {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n\n  let dispatchBlur = useEffectEvent((e: SyntheticFocusEvent<Target>) => {\n    onBlur?.(e);\n  });\n\n  // This function is called during a React onFocus event.\n  return useCallback((e: ReactFocusEvent<Target>) => {\n    // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n    // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n    // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n    // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n    if (\n      e.target instanceof HTMLButtonElement ||\n      e.target instanceof HTMLInputElement ||\n      e.target instanceof HTMLTextAreaElement ||\n      e.target instanceof HTMLSelectElement\n    ) {\n      stateRef.current.isFocused = true;\n\n      let target = e.target;\n      let onBlurHandler: EventListenerOrEventListenerObject | null = (e) => {\n        stateRef.current.isFocused = false;\n\n        if (target.disabled) {\n          // For backward compatibility, dispatch a (fake) React synthetic event.\n          dispatchBlur(new SyntheticFocusEvent('blur', e as FocusEvent));\n        }\n\n        // We no longer need the MutationObserver once the target is blurred.\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n\n      target.addEventListener('focusout', onBlurHandler, {once: true});\n\n      stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          stateRef.current.observer?.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent('blur', {relatedTarget: relatedTargetEl}));\n          target.dispatchEvent(new FocusEvent('focusout', {bubbles: true, relatedTarget: relatedTargetEl}));\n        }\n      });\n\n      stateRef.current.observer.observe(target, {attributes: true, attributeFilter: ['disabled']});\n    }\n  }, [dispatchBlur]);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {isMac, isVirtualClick} from '@react-aria/utils';\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\ntype HandlerEvent = PointerEvent | MouseEvent | KeyboardEvent | FocusEvent | null;\ntype Handler = (modality: Modality, e: HandlerEvent) => void;\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusVisibleResult {\n  /** Whether keyboard focus is visible globally. */\n  isFocusVisible: boolean\n}\n\nlet currentModality: null | Modality = null;\nlet changeHandlers = new Set<Handler>();\nlet hasSetupGlobalListeners = false;\nlet hasEventBeforeFocus = false;\nlet hasBlurredWindowRecently = false;\n\n// Only Tab or Esc keys will make focus visible on text input elements\nconst FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction triggerChangeHandlers(modality: Modality, e: HandlerEvent) {\n  for (let handler of changeHandlers) {\n    handler(modality, e);\n  }\n}\n\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction isValidKey(e: KeyboardEvent) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || (!isMac() && e.altKey) || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\n\nfunction handleKeyboardEvent(e: KeyboardEvent) {\n  hasEventBeforeFocus = true;\n  if (isValidKey(e)) {\n    currentModality = 'keyboard';\n    triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction handlePointerEvent(e: PointerEvent | MouseEvent) {\n  currentModality = 'pointer';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    hasEventBeforeFocus = true;\n    triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction handleClickEvent(e: MouseEvent) {\n  if (isVirtualClick(e)) {\n    hasEventBeforeFocus = true;\n    currentModality = 'virtual';\n  }\n}\n\nfunction handleFocusEvent(e: FocusEvent) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document) {\n    return;\n  }\n\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {\n    currentModality = 'virtual';\n    triggerChangeHandlers('virtual', e);\n  }\n\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = false;\n}\n\nfunction handleWindowBlur() {\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = true;\n}\n\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction setupGlobalFocusEvents() {\n  if (typeof window === 'undefined' || hasSetupGlobalListeners) {\n    return;\n  }\n\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function () {\n    hasEventBeforeFocus = true;\n    focus.apply(this, arguments as unknown as [options?: FocusOptions | undefined]);\n  };\n\n  document.addEventListener('keydown', handleKeyboardEvent, true);\n  document.addEventListener('keyup', handleKeyboardEvent, true);\n  document.addEventListener('click', handleClickEvent, true);\n\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  window.addEventListener('focus', handleFocusEvent, true);\n  window.addEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerdown', handlePointerEvent, true);\n    document.addEventListener('pointermove', handlePointerEvent, true);\n    document.addEventListener('pointerup', handlePointerEvent, true);\n  } else {\n    document.addEventListener('mousedown', handlePointerEvent, true);\n    document.addEventListener('mousemove', handlePointerEvent, true);\n    document.addEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  hasSetupGlobalListeners = true;\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalFocusEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalFocusEvents);\n  }\n}\n\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean {\n  return currentModality !== 'pointer';\n}\n\nexport function getInteractionModality(): Modality | null {\n  return currentModality;\n}\n\nexport function setInteractionModality(modality: Modality) {\n  currentModality = modality;\n  triggerChangeHandlers(modality, null);\n}\n\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null {\n  setupGlobalFocusEvents();\n\n  let [modality, setModality] = useState(currentModality);\n  useEffect(() => {\n    let handler = () => {\n      setModality(currentModality);\n    };\n\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  }, []);\n\n  return useIsSSR() ? null : modality;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction isKeyboardFocusEvent(isTextInput: boolean, modality: Modality, e: HandlerEvent) {\n  isTextInput = isTextInput || \n    (e?.target instanceof HTMLInputElement && !nonTextInputTypes.has(e?.target?.type)) ||\n    e?.target instanceof HTMLTextAreaElement ||\n    (e?.target instanceof HTMLElement && e?.target.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof KeyboardEvent && !FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props: FocusVisibleProps = {}): FocusVisibleResult {\n  let {isTextInput, autoFocus} = props;\n  let [isFocusVisibleState, setFocusVisible] = useState(autoFocus || isFocusVisible());\n  useFocusVisibleListener((isFocusVisible) => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {isTextInput});\n\n  return {isFocusVisible: isFocusVisibleState};\n}\n\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {isTextInput?: boolean}): void {\n  setupGlobalFocusEvents();\n\n  useEffect(() => {\n    let handler = (modality: Modality, e: HandlerEvent) => {\n      if (!isKeyboardFocusEvent(!!(opts?.isTextInput), modality, e)) {\n        return;\n      }\n      fn(isFocusVisible());\n    };\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes} from '@react-types/shared';\nimport {FocusEvent, useCallback, useRef} from 'react';\nimport {useSyntheticBlurEvent} from './utils';\n\nexport interface FocusWithinProps {\n  /** Whether the focus within events should be disabled. */\n  isDisabled?: boolean,\n  /** Handler that is called when the target element or a descendant receives focus. */\n  onFocusWithin?: (e: FocusEvent) => void,\n  /** Handler that is called when the target element and all descendants lose focus. */\n  onBlurWithin?: (e: FocusEvent) => void,\n  /** Handler that is called when the the focus within state changes. */\n  onFocusWithinChange?: (isFocusWithin: boolean) => void\n}\n\nexport interface FocusWithinResult {\n  /** Props to spread onto the target element. */\n  focusWithinProps: DOMAttributes\n}\n\n/**\n * Handles focus events for the target and its descendants.\n */\nexport function useFocusWithin(props: FocusWithinProps): FocusWithinResult {\n  let {\n    isDisabled,\n    onBlurWithin,\n    onFocusWithin,\n    onFocusWithinChange\n  } = props;\n  let state = useRef({\n    isFocusWithin: false\n  });\n\n  let onBlur = useCallback((e: FocusEvent) => {\n    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n    // when moving focus inside the element. Only trigger if the currentTarget doesn't\n    // include the relatedTarget (where focus is moving).\n    if (state.current.isFocusWithin && !(e.currentTarget as Element).contains(e.relatedTarget as Element)) {\n      state.current.isFocusWithin = false;\n\n      if (onBlurWithin) {\n        onBlurWithin(e);\n      }\n\n      if (onFocusWithinChange) {\n        onFocusWithinChange(false);\n      }\n    }\n  }, [onBlurWithin, onFocusWithinChange, state]);\n\n  let onSyntheticFocus = useSyntheticBlurEvent(onBlur);\n  let onFocus = useCallback((e: FocusEvent) => {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (!state.current.isFocusWithin && document.activeElement === e.target) {\n      if (onFocusWithin) {\n        onFocusWithin(e);\n      }\n\n      if (onFocusWithinChange) {\n        onFocusWithinChange(true);\n      }\n\n      state.current.isFocusWithin = true;\n      onSyntheticFocus(e);\n    }\n  }, [onFocusWithin, onFocusWithinChange, onSyntheticFocus]);\n\n  if (isDisabled) {\n    return {\n      focusWithinProps: {\n        // These should not have been null, that would conflict in mergeProps\n        onFocus: undefined,\n        onBlur: undefined\n      }\n    };\n  }\n\n  return {\n    focusWithinProps: {\n      onFocus,\n      onBlur\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, HoverEvents} from '@react-types/shared';\nimport {useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface HoverProps extends HoverEvents {\n  /** Whether the hover events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface HoverResult {\n  /** Props to spread on the target element. */\n  hoverProps: DOMAttributes,\n  isHovered: boolean\n}\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet globalIgnoreEmulatedMouseEvents = false;\nlet hoverCount = 0;\n\nfunction setGlobalIgnoreEmulatedMouseEvents() {\n  globalIgnoreEmulatedMouseEvents = true;\n\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(() => {\n    globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\n\nfunction handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') {\n    setGlobalIgnoreEmulatedMouseEvents();\n  }\n}\n\nfunction setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerup', handleGlobalPointerEvent);\n  } else {\n    document.addEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n  }\n\n  hoverCount++;\n  return () => {\n    hoverCount--;\n    if (hoverCount > 0) {\n      return;\n    }\n\n    if (typeof PointerEvent !== 'undefined') {\n      document.removeEventListener('pointerup', handleGlobalPointerEvent);\n    } else {\n      document.removeEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n    }\n  };\n}\n\n/**\n * Handles pointer hover interactions for an element. Normalizes behavior\n * across browsers and platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useHover(props: HoverProps): HoverResult {\n  let {\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled\n  } = props;\n\n  let [isHovered, setHovered] = useState(false);\n  let state = useRef({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n\n  useEffect(setupGlobalTouchEvents, []);\n\n  let {hoverProps, triggerHoverEnd} = useMemo(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) {\n        return;\n      }\n\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n\n      if (onHoverStart) {\n        onHoverStart({\n          type: 'hoverstart',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(true);\n      }\n\n      setHovered(true);\n    };\n\n    let triggerHoverEnd = (event, pointerType) => {\n      state.pointerType = '';\n      state.target = null;\n\n      if (pointerType === 'touch' || !state.isHovered) {\n        return;\n      }\n\n      state.isHovered = false;\n      let target = event.currentTarget;\n      if (onHoverEnd) {\n        onHoverEnd({\n          type: 'hoverend',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(false);\n      }\n\n      setHovered(false);\n    };\n\n    let hoverProps: DOMAttributes = {};\n\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = (e) => {\n        if (globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') {\n          return;\n        }\n\n        triggerHoverStart(e, e.pointerType);\n      };\n\n      hoverProps.onPointerLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      };\n    } else {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n\n      hoverProps.onMouseEnter = (e) => {\n        if (!state.ignoreEmulatedMouseEvents && !globalIgnoreEmulatedMouseEvents) {\n          triggerHoverStart(e, 'mouse');\n        }\n\n        state.ignoreEmulatedMouseEvents = false;\n      };\n\n      hoverProps.onMouseLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, 'mouse');\n        }\n      };\n    }\n    return {hoverProps, triggerHoverEnd};\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state]);\n\n  useEffect(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) {\n      triggerHoverEnd({currentTarget: state.target}, state.pointerType);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n\n  return {\n    hoverProps,\n    isHovered\n  };\n}\n\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, useEffectEvent} from '@react-aria/utils';\nimport {RefObject, useEffect, useRef} from 'react';\n\nexport interface InteractOutsideProps {\n  ref: RefObject<Element>,\n  onInteractOutside?: (e: PointerEvent) => void,\n  onInteractOutsideStart?: (e: PointerEvent) => void,\n  /** Whether the interact outside events should be disabled. */\n  isDisabled?: boolean\n}\n\n/**\n * Example, used in components like Dialogs and Popovers so they can close\n * when a user clicks outside them.\n */\nexport function useInteractOutside(props: InteractOutsideProps) {\n  let {ref, onInteractOutside, isDisabled, onInteractOutsideStart} = props;\n  let stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n\n  let onPointerDown = useEffectEvent((e) => {\n    if (onInteractOutside && isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) {\n        onInteractOutsideStart(e);\n      }\n      stateRef.current.isPointerDown = true;\n    }\n  });\n\n  let triggerInteractOutside = useEffectEvent((e: PointerEvent) => {\n    if (onInteractOutside) {\n      onInteractOutside(e);\n    }\n  });\n\n  useEffect(() => {\n    let state = stateRef.current;\n    if (isDisabled) {\n      return;\n    }\n\n    const element = ref.current;\n    const documentObject = getOwnerDocument(element);\n\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== 'undefined') {\n      let onPointerUp = (e) => {\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      // changing these to capture phase fixed combobox\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('pointerup', onPointerUp, true);\n\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('pointerup', onPointerUp, true);\n      };\n    } else {\n      let onMouseUp = (e) => {\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n        } else if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      let onTouchEnd = (e) => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\n\nfunction isValidEvent(event, ref) {\n  if (event.button > 0) {\n    return false;\n  }\n\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) {\n      return false;\n    }\n\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest('[data-react-aria-top-layer]')) {\n      return false;\n    }\n  }\n\n  return ref.current && !ref.current.contains(event.target);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createEventHandler} from './createEventHandler';\nimport {DOMAttributes, KeyboardEvents} from '@react-types/shared';\n\nexport interface KeyboardProps extends KeyboardEvents {\n  /** Whether the keyboard events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface KeyboardResult {\n  /** Props to spread onto the target element. */\n  keyboardProps: DOMAttributes\n}\n\n/**\n * Handles keyboard interactions for a focusable element.\n */\nexport function useKeyboard(props: KeyboardProps): KeyboardResult {\n  return {\n    keyboardProps: props.isDisabled ? {} : {\n      onKeyDown: createEventHandler(props.onKeyDown),\n      onKeyUp: createEventHandler(props.onKeyUp)\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {BaseEvent} from '@react-types/shared';\nimport {SyntheticEvent} from 'react';\n\n/**\n * This function wraps a React event handler to make stopPropagation the default, and support continuePropagation instead.\n */\nexport function createEventHandler<T extends SyntheticEvent>(handler?: (e: BaseEvent<T>) => void): ((e: T) => void) | undefined {\n  if (!handler) {\n    return undefined;\n  }\n\n  let shouldStopPropagation = true;\n  return (e: T) => {\n    let event: BaseEvent<T> = {\n      ...e,\n      preventDefault() {\n        e.preventDefault();\n      },\n      isDefaultPrevented() {\n        return e.isDefaultPrevented();\n      },\n      stopPropagation() {\n        console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');\n      },\n      continuePropagation() {\n        shouldStopPropagation = false;\n      }\n    };\n\n    handler(event);\n\n    if (shouldStopPropagation) {\n      e.stopPropagation();\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {disableTextSelection, restoreTextSelection}  from './textSelection';\nimport {DOMAttributes, MoveEvents, PointerType} from '@react-types/shared';\nimport React, {useMemo, useRef} from 'react';\nimport {useEffectEvent, useGlobalListeners} from '@react-aria/utils';\n\nexport interface MoveResult {\n  /** Props to spread on the target element. */\n  moveProps: DOMAttributes\n}\n\ninterface EventBase {\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean\n}\n\n/**\n * Handles move interactions across mouse, touch, and keyboard, including dragging with\n * the mouse or touch, and using the arrow keys. Normalizes behavior across browsers and\n * platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useMove(props: MoveEvents): MoveResult {\n  let {onMoveStart, onMove, onMoveEnd} = props;\n\n  let state = useRef<{\n    didMove: boolean,\n    lastPosition: {pageX: number, pageY: number} | null,\n    id: number | null\n  }>({didMove: false, lastPosition: null, id: null});\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let move = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, deltaX: number, deltaY: number) => {\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    if (!state.current.didMove) {\n      state.current.didMove = true;\n      onMoveStart?.({\n        type: 'movestart',\n        pointerType,\n        shiftKey: originalEvent.shiftKey,\n        metaKey: originalEvent.metaKey,\n        ctrlKey: originalEvent.ctrlKey,\n        altKey: originalEvent.altKey\n      });\n    }\n    onMove?.({\n      type: 'move',\n      pointerType,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      shiftKey: originalEvent.shiftKey,\n      metaKey: originalEvent.metaKey,\n      ctrlKey: originalEvent.ctrlKey,\n      altKey: originalEvent.altKey\n    });\n  });\n\n  let end = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    restoreTextSelection();\n    if (state.current.didMove) {\n      onMoveEnd?.({\n        type: 'moveend',\n        pointerType,\n        shiftKey: originalEvent.shiftKey,\n        metaKey: originalEvent.metaKey,\n        ctrlKey: originalEvent.ctrlKey,\n        altKey: originalEvent.altKey\n      });\n    }\n  });\n\n  let moveProps = useMemo(() => {\n    let moveProps: DOMAttributes = {};\n\n    let start = () => {\n      disableTextSelection();\n      state.current.didMove = false;\n    };\n\n    if (typeof PointerEvent === 'undefined') {\n      let onMouseMove = (e: MouseEvent) => {\n        if (e.button === 0) {\n          move(e, 'mouse', e.pageX - (state.current.lastPosition?.pageX ?? 0), e.pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n        }\n      };\n      let onMouseUp = (e: MouseEvent) => {\n        if (e.button === 0) {\n          end(e, 'mouse');\n          removeGlobalListener(window, 'mousemove', onMouseMove, false);\n          removeGlobalListener(window, 'mouseup', onMouseUp, false);\n        }\n      };\n      moveProps.onMouseDown = (e: React.MouseEvent) => {\n        if (e.button === 0) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n          addGlobalListener(window, 'mousemove', onMouseMove, false);\n          addGlobalListener(window, 'mouseup', onMouseUp, false);\n        }\n      };\n\n      let onTouchMove = (e: TouchEvent) => {\n        let touch = [...e.changedTouches].findIndex(({identifier}) => identifier === state.current.id);\n        if (touch >= 0) {\n          let {pageX, pageY} = e.changedTouches[touch];\n          move(e, 'touch', pageX - (state.current.lastPosition?.pageX ?? 0), pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX, pageY};\n        }\n      };\n      let onTouchEnd = (e: TouchEvent) => {\n        let touch = [...e.changedTouches].findIndex(({identifier}) => identifier === state.current.id);\n        if (touch >= 0) {\n          end(e, 'touch');\n          state.current.id = null;\n          removeGlobalListener(window, 'touchmove', onTouchMove);\n          removeGlobalListener(window, 'touchend', onTouchEnd);\n          removeGlobalListener(window, 'touchcancel', onTouchEnd);\n        }\n      };\n      moveProps.onTouchStart = (e: React.TouchEvent) => {\n        if (e.changedTouches.length === 0 || state.current.id != null) {\n          return;\n        }\n\n        let {pageX, pageY, identifier} = e.changedTouches[0];\n        start();\n        e.stopPropagation();\n        e.preventDefault();\n        state.current.lastPosition = {pageX, pageY};\n        state.current.id = identifier;\n        addGlobalListener(window, 'touchmove', onTouchMove, false);\n        addGlobalListener(window, 'touchend', onTouchEnd, false);\n        addGlobalListener(window, 'touchcancel', onTouchEnd, false);\n      };\n    } else {\n      let onPointerMove = (e: PointerEvent) => {\n        if (e.pointerId === state.current.id) {\n          let pointerType = (e.pointerType || 'mouse') as PointerType;\n\n          // Problems with PointerEvent#movementX/movementY:\n          // 1. it is always 0 on macOS Safari.\n          // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n          move(e, pointerType, e.pageX - (state.current.lastPosition?.pageX ?? 0), e.pageY - (state.current.lastPosition?.pageY ?? 0));\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.current.id) {\n          let pointerType = (e.pointerType || 'mouse') as PointerType;\n          end(e, pointerType);\n          state.current.id = null;\n          removeGlobalListener(window, 'pointermove', onPointerMove, false);\n          removeGlobalListener(window, 'pointerup', onPointerUp, false);\n          removeGlobalListener(window, 'pointercancel', onPointerUp, false);\n        }\n      };\n\n      moveProps.onPointerDown = (e: React.PointerEvent) => {\n        if (e.button === 0 && state.current.id == null) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {pageX: e.pageX, pageY: e.pageY};\n          state.current.id = e.pointerId;\n          addGlobalListener(window, 'pointermove', onPointerMove, false);\n          addGlobalListener(window, 'pointerup', onPointerUp, false);\n          addGlobalListener(window, 'pointercancel', onPointerUp, false);\n        }\n      };\n    }\n\n    let triggerKeyboardMove = (e: EventBase, deltaX: number, deltaY: number) => {\n      start();\n      move(e, 'keyboard', deltaX, deltaY);\n      end(e, 'keyboard');\n    };\n\n    moveProps.onKeyDown = (e) => {\n      switch (e.key) {\n        case 'Left':\n        case 'ArrowLeft':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, -1, 0);\n          break;\n        case 'Right':\n        case 'ArrowRight':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 1, 0);\n          break;\n        case 'Up':\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, -1);\n          break;\n        case 'Down':\n        case 'ArrowDown':\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, 1);\n          break;\n      }\n    };\n\n    return moveProps;\n  }, [state, addGlobalListener, removeGlobalListener, move, end]);\n\n  return {moveProps};\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RefObject, useCallback} from 'react';\nimport {ScrollEvents} from '@react-types/shared';\nimport {useEvent} from '@react-aria/utils';\n\nexport interface ScrollWheelProps extends ScrollEvents {\n  /** Whether the scroll listener should be disabled. */\n  isDisabled?: boolean\n}\n\n// scroll wheel needs to be added not passively so it's cancelable, small helper hook to remember that\nexport function useScrollWheel(props: ScrollWheelProps, ref: RefObject<HTMLElement>): void {\n  let {onScroll, isDisabled} = props;\n  let onScrollHandler = useCallback((e) => {\n    // If the ctrlKey is pressed, this is a zoom event, do nothing.\n    if (e.ctrlKey) {\n      return;\n    }\n\n    // stop scrolling the page\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (onScroll) {\n      onScroll({deltaX: e.deltaX, deltaY: e.deltaY});\n    }\n  }, [onScroll]);\n\n  useEvent(ref, 'wheel', isDisabled ? undefined : onScrollHandler);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, LongPressEvent} from '@react-types/shared';\nimport {mergeProps, useDescription, useGlobalListeners} from '@react-aria/utils';\nimport {usePress} from './usePress';\nimport {useRef} from 'react';\n\nexport interface LongPressProps {\n  /** Whether long press events should be disabled. */\n  isDisabled?: boolean,\n  /** Handler that is called when a long press interaction starts. */\n  onLongPressStart?: (e: LongPressEvent) => void,\n  /**\n   * Handler that is called when a long press interaction ends, either\n   * over the target or when the pointer leaves the target.\n   */\n  onLongPressEnd?: (e: LongPressEvent) => void,\n  /**\n   * Handler that is called when the threshold time is met while\n   * the press is over the target.\n   */\n  onLongPress?: (e: LongPressEvent) => void,\n  /**\n   * The amount of time in milliseconds to wait before triggering a long press.\n   * @default 500ms\n   */\n  threshold?: number,\n  /**\n   * A description for assistive techology users indicating that a long press\n   * action is available, e.g. \"Long press to open menu\".\n   */\n  accessibilityDescription?: string\n}\n\nexport interface LongPressResult {\n  /** Props to spread on the target element. */\n  longPressProps: DOMAttributes\n}\n\nconst DEFAULT_THRESHOLD = 500;\n\n/**\n * Handles long press interactions across mouse and touch devices. Supports a customizable time threshold,\n * accessibility description, and normalizes behavior across browsers and devices.\n */\nexport function useLongPress(props: LongPressProps): LongPressResult {\n  let {\n    isDisabled,\n    onLongPressStart,\n    onLongPressEnd,\n    onLongPress,\n    threshold = DEFAULT_THRESHOLD,\n    accessibilityDescription\n  } = props;\n\n  const timeRef = useRef<ReturnType<typeof setTimeout> | undefined>();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let {pressProps} = usePress({\n    isDisabled,\n    onPressStart(e) {\n      e.continuePropagation();\n      if (e.pointerType === 'mouse' || e.pointerType === 'touch') {\n        if (onLongPressStart) {\n          onLongPressStart({\n            ...e,\n            type: 'longpressstart'\n          });\n        }\n\n        timeRef.current = setTimeout(() => {\n          // Prevent other usePress handlers from also handling this event.\n          e.target.dispatchEvent(new PointerEvent('pointercancel', {bubbles: true}));\n          if (onLongPress) {\n            onLongPress({\n              ...e,\n              type: 'longpress'\n            });\n          }\n          timeRef.current = undefined;\n        }, threshold);\n\n        // Prevent context menu, which may be opened on long press on touch devices\n        if (e.pointerType === 'touch') {\n          let onContextMenu = e => {\n            e.preventDefault();\n          };\n\n          addGlobalListener(e.target, 'contextmenu', onContextMenu, {once: true});\n          addGlobalListener(window, 'pointerup', () => {\n            // If no contextmenu event is fired quickly after pointerup, remove the handler\n            // so future context menu events outside a long press are not prevented.\n            setTimeout(() => {\n              removeGlobalListener(e.target, 'contextmenu', onContextMenu);\n            }, 30);\n          }, {once: true});\n        }\n      }\n    },\n    onPressEnd(e) {\n      if (timeRef.current) {\n        clearTimeout(timeRef.current);\n      }\n\n      if (onLongPressEnd && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        onLongPressEnd({\n          ...e,\n          type: 'longpressend'\n        });\n      }\n    }\n  });\n\n  let descriptionProps = useDescription(onLongPress && !isDisabled ? accessibilityDescription : undefined);\n\n  return {\n    longPressProps: mergeProps(pressProps, descriptionProps)\n  };\n}\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { useMemo, type ElementType, type Ref } from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useDisabled } from '../../internal/disabled'\nimport type { Props } from '../../types'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\n\ntype ButtonRenderPropArg = {\n  disabled: boolean\n  hover: boolean\n  focus: boolean\n  active: boolean\n  autofocus: boolean\n}\ntype ButtonPropsWeControl = never\n\nexport type ButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    disabled?: boolean\n    autoFocus?: boolean\n    type?: 'button' | 'submit' | 'reset'\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: ButtonProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let providedDisabled = useDisabled()\n  let { disabled = providedDisabled || false, ...theirProps } = props\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled })\n  let { pressed: active, pressProps } = useActivePress({ disabled })\n\n  let ourProps = mergeProps(\n    {\n      ref,\n      disabled: disabled || undefined,\n      type: theirProps.type ?? 'button',\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        disabled,\n        hover,\n        focus,\n        active,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies ButtonRenderPropArg,\n    [disabled, hover, focus, active, props.autoFocus]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Button',\n  })\n}\n\nexport interface _internal_ComponentButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: ButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport let Button = forwardRefWithAs(ButtonFn) as unknown as _internal_ComponentButton\n", "import { useRef, useState } from 'react'\nimport { getOwnerDocument } from '../utils/owner'\nimport { useDisposables } from './use-disposables'\nimport { useEvent } from './use-event'\n\n// Only the necessary props from a DOMRect\ntype Rect = { left: number; right: number; top: number; bottom: number }\n\nfunction pointerRectFromPointerEvent(event: PointerEvent): Rect {\n  // Center of the pointer geometry\n  let offsetX = event.width / 2\n  let offsetY = event.height / 2\n\n  return {\n    top: event.clientY - offsetY,\n    right: event.clientX + offsetX,\n    bottom: event.clientY + offsetY,\n    left: event.clientX - offsetX,\n  }\n}\n\nfunction areRectsOverlapping(a: Rect | null, b: Rect | null) {\n  if (!a || !b) {\n    return false\n  }\n\n  if (a.right < b.left || a.left > b.right) {\n    return false\n  }\n\n  if (a.bottom < b.top || a.top > b.bottom) {\n    return false\n  }\n\n  return true\n}\n\nexport function useActivePress({ disabled = false }: Partial<{ disabled: boolean }> = {}) {\n  let target = useRef<HTMLElement | null>(null)\n  let [pressed, setPressed] = useState(false)\n\n  let d = useDisposables()\n\n  let reset = useEvent(() => {\n    target.current = null\n    setPressed(false)\n    d.dispose()\n  })\n\n  let handlePointerDown = useEvent((event: PointerEvent) => {\n    d.dispose() // Cancel any scheduled tasks\n\n    if (target.current !== null) return\n\n    // Keep track of the current element\n    target.current = event.currentTarget as HTMLElement\n\n    // We are definitely pressing the element now\n    setPressed(true)\n\n    // Setup global handlers to catch events on elements that are not the current element\n    {\n      let owner = getOwnerDocument(event.currentTarget as Element)!\n\n      // `pointerup` on any element means that we are no longer pressing the current element\n      d.addEventListener(owner, 'pointerup', reset, false)\n\n      // `pointerleave` isn't called consistently (if at all) on iOS Safari, so we use `pointermove` instead\n      // to determine if we are still \"pressing\". We also compare the pointer position to the target element\n      // so that we can tell if the pointer is still over the element or not.\n      d.addEventListener(\n        owner,\n        'pointermove',\n        (event: PointerEvent) => {\n          if (target.current) {\n            let pointerRect = pointerRectFromPointerEvent(event)\n            setPressed(areRectsOverlapping(pointerRect, target.current.getBoundingClientRect()))\n          }\n        },\n        false\n      )\n\n      // Whenever the browser decides to fire a `pointercancel` event, we should abort\n      d.addEventListener(owner, 'pointercancel', reset, false)\n    }\n  })\n\n  return {\n    pressed,\n    pressProps: disabled\n      ? {}\n      : {\n          onPointerDown: handlePointerDown,\n          onPointerUp: reset,\n          onClick: reset,\n        },\n  }\n}\n", "type RenderEnv = 'client' | 'server'\ntype HandoffState = 'pending' | 'complete'\n\nclass Env {\n  current: RenderEnv = this.detect()\n  handoffState: HandoffState = 'pending'\n  currentId = 0\n\n  set(env: RenderEnv): void {\n    if (this.current === env) return\n\n    this.handoffState = 'pending'\n    this.currentId = 0\n    this.current = env\n  }\n\n  reset(): void {\n    this.set(this.detect())\n  }\n\n  nextId() {\n    return ++this.currentId\n  }\n\n  get isServer(): boolean {\n    return this.current === 'server'\n  }\n\n  get isClient(): boolean {\n    return this.current === 'client'\n  }\n\n  private detect(): RenderEnv {\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      return 'server'\n    }\n\n    return 'client'\n  }\n\n  handoff(): void {\n    if (this.handoffState === 'pending') {\n      this.handoffState = 'complete'\n    }\n  }\n\n  get isHandoffComplete(): boolean {\n    return this.handoffState === 'complete'\n  }\n}\n\nexport let env = new Env()\n", "import type { MutableRefObject } from 'react'\nimport { env } from './env'\n\nexport function getOwnerDocument<T extends Element | MutableRefObject<Element | null>>(\n  element: T | null | undefined\n) {\n  if (env.isServer) return null\n  if (element instanceof Node) return element.ownerDocument\n  if (element?.hasOwnProperty('current')) {\n    if (element.current instanceof Node) return element.current.ownerDocument\n  }\n\n  return document\n}\n", "import { useEffect, useState } from 'react'\nimport { disposables } from '../utils/disposables'\n\nexport function useDisposables() {\n  // Using useState instead of useRef so that we can use the initializer function.\n  let [d] = useState(disposables)\n  useEffect(() => () => d.dispose(), [d])\n  return d\n}\n", "// Polyfill\nexport function microTask(cb: () => void) {\n  if (typeof queueMicrotask === 'function') {\n    queueMicrotask(cb)\n  } else {\n    Promise.resolve()\n      .then(cb)\n      .catch((e) =>\n        setTimeout(() => {\n          throw e\n        })\n      )\n  }\n}\n", "import { microTask } from './micro-task'\n\nexport type Disposables = ReturnType<typeof disposables>\n\nexport function disposables() {\n  let _disposables: Function[] = []\n\n  let api = {\n    addEventListener<TEventName extends keyof WindowEventMap>(\n      element: HTMLElement | Window | Document,\n      name: TEventName,\n      listener: (event: WindowEventMap[TEventName]) => any,\n      options?: boolean | AddEventListenerOptions\n    ) {\n      element.addEventListener(name, listener as any, options)\n      return api.add(() => element.removeEventListener(name, listener as any, options))\n    },\n\n    requestAnimationFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      let raf = requestAnimationFrame(...args)\n      return api.add(() => cancelAnimationFrame(raf))\n    },\n\n    nextFrame(...args: Parameters<typeof requestAnimationFrame>) {\n      return api.requestAnimationFrame(() => {\n        return api.requestAnimationFrame(...args)\n      })\n    },\n\n    setTimeout(...args: Parameters<typeof setTimeout>) {\n      let timer = setTimeout(...args)\n      return api.add(() => clearTimeout(timer))\n    },\n\n    microTask(...args: Parameters<typeof microTask>) {\n      let task = { current: true }\n      microTask(() => {\n        if (task.current) {\n          args[0]()\n        }\n      })\n      return api.add(() => {\n        task.current = false\n      })\n    },\n\n    style(node: HTMLElement, property: string, value: string) {\n      let previous = node.style.getPropertyValue(property)\n      Object.assign(node.style, { [property]: value })\n      return this.add(() => {\n        Object.assign(node.style, { [property]: previous })\n      })\n    },\n\n    group(cb: (d: typeof this) => void) {\n      let d = disposables()\n      cb(d)\n      return this.add(() => d.dispose())\n    },\n\n    add(cb: () => void) {\n      _disposables.push(cb)\n      return () => {\n        let idx = _disposables.indexOf(cb)\n        if (idx >= 0) {\n          for (let dispose of _disposables.splice(idx, 1)) {\n            dispose()\n          }\n        }\n      }\n    },\n\n    dispose() {\n      for (let dispose of _disposables.splice(0)) {\n        dispose()\n      }\n    },\n  }\n\n  return api\n}\n", "import React from 'react'\nimport { useLatestValue } from './use-latest-value'\n\nexport let useEvent =\n  // TODO: Add React.useEvent ?? once the useEvent hook is available\n  function useEvent<\n    F extends (...args: any[]) => any,\n    P extends any[] = Parameters<F>,\n    R = ReturnType<F>,\n  >(cb: (...args: P) => R) {\n    let cache = useLatestValue(cb)\n    return React.useCallback((...args: P) => cache.current(...args), [cache])\n  }\n", "import { useRef } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nexport function useLatestValue<T>(value: T) {\n  let cache = useRef(value)\n\n  useIsoMorphicEffect(() => {\n    cache.current = value\n  }, [value])\n\n  return cache\n}\n", "import { useEffect, useLayoutEffect, type DependencyList, type EffectCallback } from 'react'\nimport { env } from '../utils/env'\n\nexport let useIsoMorphicEffect = (effect: EffectCallback, deps?: DependencyList | undefined) => {\n  if (env.isServer) {\n    useEffect(effect, deps)\n  } else {\n    useLayoutEffect(effect, deps)\n  }\n}\n", "import React, { createContext, useContext } from 'react'\n\nlet DisabledContext = createContext<boolean | undefined>(undefined)\n\nexport function useDisabled() {\n  return useContext(DisabledContext)\n}\n\nexport function DisabledProvider({\n  value,\n  children,\n}: React.PropsWithChildren<{ value?: boolean }>) {\n  return <DisabledContext.Provider value={value}>{children}</DisabledContext.Provider>\n}\n", "import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n  useCallback,\n  useRef,\n  type ElementType,\n  type MutableRefObject,\n  type ReactElement,\n  type Ref,\n} from 'react'\nimport type { Expand, Props, XOR, __ } from '../types'\nimport { classNames } from './class-names'\nimport { match } from './match'\n\nexport enum RenderFeatures {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<\n  TPassedInFeatures extends RenderFeatures,\n  TForFeature extends RenderFeatures,\n  TProps,\n> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends RenderFeatures> = XOR<\n  PropsForFeature<T, RenderFeatures.Static, { static?: boolean }>,\n  PropsForFeature<T, RenderFeatures.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends RenderFeatures, TTag extends ElementType, TSlot>({\n  ourProps,\n  theirProps,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n  mergeRefs,\n}: {\n  ourProps: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>> & {\n    ref?: Ref<HTMLElement | ElementType>\n  }\n  theirProps: Expand<Props<TTag, TSlot, any>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n  mergeRefs?: ReturnType<typeof useMergeRefsFn>\n}) {\n  mergeRefs = mergeRefs ?? defaultMergeRefs\n\n  let props = mergePropsAdvanced(theirProps, ourProps)\n\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name, mergeRefs)\n\n  let featureFlags = features ?? RenderFeatures.None\n\n  if (featureFlags & RenderFeatures.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<RenderFeatures.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name, mergeRefs)\n  }\n\n  if (featureFlags & RenderFeatures.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<RenderFeatures.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name,\n          mergeRefs!\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name, mergeRefs)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string,\n  mergeRefs: ReturnType<typeof useMergeRefsFn>\n) {\n  let {\n    as: Component = tag,\n    children,\n    refName = 'ref',\n    ...rest\n  } = omit(props, ['unmount', 'static'])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if ('className' in rest && rest.className && typeof rest.className === 'function') {\n    rest.className = rest.className(slot)\n  }\n\n  // Drop `aria-labelledby` if it only references the current element. If the `aria-labelledby`\n  // references itself but also another element then we can keep it.\n  if (rest['aria-labelledby'] && rest['aria-labelledby'] === rest.id) {\n    rest['aria-labelledby'] = undefined\n  }\n\n  let dataAttributes: Record<string, string> = {}\n  if (slot) {\n    let exposeState = false\n    let states = []\n    for (let [k, v] of Object.entries(slot)) {\n      if (typeof v === 'boolean') {\n        exposeState = true\n      }\n\n      if (v === true) {\n        states.push(k.replace(/([A-Z])/g, (m) => `-${m.toLowerCase()}`))\n      }\n    }\n\n    if (exposeState) {\n      dataAttributes['data-headlessui-state'] = states.join(' ')\n      for (let state of states) {\n        dataAttributes[`data-${state}`] = ''\n      }\n    }\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(compact(rest)).length > 0 || Object.keys(compact(dataAttributes)).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        if (Object.keys(compact(rest)).length > 0) {\n          throw new Error(\n            [\n              'Passing props on \"Fragment\"!',\n              '',\n              `The current component <${name} /> is rendering a \"Fragment\".`,\n              `However we need to passthrough the following props:`,\n              Object.keys(compact(rest))\n                .concat(Object.keys(compact(dataAttributes)))\n                .map((line) => `  - ${line}`)\n                .join('\\n'),\n              '',\n              'You can apply a few solutions:',\n              [\n                'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n                'Render a single element as the child so that we can forward the props onto that element.',\n              ]\n                .map((line) => `  - ${line}`)\n                .join('\\n'),\n            ].join('\\n')\n          )\n        }\n      } else {\n        // Merge class name prop in SSR\n        // @ts-ignore We know that the props may not have className. It'll be undefined then which is fine.\n        let childProps = resolvedChildren.props as { className: string | (() => string) } | null\n\n        let childPropsClassName = childProps?.className\n        let newClassName =\n          typeof childPropsClassName === 'function'\n            ? (...args: any[]) =>\n                classNames(\n                  (childPropsClassName as Function)(...args),\n                  (rest as { className?: string }).className\n                )\n            : classNames(childPropsClassName, (rest as { className?: string }).className)\n\n        let classNameProps = newClassName ? { className: newClassName } : {}\n\n        return cloneElement(\n          resolvedChildren,\n          Object.assign(\n            {},\n            // Filter out undefined values so that they don't override the existing values\n            mergePropsAdvanced(resolvedChildren.props as any, compact(omit(rest, ['ref']))),\n            dataAttributes,\n            refRelatedProps,\n            { ref: mergeRefs((resolvedChildren as any).ref, refRelatedProps.ref) },\n            classNameProps\n          )\n        )\n      }\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign(\n      {},\n      omit(rest, ['ref']),\n      Component !== Fragment && refRelatedProps,\n      Component !== Fragment && dataAttributes\n    ),\n    resolvedChildren\n  )\n}\n\n/**\n * This is a singleton hook. **You can ONLY call the returned\n * function *once* to produce expected results.** If you need\n * to call `mergeRefs()` multiple times you need to create a\n * separate function for each invocation. This happens as we\n * store the list of `refs` to update and always return the\n * same function that refers to that list of refs.\n *\n * You shouldn't normally read refs during render but this\n * should actually be okay because React itself is calling\n * the `function` that updates these refs and can only do\n * so once the ref that contains the list is updated.\n */\nexport function useMergeRefsFn() {\n  type MaybeRef<T> = MutableRefObject<T> | ((value: T) => void) | null | undefined\n  let currentRefs = useRef<MaybeRef<any>[]>([])\n  let mergedRef = useCallback((value: any) => {\n    for (let ref of currentRefs.current) {\n      if (ref == null) continue\n      if (typeof ref === 'function') ref(value)\n      else ref.current = value\n    }\n  }, [])\n\n  return (...refs: any[]) => {\n    if (refs.every((ref) => ref == null)) {\n      return undefined\n    }\n\n    currentRefs.current = refs\n    return mergedRef\n  }\n}\n\n// This does not produce a stable function to use as a ref\n// But we only use it in the case of as={Fragment}\n// And it should really only re-render if setting the ref causes the parent to re-render unconditionally\n// which then causes the child to re-render resulting in a render loop\n// TODO: Add tests for this somehow\nfunction defaultMergeRefs(...refs: any[]) {\n  return refs.every((ref) => ref == null)\n    ? undefined\n    : (value: any) => {\n        for (let ref of refs) {\n          if (ref == null) continue\n          if (typeof ref === 'function') ref(value)\n          else ref.current = value\n        }\n      }\n}\n\n// A more complex example fo the `mergeProps` function, this one also cancels subsequent event\n// listeners if the event has already been `preventDefault`ed.\nfunction mergePropsAdvanced(...listOfProps: Props<any, any>[]) {\n  if (listOfProps.length === 0) return {}\n  if (listOfProps.length === 1) return listOfProps[0]\n\n  let target: Props<any, any> = {}\n\n  let eventHandlers: Record<\n    string,\n    ((event: { defaultPrevented: boolean }, ...args: any[]) => void | undefined)[]\n  > = {}\n\n  for (let props of listOfProps) {\n    for (let prop in props) {\n      // Collect event handlers\n      if (prop.startsWith('on') && typeof props[prop] === 'function') {\n        eventHandlers[prop] ??= []\n        eventHandlers[prop].push(props[prop])\n      } else {\n        // Override incoming prop\n        target[prop] = props[prop]\n      }\n    }\n  }\n\n  // Ensure event listeners are not called if `disabled` or `aria-disabled` is true\n  if (target.disabled || target['aria-disabled']) {\n    for (let eventName in eventHandlers) {\n      // Prevent default events for `onClick`, `onMouseDown`, `onKeyDown`, etc.\n      if (/^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(eventName)) {\n        eventHandlers[eventName] = [(e: any) => e?.preventDefault?.()]\n      }\n    }\n  }\n\n  // Merge event handlers\n  for (let eventName in eventHandlers) {\n    Object.assign(target, {\n      [eventName](event: { nativeEvent?: Event; defaultPrevented: boolean }, ...args: any[]) {\n        let handlers = eventHandlers[eventName]\n\n        for (let handler of handlers) {\n          if (\n            (event instanceof Event || event?.nativeEvent instanceof Event) &&\n            event.defaultPrevented\n          ) {\n            return\n          }\n\n          handler(event, ...args)\n        }\n      },\n    })\n  }\n\n  return target\n}\n\nexport type HasDisplayName = {\n  displayName: string\n}\n\nexport type RefProp<T extends Function> = T extends (props: any, ref: Ref<infer RefType>) => any\n  ? { ref?: Ref<RefType> }\n  : never\n\n// TODO: add proper return type, but this is not exposed as public API so it's fine for now\nexport function mergeProps<T extends Props<any, any>[]>(...listOfProps: T) {\n  if (listOfProps.length === 0) return {}\n  if (listOfProps.length === 1) return listOfProps[0]\n\n  let target: Props<any, any> = {}\n\n  let eventHandlers: Record<string, ((...args: any[]) => void | undefined)[]> = {}\n\n  for (let props of listOfProps) {\n    for (let prop in props) {\n      // Merge event listeners\n      if (prop.startsWith('on') && typeof props[prop] === 'function') {\n        eventHandlers[prop] ??= []\n        eventHandlers[prop].push(props[prop])\n      } else {\n        // Override incoming prop\n        target[prop] = props[prop]\n      }\n    }\n  }\n\n  // Merge event handlers\n  for (let eventName in eventHandlers) {\n    Object.assign(target, {\n      [eventName](...args: any[]) {\n        let handlers = eventHandlers[eventName]\n\n        for (let handler of handlers) {\n          handler?.(...args)\n        }\n      },\n    })\n  }\n\n  return target\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef(component as unknown as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nexport function compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object) as T\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n", "export function classNames(...classes: (false | null | undefined | string)[]): string {\n  return Array.from(\n    new Set(\n      classes.flatMap((value) => {\n        if (typeof value === 'string') {\n          return value.split(' ')\n        }\n\n        return []\n      })\n    )\n  )\n    .filter(Boolean)\n    .join(' ')\n}\n", "export function match<TValue extends string | number = string, TReturnValue = unknown>(\n  value: TValue,\n  lookup: Record<TValue, TReturnValue | ((...args: any[]) => TReturnValue)>,\n  ...args: any[]\n): TReturnValue {\n  if (value in lookup) {\n    let returnValue = lookup[value]\n    return typeof returnValue === 'function' ? returnValue(...args) : returnValue\n  }\n\n  let error = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    )\n      .map((key) => `\"${key}\"`)\n      .join(', ')}.`\n  )\n  if (Error.captureStackTrace) Error.captureStackTrace(error, match)\n  throw error\n}\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  useCallback,\n  useMemo,\n  useState,\n  type ElementType,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useControllable } from '../../hooks/use-controllable'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useDisabled } from '../../internal/disabled'\nimport { FormFields } from '../../internal/form-fields'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { Keys } from '../keyboard'\nimport { useLabelledBy } from '../label/label'\n\nlet DEFAULT_CHECKBOX_TAG = 'span' as const\ntype CheckboxRenderPropArg = {\n  checked: boolean\n  changing: boolean\n  focus: boolean\n  active: boolean\n  hover: boolean\n  autofocus: boolean\n  disabled: boolean\n  indeterminate: boolean\n}\ntype CheckboxPropsWeControl =\n  | 'aria-checked'\n  | 'aria-describedby'\n  | 'aria-disabled'\n  | 'aria-labelledby'\n  | 'role'\n  | 'tabIndex'\n\nexport type CheckboxProps<\n  TTag extends ElementType = typeof DEFAULT_CHECKBOX_TAG,\n  TType = string,\n> = Props<\n  TTag,\n  CheckboxRenderPropArg,\n  CheckboxPropsWeControl,\n  {\n    value?: TType\n    disabled?: boolean\n    indeterminate?: boolean\n\n    checked?: boolean\n    defaultChecked?: boolean\n    autoFocus?: boolean\n    form?: string\n    name?: string\n    onChange?: (checked: boolean) => void\n  }\n>\n\nfunction CheckboxFn<TTag extends ElementType = typeof DEFAULT_CHECKBOX_TAG, TType = any>(\n  props: CheckboxProps<TTag, TType>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-checkbox-${internalId}`,\n    disabled = providedDisabled || false,\n    checked: controlledChecked,\n    defaultChecked = false,\n    onChange: controlledOnChange,\n    name,\n    value,\n    form,\n    indeterminate = false,\n    ...theirProps\n  } = props\n\n  let [checked, onChange] = useControllable(controlledChecked, controlledOnChange, defaultChecked)\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n\n  let d = useDisposables()\n  let [changing, setChanging] = useState(false)\n  let toggle = useEvent(() => {\n    setChanging(true)\n    onChange?.(!checked)\n\n    d.nextFrame(() => {\n      setChanging(false)\n    })\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    toggle()\n  })\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n\n    switch (event.key) {\n      case Keys.Space:\n        event.preventDefault()\n        toggle()\n        break\n    }\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: disabled ?? false })\n\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      role: 'checkbox',\n      'aria-checked': indeterminate ? 'mixed' : checked ? 'true' : 'false',\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      'aria-disabled': disabled ? true : undefined,\n      indeterminate: indeterminate ? 'true' : undefined,\n      tabIndex: 0,\n      onKeyDown: disabled ? undefined : handleKeyDown,\n      onClick: disabled ? undefined : handleClick,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        checked,\n        disabled,\n        hover,\n        focus,\n        active,\n        indeterminate,\n        changing,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies CheckboxRenderPropArg,\n    [checked, indeterminate, disabled, hover, focus, active, changing, props.autoFocus]\n  )\n\n  let reset = useCallback(() => {\n    return onChange?.(defaultChecked)\n  }, [onChange /* Explicitly ignoring `defaultChecked` */])\n\n  return (\n    <>\n      {name != null && (\n        <FormFields data={checked ? { [name]: value || 'on' } : {}} form={form} onReset={reset} />\n      )}\n      {render({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_CHECKBOX_TAG,\n        name: 'Checkbox',\n      })}\n    </>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentCheckbox extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_CHECKBOX_TAG, TType = string>(\n    props: CheckboxProps<TTag, TType> & RefProp<typeof CheckboxFn>\n  ): JSX.Element\n}\n\nexport let Checkbox = forwardRefWithAs(CheckboxFn) as unknown as _internal_ComponentCheckbox\n", "import { useRef, useState } from 'react'\nimport { useEvent } from './use-event'\n\nexport function useControllable<T>(\n  controlledValue: T | undefined,\n  onChange?: (value: T) => void,\n  defaultValue?: T\n) {\n  let [internalValue, setInternalValue] = useState(defaultValue)\n\n  let isControlled = controlledValue !== undefined\n  let wasControlled = useRef(isControlled)\n  let didWarnOnUncontrolledToControlled = useRef(false)\n  let didWarnOnControlledToUncontrolled = useRef(false)\n\n  if (isControlled && !wasControlled.current && !didWarnOnUncontrolledToControlled.current) {\n    didWarnOnUncontrolledToControlled.current = true\n    wasControlled.current = isControlled\n    console.error(\n      'A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.'\n    )\n  } else if (!isControlled && wasControlled.current && !didWarnOnControlledToUncontrolled.current) {\n    didWarnOnControlledToUncontrolled.current = true\n    wasControlled.current = isControlled\n    console.error(\n      'A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.'\n    )\n  }\n\n  return [\n    (isControlled ? controlledValue : internalValue)!,\n    useEvent((value) => {\n      if (isControlled) {\n        return onChange?.(value)\n      } else {\n        setInternalValue(value)\n        return onChange?.(value)\n      }\n    }),\n  ] as const\n}\n", "import React from 'react'\nimport { env } from '../utils/env'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useServerHandoffComplete } from './use-server-handoff-complete'\n\n// We used a \"simple\" approach first which worked for SSR and rehydration on the client. However we\n// didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id\n// uses.\n//\n// Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx\n\nexport let useId =\n  // Prefer React's `useId` if it's available.\n  React.useId ??\n  function useId() {\n    let ready = useServerHandoffComplete()\n    let [id, setId] = React.useState(ready ? () => env.nextId() : null)\n\n    useIsoMorphicEffect(() => {\n      if (id === null) setId(env.nextId())\n    }, [id])\n\n    return id != null ? '' + id : undefined\n  }\n", "import * as React from 'react'\nimport { env } from '../utils/env'\n\n/**\n * This is used to determine if we're hydrating in React 18.\n *\n * The `useServerHandoffComplete` hook doesn't work with `<Suspense>`\n * because it assumes all hydration happens at one time during page load.\n *\n * Given that the problem only exists in React 18 we can rely\n * on newer APIs to determine if hydration is happening.\n */\nfunction useIsHydratingInReact18(): boolean {\n  let isServer = typeof document === 'undefined'\n\n  // React < 18 doesn't have any way to figure this out afaik\n  if (!('useSyncExternalStore' in React)) {\n    return false\n  }\n\n  // This weird pattern makes sure bundlers don't throw at build time\n  // because `useSyncExternalStore` isn't defined in React < 18\n  const useSyncExternalStore = ((r) => r.useSyncExternalStore)(React)\n\n  // @ts-ignore\n  let result = useSyncExternalStore(\n    () => () => {},\n    () => false,\n    () => (isServer ? false : true)\n  )\n\n  return result\n}\n\n// TODO: We want to get rid of this hook eventually\nexport function useServerHandoffComplete() {\n  let isHydrating = useIsHydratingInReact18()\n  let [complete, setComplete] = React.useState(env.isHandoffComplete)\n\n  if (complete && env.isHandoffComplete === false) {\n    // This means we are in a test environment and we need to reset the handoff state\n    // This kinda breaks the rules of React but this is only used for testing purposes\n    // And should theoretically be fine\n    setComplete(false)\n  }\n\n  React.useEffect(() => {\n    if (complete === true) return\n    setComplete(true)\n  }, [complete])\n\n  // Transition from pending to complete (forcing a re-render when server rendering)\n  React.useEffect(() => env.handoff(), [])\n\n  if (isHydrating) {\n    return false\n  }\n\n  return complete\n}\n", "import React, { createContext, useContext, useEffect, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport { useDisposables } from '../hooks/use-disposables'\nimport { objectToFormEntries } from '../utils/form'\nimport { compact } from '../utils/render'\nimport { Hidden, HiddenFeatures } from './hidden'\n\nlet FormFieldsContext = createContext<{ target: HTMLElement | null } | null>(null)\n\nexport function FormFieldsProvider(props: React.PropsWithChildren<{}>) {\n  let [target, setTarget] = useState<HTMLElement | null>(null)\n\n  return (\n    <FormFieldsContext.Provider value={{ target }}>\n      {props.children}\n      <Hidden features={HiddenFeatures.Hidden} ref={setTarget} />\n    </FormFieldsContext.Provider>\n  )\n}\n\nexport function HoistFormFields({ children }: React.PropsWithChildren<{}>) {\n  let formFieldsContext = useContext(FormFieldsContext)\n  if (!formFieldsContext) return <>{children}</>\n\n  let { target } = formFieldsContext\n  return target\n    ? createPortal(<>{children}</>, target) //\n    : null // We know for sure that we are in a `FormFieldsContext`, but the DOM element where we want to render is not ready yet. Let's render nothing for now until that element is ready.\n}\n\nexport function FormFields({\n  data,\n  form: formId,\n  onReset,\n}: {\n  data: Record<string, any>\n  form?: string\n  onReset?: (e: Event) => void\n}) {\n  let [form, setForm] = useState<HTMLFormElement | null>(null)\n\n  let d = useDisposables()\n  useEffect(() => {\n    if (!onReset) return\n    if (!form) return\n\n    return d.addEventListener(form, 'reset', onReset)\n  }, [form, formId, onReset])\n\n  return (\n    <HoistFormFields>\n      <FormResolver setForm={setForm} formId={formId} />\n      {objectToFormEntries(data).map(([name, value]) => {\n        return (\n          <Hidden\n            features={HiddenFeatures.Hidden}\n            {...compact({\n              key: name,\n              as: 'input',\n              type: 'hidden',\n              hidden: true,\n              readOnly: true,\n              form: formId,\n              name,\n              value,\n            })}\n          />\n        )\n      })}\n    </HoistFormFields>\n  )\n}\n\nfunction FormResolver({\n  setForm,\n  formId,\n}: {\n  setForm: (form: HTMLFormElement) => void\n  formId?: string\n}) {\n  useEffect(() => {\n    if (formId) {\n      let resolvedForm = document.getElementById(formId) as HTMLFormElement\n      if (resolvedForm) setForm(resolvedForm)\n    }\n  }, [setForm, formId])\n\n  return formId ? null : (\n    <Hidden\n      features={HiddenFeatures.Hidden}\n      as=\"input\"\n      type=\"hidden\"\n      hidden\n      readOnly\n      ref={(el) => {\n        if (!el) return\n        let resolvedForm = el.closest('form')\n        if (resolvedForm) setForm(resolvedForm)\n      }}\n    />\n  )\n}\n", "type Entries = [string, string][]\n\nexport function objectToFormEntries(\n  source: Record<string, any> = {},\n  parentKey: string | null = null,\n  entries: Entries = []\n): Entries {\n  for (let [key, value] of Object.entries(source)) {\n    append(entries, composeKey(parentKey, key), value)\n  }\n\n  return entries\n}\n\nfunction composeKey(parent: string | null, key: string): string {\n  return parent ? parent + '[' + key + ']' : key\n}\n\nfunction append(entries: Entries, key: string, value: any): void {\n  if (Array.isArray(value)) {\n    for (let [subkey, subvalue] of value.entries()) {\n      append(entries, composeKey(key, subkey.toString()), subvalue)\n    }\n  } else if (value instanceof Date) {\n    entries.push([key, value.toISOString()])\n  } else if (typeof value === 'boolean') {\n    entries.push([key, value ? '1' : '0'])\n  } else if (typeof value === 'string') {\n    entries.push([key, value])\n  } else if (typeof value === 'number') {\n    entries.push([key, `${value}`])\n  } else if (value === null || value === undefined) {\n    entries.push([key, ''])\n  } else {\n    objectToFormEntries(value, key, entries)\n  }\n}\n\nexport function attemptSubmit(elementInForm: HTMLElement) {\n  let form = (elementInForm as any)?.form ?? elementInForm.closest('form')\n  if (!form) return\n\n  for (let element of form.elements) {\n    if (element === elementInForm) continue\n\n    if (\n      (element.tagName === 'INPUT' && element.type === 'submit') ||\n      (element.tagName === 'BUTTON' && element.type === 'submit') ||\n      (element.nodeName === 'INPUT' && element.type === 'image')\n    ) {\n      // If you press `enter` in a normal input[type='text'] field, then the form will submit by\n      // searching for the a submit element and \"click\" it. We could also use the\n      // `form.requestSubmit()` function, but this has a downside where an `event.preventDefault()`\n      // inside a `click` listener on the submit button won't stop the form from submitting.\n      element.click()\n      return\n    }\n  }\n\n  // If we get here, then there is no submit button in the form. We can use the\n  // `form.requestSubmit()` function to submit the form instead. We cannot use `form.submit()`\n  // because then the `submit` event won't be fired and `onSubmit` listeners won't be fired.\n  form.requestSubmit?.()\n}\n", "import type { ElementType, Ref } from 'react'\nimport type { Props } from '../types'\nimport { forwardRefWithAs, render, type HasDisplayName, type RefProp } from '../utils/render'\n\nlet DEFAULT_VISUALLY_HIDDEN_TAG = 'div' as const\n\nexport enum HiddenFeatures {\n  // The default, no features.\n  None = 1 << 0,\n\n  // Whether the element should be focusable or not.\n  Focusable = 1 << 1,\n\n  // Whether it should be completely hidden, even to assistive technologies.\n  Hidden = 1 << 2,\n}\n\ntype HiddenRenderPropArg = {}\ntype HiddenPropsWeControl = never\nexport type HiddenProps<TTag extends ElementType = typeof DEFAULT_VISUALLY_HIDDEN_TAG> = Props<\n  TTag,\n  HiddenRenderPropArg,\n  HiddenPropsWeControl,\n  { features?: HiddenFeatures }\n>\n\nfunction VisuallyHidden<TTag extends ElementType = typeof DEFAULT_VISUALLY_HIDDEN_TAG>(\n  props: HiddenProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { features = HiddenFeatures.None, ...theirProps } = props\n  let ourProps = {\n    ref,\n    'aria-hidden':\n      (features & HiddenFeatures.Focusable) === HiddenFeatures.Focusable\n        ? true\n        : theirProps['aria-hidden'] ?? undefined,\n    style: {\n      position: 'fixed',\n      top: 1,\n      left: 1,\n      width: 1,\n      height: 0,\n      padding: 0,\n      margin: -1,\n      overflow: 'hidden',\n      clip: 'rect(0, 0, 0, 0)',\n      whiteSpace: 'nowrap',\n      borderWidth: '0',\n      ...((features & HiddenFeatures.Hidden) === HiddenFeatures.Hidden &&\n        !((features & HiddenFeatures.Focusable) === HiddenFeatures.Focusable) && {\n          display: 'none',\n        }),\n    },\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_VISUALLY_HIDDEN_TAG,\n    name: 'Hidden',\n  })\n}\n\ninterface ComponentHidden extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_VISUALLY_HIDDEN_TAG>(\n    props: HiddenProps<TTag> & RefProp<typeof VisuallyHidden>\n  ): JSX.Element\n}\n\nexport let Hidden = forwardRefWithAs(VisuallyHidden) as unknown as ComponentHidden\n", "import React, { createContext, useContext } from 'react'\n\nlet IdContext = createContext<string | undefined>(undefined)\n\nexport function useProvidedId() {\n  return useContext(IdContext)\n}\n\nexport function IdProvider({ id, children }: React.PropsWithChildren<{ id: string | undefined }>) {\n  return <IdContext.Provider value={id}>{children}</IdContext.Provider>\n}\n", "// See: https://github.com/facebook/react/issues/7711\n// See: https://github.com/facebook/react/pull/20612\n// See: https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-disabled (2.)\nexport function isDisabledReactIssue7711(element: Element): boolean {\n  let parent = element.parentElement\n  let legend = null\n\n  while (parent && !(parent instanceof HTMLFieldSetElement)) {\n    if (parent instanceof HTMLLegendElement) legend = parent\n    parent = parent.parentElement\n  }\n\n  let isParentDisabled = parent?.getAttribute('disabled') === '' ?? false\n  if (isParentDisabled && isFirstLegend(legend)) return false\n\n  return isParentDisabled\n}\n\nfunction isFirstLegend(element: HTMLLegendElement | null): boolean {\n  if (!element) return false\n\n  let previous = element.previousElementSibling\n\n  while (previous !== null) {\n    if (previous instanceof HTMLLegendElement) return false\n    previous = previous.previousElementSibling\n  }\n\n  return true\n}\n", "'use client'\n\nimport React, {\n  createContext,\n  useContext,\n  useMemo,\n  useState,\n  type ElementType,\n  type ReactNode,\n  type Ref,\n} from 'react'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useDisabled } from '../../internal/disabled'\nimport type { Props } from '../../types'\nimport { forwardRefWithAs, render, type HasDisplayName, type RefProp } from '../../utils/render'\n\n// ---\n\ninterface SharedData {\n  slot?: {}\n  name?: string\n  props?: {}\n}\n\nlet DescriptionContext = createContext<\n  ({ value: string | undefined; register(value: string): () => void } & SharedData) | null\n>(null)\nDescriptionContext.displayName = 'DescriptionContext'\n\nfunction useDescriptionContext() {\n  let context = useContext(DescriptionContext)\n  if (context === null) {\n    let err = new Error(\n      'You used a <Description /> component, but it is not inside a relevant parent.'\n    )\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDescriptionContext)\n    throw err\n  }\n  return context\n}\n\nexport function useDescribedBy() {\n  return useContext(DescriptionContext)?.value ?? undefined\n}\n\ninterface DescriptionProviderProps extends SharedData {\n  children: ReactNode\n  value?: string | undefined\n}\n\nexport function useDescriptions(): [\n  string | undefined,\n  (props: DescriptionProviderProps) => JSX.Element,\n] {\n  let [descriptionIds, setDescriptionIds] = useState<string[]>([])\n\n  return [\n    // The actual id's as string or undefined\n    descriptionIds.length > 0 ? descriptionIds.join(' ') : undefined,\n\n    // The provider component\n    useMemo(() => {\n      return function DescriptionProvider(props: DescriptionProviderProps) {\n        let register = useEvent((value: string) => {\n          setDescriptionIds((existing) => [...existing, value])\n\n          return () => {\n            return setDescriptionIds((existing) => {\n              let clone = existing.slice()\n              let idx = clone.indexOf(value)\n              if (idx !== -1) clone.splice(idx, 1)\n              return clone\n            })\n          }\n        })\n\n        let contextBag = useMemo(\n          () => ({\n            register,\n            slot: props.slot,\n            name: props.name,\n            props: props.props,\n            value: props.value,\n          }),\n          [register, props.slot, props.name, props.props, props.value]\n        )\n\n        return (\n          <DescriptionContext.Provider value={contextBag}>\n            {props.children}\n          </DescriptionContext.Provider>\n        )\n      }\n    }, [setDescriptionIds]),\n  ]\n}\n\n// ---\n\nlet DEFAULT_DESCRIPTION_TAG = 'p' as const\n\nexport type DescriptionProps<TTag extends ElementType = typeof DEFAULT_DESCRIPTION_TAG> =\n  Props<TTag>\n\nfunction DescriptionFn<TTag extends ElementType = typeof DEFAULT_DESCRIPTION_TAG>(\n  props: DescriptionProps<TTag>,\n  ref: Ref<HTMLParagraphElement>\n) {\n  let internalId = useId()\n  let providedDisabled = useDisabled()\n  let { id = `headlessui-description-${internalId}`, ...theirProps } = props\n  let context = useDescriptionContext()\n  let descriptionRef = useSyncRefs(ref)\n\n  useIsoMorphicEffect(() => context.register(id), [id, context.register])\n\n  let disabled = providedDisabled || false\n  let slot = useMemo(() => ({ ...context.slot, disabled }), [context.slot, disabled])\n  let ourProps = { ref: descriptionRef, ...context.props, id }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DESCRIPTION_TAG,\n    name: context.name || 'Description',\n  })\n}\n\n// ---\nexport interface _internal_ComponentDescription extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_DESCRIPTION_TAG>(\n    props: DescriptionProps<TTag> & RefProp<typeof DescriptionFn>\n  ): JSX.Element\n}\n\nlet DescriptionRoot = forwardRefWithAs(DescriptionFn) as unknown as _internal_ComponentDescription\n\nexport let Description = Object.assign(DescriptionRoot, {\n  //\n})\n", "import { useEffect, useRef } from 'react'\nimport { useEvent } from './use-event'\n\nlet Optional = Symbol()\n\nexport function optionalRef<T>(cb: (ref: T) => void, isOptional = true) {\n  return Object.assign(cb, { [Optional]: isOptional })\n}\n\nexport function useSyncRefs<TType>(\n  ...refs: (React.MutableRefObject<TType | null> | ((instance: TType) => void) | null)[]\n) {\n  let cache = useRef(refs)\n\n  useEffect(() => {\n    cache.current = refs\n  }, [refs])\n\n  let syncRefs = useEvent((value: TType) => {\n    for (let ref of cache.current) {\n      if (ref == null) continue\n      if (typeof ref === 'function') ref(value)\n      else ref.current = value\n    }\n  })\n\n  return refs.every(\n    (ref) =>\n      ref == null ||\n      // @ts-expect-error\n      ref?.[Optional]\n  )\n    ? undefined\n    : syncRefs\n}\n", "'use client'\n\nimport React, {\n  createContext,\n  useContext,\n  useMemo,\n  useState,\n  type ElementType,\n  type MouseEvent as ReactMouseEvent,\n  type ReactNode,\n  type Ref,\n} from 'react'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useDisabled } from '../../internal/disabled'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport { forwardRefWithAs, render, type HasDisplayName, type RefProp } from '../../utils/render'\n\n// ---\n\ninterface SharedData {\n  slot?: {}\n  name?: string\n  props?: Record<string, any>\n}\n\nlet LabelContext = createContext<\n  ({ value: string | undefined; register(value: string): () => void } & SharedData) | null\n>(null)\nLabelContext.displayName = 'LabelContext'\n\nexport function useLabelContext() {\n  let context = useContext(LabelContext)\n  if (context === null) {\n    let err = new Error('You used a <Label /> component, but it is not inside a relevant parent.')\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useLabelContext)\n    throw err\n  }\n  return context\n}\n\nexport function useLabelledBy(alwaysAvailableIds?: (string | undefined | null)[]) {\n  let labelIds = useContext(LabelContext)?.value ?? undefined\n  if ((alwaysAvailableIds?.length ?? 0) > 0) {\n    return [labelIds, ...alwaysAvailableIds!].filter(Boolean).join(' ')\n  }\n  return labelIds\n}\n\ninterface LabelProviderProps extends SharedData {\n  children: ReactNode\n  value?: string | undefined\n}\n\nexport function useLabels({ inherit = false } = {}): [\n  string | undefined,\n  (props: LabelProviderProps & { inherit?: boolean }) => JSX.Element,\n] {\n  let parentLabelledBy = useLabelledBy()\n  let [labelIds, setLabelIds] = useState<string[]>([])\n\n  let allLabelIds = inherit ? [parentLabelledBy, ...labelIds].filter(Boolean) : labelIds\n\n  return [\n    // The actual id's as string or undefined.\n    allLabelIds.length > 0 ? allLabelIds.join(' ') : undefined,\n\n    // The provider component\n    useMemo(() => {\n      return function LabelProvider(props: LabelProviderProps) {\n        let register = useEvent((value: string) => {\n          setLabelIds((existing) => [...existing, value])\n\n          return () => {\n            return setLabelIds((existing) => {\n              let clone = existing.slice()\n              let idx = clone.indexOf(value)\n              if (idx !== -1) clone.splice(idx, 1)\n              return clone\n            })\n          }\n        })\n\n        let contextBag = useMemo(\n          () => ({\n            register,\n            slot: props.slot,\n            name: props.name,\n            props: props.props,\n            value: props.value,\n          }),\n          [register, props.slot, props.name, props.props, props.value]\n        )\n\n        return <LabelContext.Provider value={contextBag}>{props.children}</LabelContext.Provider>\n      }\n    }, [setLabelIds]),\n  ]\n}\n\n// ---\n\nlet DEFAULT_LABEL_TAG = 'label' as const\n\nexport type LabelProps<TTag extends ElementType = typeof DEFAULT_LABEL_TAG> = Props<TTag> & {\n  passive?: boolean\n  htmlFor?: string\n}\n\nfunction LabelFn<TTag extends ElementType = typeof DEFAULT_LABEL_TAG>(\n  props: LabelProps<TTag>,\n  ref: Ref<HTMLLabelElement>\n) {\n  let internalId = useId()\n  let context = useLabelContext()\n  let providedHtmlFor = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = `headlessui-label-${internalId}`,\n    htmlFor = providedHtmlFor ?? context.props?.htmlFor,\n    passive = false,\n    ...theirProps\n  } = props\n  let labelRef = useSyncRefs(ref)\n\n  useIsoMorphicEffect(() => context.register(id), [id, context.register])\n\n  let handleClick = useEvent((e: ReactMouseEvent) => {\n    let current = e.currentTarget\n\n    // Labels connected to 'real' controls will already click the element. But we don't know that\n    // ahead of time. This will prevent the default click, such that only a single click happens\n    // instead of two. Otherwise this results in a visual no-op.\n    if (current instanceof HTMLLabelElement) {\n      e.preventDefault()\n    }\n\n    // Ensure `onClick` from context is called\n    if (\n      context.props &&\n      'onClick' in context.props &&\n      typeof context.props.onClick === 'function'\n    ) {\n      context.props.onClick(e)\n    }\n\n    if (current instanceof HTMLLabelElement) {\n      let target = document.getElementById(current.htmlFor)\n      if (target) {\n        // Bail if the target element is disabled\n        let actuallyDisabled = target.getAttribute('disabled')\n        if (actuallyDisabled === 'true' || actuallyDisabled === '') {\n          return\n        }\n\n        let ariaDisabled = target.getAttribute('aria-disabled')\n        if (ariaDisabled === 'true' || ariaDisabled === '') {\n          return\n        }\n\n        // Ensure we click the element this label is bound to. This is necessary for elements that\n        // immediately require state changes, e.g.: Radio & Checkbox inputs need to be checked (or\n        // unchecked).\n        if (\n          (target instanceof HTMLInputElement &&\n            (target.type === 'radio' || target.type === 'checkbox')) ||\n          target.role === 'radio' ||\n          target.role === 'checkbox' ||\n          target.role === 'switch'\n        ) {\n          target.click()\n        }\n\n        // Move focus to the element, this allows you to start using keyboard shortcuts since the\n        // bound element is now focused.\n        target.focus({ preventScroll: true })\n      }\n    }\n  })\n\n  let disabled = providedDisabled || false\n  let slot = useMemo(() => ({ ...context.slot, disabled }), [context.slot, disabled])\n\n  let ourProps = {\n    ref: labelRef,\n    ...context.props,\n    id,\n    htmlFor,\n    onClick: handleClick,\n  }\n\n  if (passive) {\n    if ('onClick' in ourProps) {\n      delete (ourProps as any)['htmlFor']\n      delete (ourProps as any)['onClick']\n    }\n\n    if ('onClick' in theirProps) {\n      delete (theirProps as any)['onClick']\n    }\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: htmlFor ? DEFAULT_LABEL_TAG : 'div',\n    name: context.name || 'Label',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentLabel extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_LABEL_TAG>(\n    props: LabelProps<TTag> & RefProp<typeof LabelFn>\n  ): JSX.Element\n}\n\nlet LabelRoot = forwardRefWithAs(LabelFn) as unknown as _internal_ComponentLabel\n\nexport let Label = Object.assign(LabelRoot, {\n  //\n})\n", "/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n//# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n", "/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n//# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n", "export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => any\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  return (): TResult => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result!\n  }\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n", "import { approxEqual, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\ninterface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (offset: number) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb(element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop'])\n  }\n  handler()\n\n  element.addEventListener('scroll', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: (offset: number) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb(element[instance.options.horizontal ? 'scrollX' : 'scrollY'])\n  }\n  handler()\n\n  element.addEventListener('scroll', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = window.scrollY,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (instance: Virtualizer<TScrollElement, TItemElement>) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => number[]\n  scrollMargin?: number\n  scrollingDelay?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: VirtualItem[]\n  lanes?: number\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: (void | (() => void))[] = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  isScrolling: boolean = false\n  private isScrollingTimeoutId: ReturnType<typeof setTimeout> | null = null\n  private scrollToIndexTimeoutId: ReturnType<typeof setTimeout> | null = null\n  measurementsCache: VirtualItem[] = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: number[] = []\n  private scrollRect: Rect\n  scrollOffset: number\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments: number = 0\n  measureElementCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return (_ro = new ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target as TItemElement, entry)\n          })\n        }))\n      } else {\n        return null\n      }\n    }\n\n    return {\n      disconnect: () => get()?.disconnect(),\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } = {\n    startIndex: 0,\n    endIndex: 0,\n  }\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n    this.scrollRect = this.options.initialRect\n    this.scrollOffset = this.options.initialOffset\n    this.measurementsCache = this.options.initialMeasurementsCache\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size)\n    })\n\n    this.maybeNotify()\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      ...opts,\n    }\n  }\n\n  private notify = () => {\n    this.options.onChange?.(this)\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n  }\n\n  _didMount = () => {\n    this.measureElementCache.forEach(this.observer.observe)\n    return () => {\n      this.observer.disconnect()\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.getScrollElement()\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      this.scrollElement = scrollElement\n\n      this._scrollToOffset(this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          const prev = this.scrollRect\n          this.scrollRect = rect\n          if (\n            this.options.horizontal\n              ? rect.width !== prev.width\n              : rect.height !== prev.height\n          ) {\n            this.maybeNotify()\n          }\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset) => {\n          this.scrollAdjustments = 0\n\n          if (this.scrollOffset === offset) {\n            return\n          }\n\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId)\n            this.isScrollingTimeoutId = null\n          }\n\n          this.isScrolling = true\n          this.scrollDirection =\n            this.scrollOffset < offset ? 'forward' : 'backward'\n          this.scrollOffset = offset\n\n          this.maybeNotify()\n\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null\n            this.isScrolling = false\n            this.scrollDirection = null\n\n            this.maybeNotify()\n          }, this.options.scrollingDelay)\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private memoOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getFurthestMeasurement = (\n    measurements: VirtualItem[],\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort(\n          (a, b) => a.end - b.end,\n        )[0]\n      : undefined\n  }\n\n  private getMeasurements = memo(\n    () => [this.memoOptions(), this.itemSizeCache],\n    ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset,\n      }))\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private maybeNotify = memo(\n    () => {\n      const range = this.calculateRange()\n\n      return [range.startIndex, range.endIndex, this.isScrolling]\n    },\n    () => {\n      this.notify()\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.range.startIndex,\n        this.range.endIndex,\n        this.isScrolling,\n      ],\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({\n        ...range,\n        overscan,\n        count,\n      })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const item = this.measurementsCache[this.indexFromElement(node)]\n    if (!item) {\n      this.measureElementCache.forEach((cached, key) => {\n        if (cached === node) {\n          this.observer.unobserve(node)\n          this.measureElementCache.delete(key)\n        }\n      })\n      return\n    }\n\n    const prevNode = this.measureElementCache.get(item.key)\n\n    if (!node.isConnected) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n        this.measureElementCache.delete(item.key)\n      }\n      return\n    }\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.measureElementCache.set(item.key, node)\n    }\n\n    const measuredItemSize = this.options.measureElement(node, entry, this)\n\n    this.resizeItem(item, measuredItemSize)\n  }\n\n  resizeItem = (item: VirtualItem, size: number) => {\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (item.start < this.scrollOffset) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify()\n    }\n  }\n\n  measureElement = (node: TItemElement | null) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: VirtualItem[] = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n\n    if (align === 'auto') {\n      if (toOffset <= this.scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= this.scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - this.getSize()\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const measurement = notUndefined(this.getMeasurements()[index])\n\n    if (align === 'auto') {\n      if (\n        measurement.end >=\n        this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd\n      ) {\n        align = 'end'\n      } else if (\n        measurement.start <=\n        this.scrollOffset + this.options.scrollPaddingStart\n      ) {\n        align = 'start'\n      } else {\n        return [this.scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? measurement.end + this.options.scrollPaddingEnd\n        : measurement.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.measureElementCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null) {\n      clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const [toOffset, align] = this.getOffsetForIndex(index, initialAlign)\n\n    this._scrollToOffset(toOffset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode()) {\n      this.scrollToIndexTimeoutId = setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.measureElementCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [toOffset] = this.getOffsetForIndex(index, align)\n\n          if (!approxEqual(toOffset, this.scrollOffset)) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.scrollOffset + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () =>\n    (this.getMeasurements()[this.options.count - 1]?.end ||\n      this.options.paddingStart) -\n    this.options.scrollMargin +\n    this.options.paddingEnd\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.notify()\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: VirtualItem[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n", "import * as React from 'react'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance) => {\n      rerender()\n      options.onChange?.(instance)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    ...options,\n  })\n}\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { Virtualizer, useVirtualizer } from '@tanstack/react-virtual'\nimport React, {\n  Fragment,\n  createContext,\n  createRef,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  type ElementType,\n  type MutableRefObject,\n  type FocusEvent as ReactFocusEvent,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useByComparator, type ByComparator } from '../../hooks/use-by-comparator'\nimport { useControllable } from '../../hooks/use-controllable'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useOutsideClick } from '../../hooks/use-outside-click'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useTrackedPointer } from '../../hooks/use-tracked-pointer'\nimport { useTreeWalker } from '../../hooks/use-tree-walker'\nimport { useWatch } from '../../hooks/use-watch'\nimport { useDisabled } from '../../internal/disabled'\nimport {\n  FloatingProvider,\n  useFloatingPanel,\n  useFloatingPanelProps,\n  useFloatingReference,\n  type AnchorProps,\n} from '../../internal/floating'\nimport { FormFields } from '../../internal/form-fields'\nimport { useProvidedId } from '../../internal/id'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { EnsureArray, Expand, Props } from '../../types'\nimport { history } from '../../utils/active-element-history'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { Focus, calculateActiveIndex } from '../../utils/calculate-active-index'\nimport { disposables } from '../../utils/disposables'\nimport { sortByDomNode } from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport { isMobile } from '../../utils/platform'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { Keys } from '../keyboard'\nimport { Label, useLabelledBy, useLabels, type _internal_ComponentLabel } from '../label/label'\n\nenum ComboboxState {\n  Open,\n  Closed,\n}\n\nenum ValueMode {\n  Single,\n  Multi,\n}\n\nenum ActivationTrigger {\n  Pointer,\n  Focus,\n  Other,\n}\n\ntype ComboboxOptionDataRef<T> = MutableRefObject<{\n  disabled: boolean\n  value: T\n  domRef: MutableRefObject<HTMLElement | null>\n  order: number | null\n}>\n\ninterface StateDefinition<T> {\n  dataRef: MutableRefObject<_Data | null>\n\n  virtual: { options: T[]; disabled: (value: unknown) => boolean } | null\n\n  comboboxState: ComboboxState\n\n  options: { id: string; dataRef: ComboboxOptionDataRef<T> }[]\n  activeOptionIndex: number | null\n  activationTrigger: ActivationTrigger\n}\n\nenum ActionTypes {\n  OpenCombobox,\n  CloseCombobox,\n\n  GoToOption,\n\n  RegisterOption,\n  UnregisterOption,\n\n  SetActivationTrigger,\n\n  UpdateVirtualOptions,\n}\n\nfunction adjustOrderedState<T>(\n  state: StateDefinition<T>,\n  adjustment: (options: StateDefinition<T>['options']) => StateDefinition<T>['options'] = (i) => i\n) {\n  let currentActiveOption =\n    state.activeOptionIndex !== null ? state.options[state.activeOptionIndex] : null\n\n  let list = adjustment(state.options.slice())\n  let sortedOptions =\n    list.length > 0 && list[0].dataRef.current.order !== null\n      ? // Prefer sorting based on the `order`\n        list.sort((a, z) => a.dataRef.current.order! - z.dataRef.current.order!)\n      : // Fallback to much slower DOM order\n        sortByDomNode(list, (option) => option.dataRef.current.domRef.current)\n\n  // If we inserted an option before the current active option then the active option index\n  // would be wrong. To fix this, we will re-lookup the correct index.\n  let adjustedActiveOptionIndex = currentActiveOption\n    ? sortedOptions.indexOf(currentActiveOption)\n    : null\n\n  // Reset to `null` in case the currentActiveOption was removed.\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null\n  }\n\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex,\n  }\n}\n\ntype Actions<T> =\n  | { type: ActionTypes.CloseCombobox }\n  | { type: ActionTypes.OpenCombobox }\n  | {\n      type: ActionTypes.GoToOption\n      focus: Focus.Specific\n      idx: number\n      trigger?: ActivationTrigger\n    }\n  | {\n      type: ActionTypes.GoToOption\n      focus: Exclude<Focus, Focus.Specific>\n      trigger?: ActivationTrigger\n    }\n  | {\n      type: ActionTypes.RegisterOption\n      payload: { id: string; dataRef: ComboboxOptionDataRef<T> }\n    }\n  | { type: ActionTypes.UnregisterOption; id: string }\n  | { type: ActionTypes.SetActivationTrigger; trigger: ActivationTrigger }\n  | { type: ActionTypes.UpdateVirtualOptions; options: T[] }\n\nlet reducers: {\n  [P in ActionTypes]: <T>(\n    state: StateDefinition<T>,\n    action: Extract<Actions<T>, { type: P }>\n  ) => StateDefinition<T>\n} = {\n  [ActionTypes.CloseCombobox](state) {\n    if (state.dataRef.current?.disabled) return state\n    if (state.comboboxState === ComboboxState.Closed) return state\n\n    return { ...state, activeOptionIndex: null, comboboxState: ComboboxState.Closed }\n  },\n  [ActionTypes.OpenCombobox](state) {\n    if (state.dataRef.current?.disabled) return state\n    if (state.comboboxState === ComboboxState.Open) return state\n\n    // Check if we have a selected value that we can make active\n    if (state.dataRef.current?.value) {\n      let idx = state.dataRef.current.calculateIndex(state.dataRef.current.value)\n      if (idx !== -1) {\n        return {\n          ...state,\n          activeOptionIndex: idx,\n          comboboxState: ComboboxState.Open,\n        }\n      }\n    }\n\n    return { ...state, comboboxState: ComboboxState.Open }\n  },\n  [ActionTypes.GoToOption](state, action) {\n    if (state.dataRef.current?.disabled) return state\n    if (\n      state.dataRef.current?.optionsRef.current &&\n      !state.dataRef.current?.optionsPropsRef.current.static &&\n      state.comboboxState === ComboboxState.Closed\n    ) {\n      return state\n    }\n\n    if (state.virtual) {\n      let activeOptionIndex =\n        action.focus === Focus.Specific\n          ? action.idx\n          : calculateActiveIndex(action, {\n              resolveItems: () => state.virtual!.options,\n              resolveActiveIndex: () =>\n                state.activeOptionIndex ??\n                state.virtual!.options.findIndex((option) => !state.virtual!.disabled(option)) ??\n                null,\n              resolveDisabled: state.virtual!.disabled,\n              resolveId() {\n                throw new Error('Function not implemented.')\n              },\n            })\n\n      let activationTrigger = action.trigger ?? ActivationTrigger.Other\n\n      if (\n        state.activeOptionIndex === activeOptionIndex &&\n        state.activationTrigger === activationTrigger\n      ) {\n        return state\n      }\n\n      return {\n        ...state,\n        activeOptionIndex,\n        activationTrigger,\n      }\n    }\n\n    let adjustedState = adjustOrderedState(state)\n\n    // It's possible that the activeOptionIndex is set to `null` internally, but\n    // this means that we will fallback to the first non-disabled option by default.\n    // We have to take this into account.\n    if (adjustedState.activeOptionIndex === null) {\n      let localActiveOptionIndex = adjustedState.options.findIndex(\n        (option) => !option.dataRef.current.disabled\n      )\n\n      if (localActiveOptionIndex !== -1) {\n        adjustedState.activeOptionIndex = localActiveOptionIndex\n      }\n    }\n\n    let activeOptionIndex =\n      action.focus === Focus.Specific\n        ? action.idx\n        : calculateActiveIndex(action, {\n            resolveItems: () => adjustedState.options,\n            resolveActiveIndex: () => adjustedState.activeOptionIndex,\n            resolveId: (item) => item.id,\n            resolveDisabled: (item) => item.dataRef.current.disabled,\n          })\n    let activationTrigger = action.trigger ?? ActivationTrigger.Other\n\n    if (\n      state.activeOptionIndex === activeOptionIndex &&\n      state.activationTrigger === activationTrigger\n    ) {\n      return state\n    }\n\n    return {\n      ...state,\n      ...adjustedState,\n      activeOptionIndex,\n      activationTrigger,\n    }\n  },\n  [ActionTypes.RegisterOption]: (state, action) => {\n    if (state.dataRef.current?.virtual) {\n      return {\n        ...state,\n        options: [...state.options, action.payload],\n      }\n    }\n\n    let option = action.payload\n\n    let adjustedState = adjustOrderedState(state, (options) => {\n      options.push(option)\n      return options\n    })\n\n    // Check if we need to make the newly registered option active.\n    if (state.activeOptionIndex === null) {\n      if (state.dataRef.current?.isSelected(action.payload.dataRef.current.value)) {\n        adjustedState.activeOptionIndex = adjustedState.options.indexOf(option)\n      }\n    }\n\n    let nextState = {\n      ...state,\n      ...adjustedState,\n      activationTrigger: ActivationTrigger.Other,\n    }\n\n    if (state.dataRef.current?.__demoMode && state.dataRef.current.value === undefined) {\n      nextState.activeOptionIndex = 0\n    }\n\n    return nextState\n  },\n  [ActionTypes.UnregisterOption]: (state, action) => {\n    if (state.dataRef.current?.virtual) {\n      return {\n        ...state,\n        options: state.options.filter((option) => option.id !== action.id),\n      }\n    }\n\n    let adjustedState = adjustOrderedState(state, (options) => {\n      let idx = options.findIndex((option) => option.id === action.id)\n      if (idx !== -1) options.splice(idx, 1)\n      return options\n    })\n\n    return {\n      ...state,\n      ...adjustedState,\n      activationTrigger: ActivationTrigger.Other,\n    }\n  },\n  [ActionTypes.SetActivationTrigger]: (state, action) => {\n    if (state.activationTrigger === action.trigger) {\n      return state\n    }\n\n    return {\n      ...state,\n      activationTrigger: action.trigger,\n    }\n  },\n  [ActionTypes.UpdateVirtualOptions]: (state, action) => {\n    if (state.virtual?.options === action.options) {\n      return state\n    }\n\n    let adjustedActiveOptionIndex = state.activeOptionIndex\n    if (state.activeOptionIndex !== null) {\n      let idx = action.options.indexOf(state.virtual!.options[state.activeOptionIndex])\n      if (idx !== -1) {\n        adjustedActiveOptionIndex = idx\n      } else {\n        adjustedActiveOptionIndex = null\n      }\n    }\n\n    return {\n      ...state,\n      activeOptionIndex: adjustedActiveOptionIndex,\n      virtual: Object.assign({}, state.virtual, { options: action.options }),\n    }\n  },\n}\n\nlet ComboboxActionsContext = createContext<{\n  openCombobox(): void\n  closeCombobox(): void\n  registerOption(id: string, dataRef: ComboboxOptionDataRef<unknown>): () => void\n  goToOption(focus: Focus.Specific, idx: number, trigger?: ActivationTrigger): void\n  goToOption(focus: Focus, idx?: number, trigger?: ActivationTrigger): void\n  selectActiveOption(): void\n  setActivationTrigger(trigger: ActivationTrigger): void\n  onChange(value: unknown): void\n} | null>(null)\nComboboxActionsContext.displayName = 'ComboboxActionsContext'\n\nfunction useActions(component: string) {\n  let context = useContext(ComboboxActionsContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useActions)\n    throw err\n  }\n  return context\n}\ntype _Actions = ReturnType<typeof useActions>\n\nlet VirtualContext = createContext<Virtualizer<any, any> | null>(null)\n\nfunction VirtualProvider(props: {\n  children: (data: { option: unknown; open: boolean }) => React.ReactElement\n}) {\n  let data = useData('VirtualProvider')\n\n  let [paddingStart, paddingEnd] = useMemo(() => {\n    let el = data.optionsRef.current\n    if (!el) return [0, 0]\n\n    let styles = window.getComputedStyle(el)\n\n    return [\n      parseFloat(styles.paddingBlockStart || styles.paddingTop),\n      parseFloat(styles.paddingBlockEnd || styles.paddingBottom),\n    ]\n  }, [data.optionsRef.current])\n\n  let virtualizer = useVirtualizer({\n    scrollPaddingStart: paddingStart,\n    scrollPaddingEnd: paddingEnd,\n    count: data.virtual!.options.length,\n    estimateSize() {\n      return 40\n    },\n    getScrollElement() {\n      return (data.optionsRef.current ?? null) as HTMLElement | null\n    },\n    overscan: 12,\n  })\n\n  let [baseKey, setBaseKey] = useState(0)\n  useIsoMorphicEffect(() => {\n    setBaseKey((v) => v + 1)\n  }, [data.virtual?.options])\n\n  return (\n    <VirtualContext.Provider value={virtualizer}>\n      <div\n        style={{\n          position: 'relative',\n          width: '100%',\n          height: `${virtualizer.getTotalSize()}px`,\n        }}\n        ref={(el) => {\n          if (!el) {\n            return\n          }\n\n          // Scroll to the active index\n          {\n            // Ignore this when we are in a test environment\n            if (typeof process !== 'undefined' && process.env.JEST_WORKER_ID !== undefined) {\n              return\n            }\n\n            // Do not scroll when the mouse/pointer is being used\n            if (data.activationTrigger === ActivationTrigger.Pointer) {\n              return\n            }\n\n            if (\n              data.activeOptionIndex !== null &&\n              data.virtual!.options.length > data.activeOptionIndex\n            ) {\n              virtualizer.scrollToIndex(data.activeOptionIndex)\n            }\n          }\n        }}\n      >\n        {virtualizer.getVirtualItems().map((item) => {\n          return (\n            <Fragment key={item.key}>\n              {React.cloneElement(\n                props.children?.({\n                  option: data.virtual!.options[item.index],\n                  open: data.comboboxState === ComboboxState.Open,\n                }),\n                {\n                  key: `${baseKey}-${item.key}`,\n                  'data-index': item.index,\n                  'aria-setsize': data.virtual!.options.length,\n                  'aria-posinset': item.index + 1,\n                  style: {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    transform: `translateY(${item.start}px)`,\n                    overflowAnchor: 'none',\n                  },\n                }\n              )}\n            </Fragment>\n          )\n        })}\n      </div>\n    </VirtualContext.Provider>\n  )\n}\n\nlet ComboboxDataContext = createContext<\n  | ({\n      value: unknown\n      defaultValue: unknown\n      disabled: boolean\n      mode: ValueMode\n      activeOptionIndex: number | null\n      nullable: boolean\n      immediate: boolean\n\n      virtual: { options: unknown[]; disabled: (value: unknown) => boolean } | null\n      calculateIndex(value: unknown): number\n      compare(a: unknown, z: unknown): boolean\n      isSelected(value: unknown): boolean\n      isActive(value: unknown): boolean\n\n      __demoMode: boolean\n\n      optionsPropsRef: MutableRefObject<{\n        static: boolean\n        hold: boolean\n      }>\n\n      inputRef: MutableRefObject<HTMLInputElement | null>\n      buttonRef: MutableRefObject<HTMLButtonElement | null>\n      optionsRef: MutableRefObject<HTMLUListElement | null>\n    } & Omit<StateDefinition<unknown>, 'dataRef'>)\n  | null\n>(null)\nComboboxDataContext.displayName = 'ComboboxDataContext'\n\nfunction useData(component: string) {\n  let context = useContext(ComboboxDataContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useData)\n    throw err\n  }\n  return context\n}\ntype _Data = ReturnType<typeof useData>\n\nfunction stateReducer<T>(state: StateDefinition<T>, action: Actions<T>) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_COMBOBOX_TAG = Fragment\ntype ComboboxRenderPropArg<TValue, TActive = TValue> = {\n  open: boolean\n  disabled: boolean\n  activeIndex: number | null\n  activeOption: TActive | null\n  value: TValue\n}\n\ntype O = 'value' | 'defaultValue' | 'nullable' | 'multiple' | 'onChange' | 'by'\n\ntype ComboboxValueProps<\n  TValue,\n  TNullable extends boolean | undefined,\n  TMultiple extends boolean | undefined,\n  TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG,\n> = Extract<\n  | ({\n      value?: EnsureArray<TValue>\n      defaultValue?: EnsureArray<TValue>\n      nullable: true // We ignore `nullable` in multiple mode\n      multiple: true\n      onChange?(value: EnsureArray<TValue>): void\n      by?: ByComparator<TValue>\n    } & Props<TTag, ComboboxRenderPropArg<EnsureArray<TValue>, TValue>, O>)\n  | ({\n      value?: TValue | null\n      defaultValue?: TValue | null\n      nullable: true\n      multiple?: false\n      onChange?(value: TValue | null): void\n      by?: ByComparator<TValue | null>\n    } & Expand<Props<TTag, ComboboxRenderPropArg<TValue | null>, O>>)\n  | ({\n      value?: EnsureArray<TValue>\n      defaultValue?: EnsureArray<TValue>\n      nullable?: false\n      multiple: true\n      onChange?(value: EnsureArray<TValue>): void\n      by?: ByComparator<TValue extends Array<infer U> ? U : TValue>\n    } & Expand<Props<TTag, ComboboxRenderPropArg<EnsureArray<TValue>, TValue>, O>>)\n  | ({\n      value?: TValue\n      nullable?: false\n      multiple?: false\n      defaultValue?: TValue\n      onChange?(value: TValue): void\n      by?: ByComparator<TValue>\n    } & Props<TTag, ComboboxRenderPropArg<TValue>, O>),\n  { nullable?: TNullable; multiple?: TMultiple }\n>\n\nexport type ComboboxProps<\n  TValue,\n  TNullable extends boolean | undefined,\n  TMultiple extends boolean | undefined,\n  TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG,\n> = ComboboxValueProps<TValue, TNullable, TMultiple, TTag> & {\n  disabled?: boolean\n  __demoMode?: boolean\n  form?: string\n  name?: string\n  immediate?: boolean\n  virtual?: {\n    options: TValue[]\n    disabled?: (value: TValue) => boolean\n  } | null\n}\n\nfunction ComboboxFn<TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n  props: ComboboxProps<TValue, true, true, TTag>,\n  ref: Ref<HTMLElement>\n): JSX.Element\nfunction ComboboxFn<TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n  props: ComboboxProps<TValue, true, false, TTag>,\n  ref: Ref<HTMLElement>\n): JSX.Element\nfunction ComboboxFn<TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n  props: ComboboxProps<TValue, false, false, TTag>,\n  ref: Ref<HTMLElement>\n): JSX.Element\nfunction ComboboxFn<TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n  props: ComboboxProps<TValue, false, true, TTag>,\n  ref: Ref<HTMLElement>\n): JSX.Element\n\nfunction ComboboxFn<TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n  props: ComboboxProps<TValue, boolean | undefined, boolean | undefined, TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let providedDisabled = useDisabled()\n  let {\n    value: controlledValue,\n    defaultValue,\n    onChange: controlledOnChange,\n    form,\n    name,\n    by,\n    disabled = providedDisabled || false,\n    __demoMode = false,\n    nullable = false,\n    multiple = false,\n    immediate = false,\n    virtual = null,\n    ...theirProps\n  } = props\n  let [value = multiple ? [] : undefined, theirOnChange] = useControllable<any>(\n    controlledValue,\n    controlledOnChange,\n    defaultValue\n  )\n\n  let [state, dispatch] = useReducer(stateReducer, {\n    dataRef: createRef(),\n    comboboxState: __demoMode ? ComboboxState.Open : ComboboxState.Closed,\n    options: [],\n    virtual: virtual\n      ? { options: virtual.options, disabled: virtual.disabled ?? (() => false) }\n      : null,\n    activeOptionIndex: null,\n    activationTrigger: ActivationTrigger.Other,\n  } as StateDefinition<TValue>)\n\n  let defaultToFirstOption = useRef(false)\n\n  let optionsPropsRef = useRef<_Data['optionsPropsRef']['current']>({ static: false, hold: false })\n\n  let inputRef = useRef<_Data['inputRef']['current']>(null)\n  let buttonRef = useRef<_Data['buttonRef']['current']>(null)\n  let optionsRef = useRef<_Data['optionsRef']['current']>(null)\n\n  type TActualValue = true extends typeof multiple ? EnsureArray<TValue>[number] : TValue\n  // @ts-expect-error Eventually we'll want to tackle this, but for now this will do.\n  let compare = useByComparator<TActualValue>(by)\n\n  let calculateIndex = useEvent((value: TValue) => {\n    if (virtual) {\n      if (by === null) {\n        return virtual.options.indexOf(value)\n      } else {\n        return virtual.options.findIndex((other) => compare(other, value))\n      }\n    } else {\n      return state.options.findIndex((other) => compare(other.dataRef.current.value, value))\n    }\n  })\n\n  let isSelected: (value: TValue) => boolean = useCallback(\n    (other) =>\n      match(data.mode, {\n        [ValueMode.Multi]: () =>\n          (value as EnsureArray<TValue>).some((option) => compare(option, other)),\n        [ValueMode.Single]: () => compare(value as TValue, other),\n      }),\n    [value]\n  )\n\n  let isActive = useEvent((other: TValue) => {\n    return state.activeOptionIndex === calculateIndex(other)\n  })\n\n  let data = useMemo<_Data>(\n    () => ({\n      ...state,\n      immediate,\n      optionsPropsRef,\n      inputRef,\n      buttonRef,\n      optionsRef,\n      value,\n      defaultValue,\n      disabled,\n      mode: multiple ? ValueMode.Multi : ValueMode.Single,\n      virtual: state.virtual,\n      get activeOptionIndex() {\n        if (\n          defaultToFirstOption.current &&\n          state.activeOptionIndex === null &&\n          (virtual ? virtual.options.length > 0 : state.options.length > 0)\n        ) {\n          if (virtual) {\n            let localActiveOptionIndex = virtual.options.findIndex(\n              (option) => !(virtual?.disabled?.(option) ?? false)\n            )\n\n            if (localActiveOptionIndex !== -1) {\n              return localActiveOptionIndex\n            }\n          }\n\n          let localActiveOptionIndex = state.options.findIndex((option) => {\n            return !option.dataRef.current.disabled\n          })\n\n          if (localActiveOptionIndex !== -1) {\n            return localActiveOptionIndex\n          }\n        }\n\n        return state.activeOptionIndex\n      },\n      calculateIndex,\n      compare,\n      isSelected,\n      isActive,\n      nullable,\n      __demoMode,\n    }),\n    [value, defaultValue, disabled, multiple, nullable, __demoMode, state, virtual]\n  )\n\n  useIsoMorphicEffect(() => {\n    if (!virtual) return\n    dispatch({ type: ActionTypes.UpdateVirtualOptions, options: virtual.options })\n  }, [virtual, virtual?.options])\n\n  useIsoMorphicEffect(() => {\n    state.dataRef.current = data\n  }, [data])\n\n  // Handle outside click\n  useOutsideClick(\n    [data.buttonRef, data.inputRef, data.optionsRef],\n    () => actions.closeCombobox(),\n    data.comboboxState === ComboboxState.Open\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.comboboxState === ComboboxState.Open,\n        disabled,\n        activeIndex: data.activeOptionIndex,\n        activeOption:\n          data.activeOptionIndex === null\n            ? null\n            : data.virtual\n              ? data.virtual.options[data.activeOptionIndex ?? 0]\n              : (data.options[data.activeOptionIndex]?.dataRef.current.value as TValue) ?? null,\n        value,\n      }) satisfies ComboboxRenderPropArg<unknown>,\n    [data, disabled, value]\n  )\n\n  let selectActiveOption = useEvent(() => {\n    if (data.activeOptionIndex === null) return\n\n    if (data.virtual) {\n      onChange(data.virtual.options[data.activeOptionIndex])\n    } else {\n      let { dataRef } = data.options[data.activeOptionIndex]\n      onChange(dataRef.current.value)\n    }\n\n    // It could happen that the `activeOptionIndex` stored in state is actually null, but we are\n    // getting the fallback active option back instead.\n    actions.goToOption(Focus.Specific, data.activeOptionIndex)\n  })\n\n  let openCombobox = useEvent(() => {\n    dispatch({ type: ActionTypes.OpenCombobox })\n    defaultToFirstOption.current = true\n  })\n\n  let closeCombobox = useEvent(() => {\n    dispatch({ type: ActionTypes.CloseCombobox })\n    defaultToFirstOption.current = false\n  })\n\n  let goToOption = useEvent((focus, idx, trigger) => {\n    defaultToFirstOption.current = false\n\n    if (focus === Focus.Specific) {\n      return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, idx: idx!, trigger })\n    }\n\n    return dispatch({ type: ActionTypes.GoToOption, focus, trigger })\n  })\n\n  let registerOption = useEvent((id, dataRef) => {\n    dispatch({ type: ActionTypes.RegisterOption, payload: { id, dataRef } })\n    return () => {\n      // When we are unregistering the currently active option, then we also have to make sure to\n      // reset the `defaultToFirstOption` flag, so that visually something is selected and the next\n      // time you press a key on your keyboard it will go to the proper next or previous option in\n      // the list.\n      //\n      // Since this was the active option and it could have been anywhere in the list, resetting to\n      // the very first option seems like a fine default. We _could_ be smarter about this by going\n      // to the previous / next item in list if we know the direction of the keyboard navigation,\n      // but that might be too complex/confusing from an end users perspective.\n      if (data.isActive(dataRef.current.value)) {\n        defaultToFirstOption.current = true\n      }\n\n      dispatch({ type: ActionTypes.UnregisterOption, id })\n    }\n  })\n\n  let onChange = useEvent((value: unknown) => {\n    return match(data.mode, {\n      [ValueMode.Single]() {\n        return theirOnChange?.(value as TValue)\n      },\n      [ValueMode.Multi]() {\n        let copy = (data.value as TValue[]).slice()\n\n        let idx = copy.findIndex((item) => compare(item, value as TValue))\n        if (idx === -1) {\n          copy.push(value as TValue)\n        } else {\n          copy.splice(idx, 1)\n        }\n\n        return theirOnChange?.(copy as unknown as TValue[])\n      },\n    })\n  })\n\n  let setActivationTrigger = useEvent((trigger: ActivationTrigger) => {\n    dispatch({ type: ActionTypes.SetActivationTrigger, trigger })\n  })\n\n  let actions = useMemo<_Actions>(\n    () => ({\n      onChange,\n      registerOption,\n      goToOption,\n      closeCombobox,\n      openCombobox,\n      setActivationTrigger,\n      selectActiveOption,\n    }),\n    []\n  )\n\n  let [labelledby, LabelProvider] = useLabels()\n\n  let ourProps = ref === null ? {} : { ref }\n\n  let reset = useCallback(() => {\n    return theirOnChange?.(defaultValue)\n  }, [theirOnChange /* Explicitly ignoring `defaultValue` */])\n\n  return (\n    <LabelProvider\n      value={labelledby}\n      props={{\n        htmlFor: data.inputRef.current?.id,\n      }}\n      slot={{\n        open: data.comboboxState === ComboboxState.Open,\n        disabled,\n      }}\n    >\n      <FloatingProvider>\n        <ComboboxActionsContext.Provider value={actions}>\n          <ComboboxDataContext.Provider value={data}>\n            <OpenClosedProvider\n              value={match(data.comboboxState, {\n                [ComboboxState.Open]: State.Open,\n                [ComboboxState.Closed]: State.Closed,\n              })}\n            >\n              {name != null && (\n                <FormFields\n                  data={value != null ? { [name]: value } : {}}\n                  form={form}\n                  onReset={reset}\n                />\n              )}\n              {render({\n                ourProps,\n                theirProps,\n                slot,\n                defaultTag: DEFAULT_COMBOBOX_TAG,\n                name: 'Combobox',\n              })}\n            </OpenClosedProvider>\n          </ComboboxDataContext.Provider>\n        </ComboboxActionsContext.Provider>\n      </FloatingProvider>\n    </LabelProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_INPUT_TAG = 'input' as const\ntype InputRenderPropArg = {\n  open: boolean\n  disabled: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n}\ntype InputPropsWeControl =\n  | 'aria-activedescendant'\n  | 'aria-autocomplete'\n  | 'aria-controls'\n  | 'aria-expanded'\n  | 'aria-labelledby'\n  | 'disabled'\n  | 'role'\n\nexport type ComboboxInputProps<\n  TTag extends ElementType = typeof DEFAULT_INPUT_TAG,\n  TType = string,\n> = Props<\n  TTag,\n  InputRenderPropArg,\n  InputPropsWeControl,\n  {\n    defaultValue?: TType\n    displayValue?(item: TType): string\n    onChange?(event: React.ChangeEvent<HTMLInputElement>): void\n    autoFocus?: boolean\n  }\n>\n\nfunction InputFn<\n  TTag extends ElementType = typeof DEFAULT_INPUT_TAG,\n  // TODO: One day we will be able to infer this type from the generic in Combobox itself.\n  // But today is not that day..\n  TType = Parameters<typeof ComboboxRoot>[0]['value'],\n>(props: ComboboxInputProps<TTag, TType>, ref: Ref<HTMLInputElement>) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let {\n    id = providedId || `headlessui-combobox-input-${internalId}`,\n    onChange,\n    displayValue,\n    // @ts-ignore: We know this MAY NOT exist for a given tag but we only care when it _does_ exist.\n    type = 'text',\n    ...theirProps\n  } = props\n  let data = useData('Combobox.Input')\n  let actions = useActions('Combobox.Input')\n\n  let inputRef = useSyncRefs(data.inputRef, ref, useFloatingReference())\n  let ownerDocument = useOwnerDocument(data.inputRef)\n\n  let isTyping = useRef(false)\n\n  let d = useDisposables()\n\n  let clear = useEvent(() => {\n    actions.onChange(null)\n    if (data.optionsRef.current) {\n      data.optionsRef.current.scrollTop = 0\n    }\n    actions.goToOption(Focus.Nothing)\n  })\n\n  // When a `displayValue` prop is given, we should use it to transform the current selected\n  // option(s) so that the format can be chosen by developers implementing this. This is useful if\n  // your data is an object and you just want to pick a certain property or want to create a dynamic\n  // value like `firstName + ' ' + lastName`.\n  //\n  // Note: This can also be used with multiple selected options, but this is a very simple transform\n  // which should always result in a string (since we are filling in the value of the text input),\n  // you don't have to use this at all, a more common UI is a \"tag\" based UI, which you can render\n  // yourself using the selected option(s).\n  let currentDisplayValue = (function () {\n    if (typeof displayValue === 'function' && data.value !== undefined) {\n      return displayValue(data.value as unknown as TType) ?? ''\n    } else if (typeof data.value === 'string') {\n      return data.value\n    } else {\n      return ''\n    }\n  })()\n\n  // Syncing the input value has some rules attached to it to guarantee a smooth and expected user\n  // experience:\n  //\n  // - When a user is not typing in the input field, it is safe to update the input value based on\n  //   the selected option(s). See `currentDisplayValue` computation from above.\n  // - The value can be updated when:\n  //   - The `value` is set from outside of the component\n  //   - The `value` is set when the user uses their keyboard (confirm via enter or space)\n  //   - The `value` is set when the user clicks on a value to select it\n  // - The value will be reset to the current selected option(s), when:\n  //   - The user is _not_ typing (otherwise you will loose your current state / query)\n  //   - The user cancels the current changes:\n  //     - By pressing `escape`\n  //     - By clicking `outside` of the Combobox\n  useWatch(\n    ([currentDisplayValue, state], [oldCurrentDisplayValue, oldState]) => {\n      // When the user is typing, we want to not touch the `input` at all. Especially when they are\n      // using an IME, we don't want to mess with the input at all.\n      if (isTyping.current) return\n\n      let input = data.inputRef.current\n      if (!input) return\n\n      if (oldState === ComboboxState.Open && state === ComboboxState.Closed) {\n        input.value = currentDisplayValue\n      } else if (currentDisplayValue !== oldCurrentDisplayValue) {\n        input.value = currentDisplayValue\n      }\n\n      // Once we synced the input value, we want to make sure the cursor is at the end of the input\n      // field. This makes it easier to continue typing and append to the query. We will bail out if\n      // the user is currently typing, because we don't want to mess with the cursor position while\n      // typing.\n      requestAnimationFrame(() => {\n        if (isTyping.current) return\n        if (!input) return\n\n        // Bail when the input is not the currently focused element. When it is not the focused\n        // element, and we call the `setSelectionRange`, then it will become the focused\n        // element which may be unwanted.\n        if (ownerDocument?.activeElement !== input) return\n\n        let { selectionStart, selectionEnd } = input\n\n        // A custom selection is used, no need to move the caret\n        if (Math.abs((selectionEnd ?? 0) - (selectionStart ?? 0)) !== 0) return\n\n        // A custom caret position is used, no need to move the caret\n        if (selectionStart !== 0) return\n\n        // Move the caret to the end\n        input.setSelectionRange(input.value.length, input.value.length)\n      })\n    },\n    [currentDisplayValue, data.comboboxState, ownerDocument]\n  )\n\n  // Trick VoiceOver in behaving a little bit better. Manually \"resetting\" the input makes VoiceOver\n  // a bit more happy and doesn't require some changes manually first before announcing items\n  // correctly. This is a bit of a hacks, but it is a workaround for a VoiceOver bug.\n  //\n  // TODO: VoiceOver is still relatively buggy if you start VoiceOver while the Combobox is already\n  // in an open state.\n  useWatch(\n    ([newState], [oldState]) => {\n      if (newState === ComboboxState.Open && oldState === ComboboxState.Closed) {\n        // When the user is typing, we want to not touch the `input` at all. Especially when they are\n        // using an IME, we don't want to mess with the input at all.\n        if (isTyping.current) return\n\n        let input = data.inputRef.current\n        if (!input) return\n\n        // Capture current state\n        let currentValue = input.value\n        let { selectionStart, selectionEnd, selectionDirection } = input\n\n        // Trick VoiceOver into announcing the value\n        input.value = ''\n\n        // Rollback to original state\n        input.value = currentValue\n        if (selectionDirection !== null) {\n          input.setSelectionRange(selectionStart, selectionEnd, selectionDirection)\n        } else {\n          input.setSelectionRange(selectionStart, selectionEnd)\n        }\n      }\n    },\n    [data.comboboxState]\n  )\n\n  let isComposing = useRef(false)\n  let handleCompositionStart = useEvent(() => {\n    isComposing.current = true\n  })\n  let handleCompositionEnd = useEvent(() => {\n    d.nextFrame(() => {\n      isComposing.current = false\n    })\n  })\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLInputElement>) => {\n    isTyping.current = true\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menu/#keyboard-interaction-12\n\n      case Keys.Enter:\n        isTyping.current = false\n        if (data.comboboxState !== ComboboxState.Open) return\n\n        // When the user is still in the middle of composing by using an IME, then we don't want to\n        // submit this value and close the Combobox yet. Instead, we will fallback to the default\n        // behaviour which is to \"end\" the composition.\n        if (isComposing.current) return\n\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (data.activeOptionIndex === null) {\n          actions.closeCombobox()\n          return\n        }\n\n        actions.selectActiveOption()\n        if (data.mode === ValueMode.Single) {\n          actions.closeCombobox()\n        }\n        break\n\n      case Keys.ArrowDown:\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return match(data.comboboxState, {\n          [ComboboxState.Open]: () => actions.goToOption(Focus.Next),\n          [ComboboxState.Closed]: () => actions.openCombobox(),\n        })\n\n      case Keys.ArrowUp:\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return match(data.comboboxState, {\n          [ComboboxState.Open]: () => actions.goToOption(Focus.Previous),\n          [ComboboxState.Closed]: () => {\n            actions.openCombobox()\n            d.nextFrame(() => {\n              if (!data.value) {\n                actions.goToOption(Focus.Last)\n              }\n            })\n          },\n        })\n\n      case Keys.Home:\n        if (event.shiftKey) {\n          break\n        }\n\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.First)\n\n      case Keys.PageUp:\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.First)\n\n      case Keys.End:\n        if (event.shiftKey) {\n          break\n        }\n\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.Last)\n\n      case Keys.PageDown:\n        isTyping.current = false\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.Last)\n\n      case Keys.Escape:\n        isTyping.current = false\n        if (data.comboboxState !== ComboboxState.Open) return\n        event.preventDefault()\n        if (data.optionsRef.current && !data.optionsPropsRef.current.static) {\n          event.stopPropagation()\n        }\n\n        if (data.nullable && data.mode === ValueMode.Single) {\n          // We want to clear the value when the user presses escape if and only if the current\n          // value is not set (aka, they didn't select anything yet, or they cleared the input which\n          // caused the value to be set to `null`). If the current value is set, then we want to\n          // fallback to that value when we press escape (this part is handled in the watcher that\n          // syncs the value with the input field again).\n          if (data.value === null) {\n            clear()\n          }\n        }\n\n        return actions.closeCombobox()\n\n      case Keys.Tab:\n        isTyping.current = false\n        if (data.comboboxState !== ComboboxState.Open) return\n        if (data.mode === ValueMode.Single && data.activationTrigger !== ActivationTrigger.Focus) {\n          actions.selectActiveOption()\n        }\n        actions.closeCombobox()\n        break\n    }\n  })\n\n  let handleChange = useEvent((event: React.ChangeEvent<HTMLInputElement>) => {\n    // Always call the onChange listener even if the user is still typing using an IME (Input Method\n    // Editor).\n    //\n    // The main issue is Android, where typing always uses the IME APIs. Just waiting until the\n    // compositionend event is fired to trigger an onChange is not enough, because then filtering\n    // options while typing won't work at all because we are still in \"composing\" mode.\n    onChange?.(event)\n\n    // When the value becomes empty in a single value mode while being nullable then we want to clear\n    // the option entirely.\n    //\n    // This is can happen when you press backspace, but also when you select all the text and press\n    // ctrl/cmd+x.\n    if (data.nullable && data.mode === ValueMode.Single) {\n      if (event.target.value === '') {\n        clear()\n      }\n    }\n\n    // Open the combobox to show the results based on what the user has typed\n    actions.openCombobox()\n  })\n\n  let handleBlur = useEvent((event: ReactFocusEvent) => {\n    let relatedTarget =\n      (event.relatedTarget as HTMLElement) ?? history.find((x) => x !== event.currentTarget)\n    isTyping.current = false\n\n    // Focus is moved into the list, we don't want to close yet.\n    if (data.optionsRef.current?.contains(relatedTarget)) {\n      return\n    }\n\n    if (data.buttonRef.current?.contains(relatedTarget)) {\n      return\n    }\n\n    if (data.comboboxState !== ComboboxState.Open) return\n    event.preventDefault()\n\n    if (data.mode === ValueMode.Single) {\n      // We want to clear the value when the user presses escape if and only if the current\n      // value is not set (aka, they didn't select anything yet, or they cleared the input which\n      // caused the value to be set to `null`). If the current value is set, then we want to\n      // fallback to that value when we press escape (this part is handled in the watcher that\n      // syncs the value with the input field again).\n      if (data.nullable && data.value === null) {\n        clear()\n      }\n\n      // We do have a value, so let's select the active option, unless we were just going through\n      // the form and we opened it due to the focus event.\n      else if (data.activationTrigger !== ActivationTrigger.Focus) {\n        actions.selectActiveOption()\n      }\n    }\n\n    return actions.closeCombobox()\n  })\n\n  let handleFocus = useEvent((event: ReactFocusEvent) => {\n    let relatedTarget =\n      (event.relatedTarget as HTMLElement) ?? history.find((x) => x !== event.currentTarget)\n    if (data.buttonRef.current?.contains(relatedTarget)) return\n    if (data.optionsRef.current?.contains(relatedTarget)) return\n    if (data.disabled) return\n\n    if (!data.immediate) return\n    if (data.comboboxState === ComboboxState.Open) return\n\n    actions.openCombobox()\n\n    // We need to make sure that tabbing through a form doesn't result in incorrectly setting the\n    // value of the combobox. We will set the activation trigger to `Focus`, and we will ignore\n    // selecting the active option when the user tabs away.\n    d.nextFrame(() => {\n      actions.setActivationTrigger(ActivationTrigger.Focus)\n    })\n  })\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({\n    isTextInput: true,\n    autoFocus: props.autoFocus ?? false,\n  })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: data.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.comboboxState === ComboboxState.Open,\n        disabled: data.disabled,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies InputRenderPropArg,\n    [data, hover, focus, props.autoFocus]\n  )\n\n  let ourProps = mergeProps(\n    {\n      ref: inputRef,\n      id,\n      role: 'combobox',\n      type,\n      'aria-controls': data.optionsRef.current?.id,\n      'aria-expanded': data.comboboxState === ComboboxState.Open,\n      'aria-activedescendant':\n        data.activeOptionIndex === null\n          ? undefined\n          : data.virtual\n            ? data.options.find(\n                (option) =>\n                  !data.virtual?.disabled(option.dataRef.current.value) &&\n                  data.compare(\n                    option.dataRef.current.value,\n                    data.virtual!.options[data.activeOptionIndex!]\n                  )\n              )?.id\n            : data.options[data.activeOptionIndex]?.id,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      'aria-autocomplete': 'list',\n      defaultValue:\n        props.defaultValue ??\n        (data.defaultValue !== undefined\n          ? displayValue?.(data.defaultValue as unknown as TType)\n          : null) ??\n        data.defaultValue,\n      disabled: data.disabled,\n      onCompositionStart: handleCompositionStart,\n      onCompositionEnd: handleCompositionEnd,\n      onKeyDown: handleKeyDown,\n      onChange: handleChange,\n      onFocus: handleFocus,\n      onBlur: handleBlur,\n    },\n    focusProps,\n    hoverProps\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_INPUT_TAG,\n    name: 'Combobox.Input',\n  })\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ntype ButtonRenderPropArg = {\n  open: boolean\n  active: boolean\n  disabled: boolean\n  value: any\n  focus: boolean\n  hover: boolean\n}\ntype ButtonPropsWeControl =\n  | 'aria-controls'\n  | 'aria-expanded'\n  | 'aria-haspopup'\n  | 'aria-labelledby'\n  | 'disabled'\n  | 'tabIndex'\n\nexport type ComboboxButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    autoFocus?: boolean\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: ComboboxButtonProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let data = useData('Combobox.Button')\n  let actions = useActions('Combobox.Button')\n  let buttonRef = useSyncRefs(data.buttonRef, ref)\n  let internalId = useId()\n  let { id = `headlessui-combobox-button-${internalId}`, ...theirProps } = props\n  let d = useDisposables()\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLUListElement>) => {\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menu/#keyboard-interaction-12\n\n      case Keys.ArrowDown:\n        event.preventDefault()\n        event.stopPropagation()\n        if (data.comboboxState === ComboboxState.Closed) {\n          actions.openCombobox()\n        }\n\n        return d.nextFrame(() => data.inputRef.current?.focus({ preventScroll: true }))\n\n      case Keys.ArrowUp:\n        event.preventDefault()\n        event.stopPropagation()\n        if (data.comboboxState === ComboboxState.Closed) {\n          actions.openCombobox()\n          d.nextFrame(() => {\n            if (!data.value) {\n              actions.goToOption(Focus.Last)\n            }\n          })\n        }\n        return d.nextFrame(() => data.inputRef.current?.focus({ preventScroll: true }))\n\n      case Keys.Escape:\n        if (data.comboboxState !== ComboboxState.Open) return\n        event.preventDefault()\n        if (data.optionsRef.current && !data.optionsPropsRef.current.static) {\n          event.stopPropagation()\n        }\n        actions.closeCombobox()\n        return d.nextFrame(() => data.inputRef.current?.focus({ preventScroll: true }))\n\n      default:\n        return\n    }\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent<HTMLButtonElement>) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    if (data.comboboxState === ComboboxState.Open) {\n      actions.closeCombobox()\n    } else {\n      event.preventDefault()\n      actions.openCombobox()\n    }\n\n    d.nextFrame(() => data.inputRef.current?.focus({ preventScroll: true }))\n  })\n\n  let labelledBy = useLabelledBy([id])\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({\n    isTextInput: true,\n    autoFocus: props.autoFocus ?? false,\n  })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: data.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: data.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.comboboxState === ComboboxState.Open,\n        active: active || data.comboboxState === ComboboxState.Open,\n        disabled: data.disabled,\n        value: data.value,\n        hover,\n        focus,\n      }) satisfies ButtonRenderPropArg,\n    [data, hover, focus, active]\n  )\n  let ourProps = mergeProps(\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, data.buttonRef),\n      tabIndex: -1,\n      'aria-haspopup': 'listbox',\n      'aria-controls': data.optionsRef.current?.id,\n      'aria-expanded': data.comboboxState === ComboboxState.Open,\n      'aria-labelledby': labelledBy,\n      disabled: data.disabled,\n      onClick: handleClick,\n      onKeyDown: handleKeyDown,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Combobox.Button',\n  })\n}\n\n// ---\n\nlet DEFAULT_OPTIONS_TAG = 'ul' as const\ntype OptionsRenderPropArg = {\n  open: boolean\n  option: unknown\n}\ntype OptionsPropsWeControl = 'aria-labelledby' | 'aria-multiselectable' | 'role' | 'tabIndex'\n\nlet OptionsRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type ComboboxOptionsProps<TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG> = Props<\n  TTag,\n  OptionsRenderPropArg,\n  OptionsPropsWeControl,\n  PropsForFeatures<typeof OptionsRenderFeatures> & {\n    hold?: boolean\n    anchor?: AnchorProps\n  }\n>\n\nfunction OptionsFn<TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG>(\n  props: ComboboxOptionsProps<TTag>,\n  ref: Ref<HTMLUListElement>\n) {\n  let internalId = useId()\n  let {\n    id = `headlessui-combobox-options-${internalId}`,\n    hold = false,\n    anchor,\n    ...theirProps\n  } = props\n  let data = useData('Combobox.Options')\n\n  let [floatingRef, style] = useFloatingPanel(anchor)\n  let getFloatingPanelProps = useFloatingPanelProps()\n  let optionsRef = useSyncRefs(data.optionsRef, ref, anchor ? floatingRef : null)\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return data.comboboxState === ComboboxState.Open\n  })()\n\n  useIsoMorphicEffect(() => {\n    data.optionsPropsRef.current.static = props.static ?? false\n  }, [data.optionsPropsRef, props.static])\n  useIsoMorphicEffect(() => {\n    data.optionsPropsRef.current.hold = hold\n  }, [data.optionsPropsRef, hold])\n\n  useTreeWalker({\n    container: data.optionsRef.current,\n    enabled: data.comboboxState === ComboboxState.Open,\n    accept(node) {\n      if (node.getAttribute('role') === 'option') return NodeFilter.FILTER_REJECT\n      if (node.hasAttribute('role')) return NodeFilter.FILTER_SKIP\n      return NodeFilter.FILTER_ACCEPT\n    },\n    walk(node) {\n      node.setAttribute('role', 'none')\n    },\n  })\n\n  let labelledBy = useLabelledBy([data.buttonRef.current?.id])\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.comboboxState === ComboboxState.Open,\n        option: undefined,\n      }) satisfies OptionsRenderPropArg,\n    [data]\n  )\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    'aria-labelledby': labelledBy,\n    role: 'listbox',\n    'aria-multiselectable': data.mode === ValueMode.Multi ? true : undefined,\n    id,\n    ref: optionsRef,\n    ...(style ? { style } : {}),\n  })\n\n  // Map the children in a scrollable container when virtualization is enabled\n  if (data.virtual && data.comboboxState === ComboboxState.Open) {\n    Object.assign(theirProps, {\n      // @ts-expect-error The `children` prop now is a callback function that receives `{ option }`.\n      children: <VirtualProvider>{theirProps.children}</VirtualProvider>,\n    })\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG,\n    features: OptionsRenderFeatures,\n    visible,\n    name: 'Combobox.Options',\n  })\n}\n\n// ---\n\nlet DEFAULT_OPTION_TAG = 'li' as const\ntype OptionRenderPropArg = {\n  focus: boolean\n  /** @deprecated use `focus` instead */\n  active: boolean\n  selected: boolean\n  disabled: boolean\n}\ntype OptionPropsWeControl = 'role' | 'tabIndex' | 'aria-disabled' | 'aria-selected'\n\nexport type ComboboxOptionProps<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  TType = string,\n> = Props<\n  TTag,\n  OptionRenderPropArg,\n  OptionPropsWeControl,\n  {\n    disabled?: boolean\n    value: TType\n    order?: number\n  }\n>\n\nfunction OptionFn<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  // TODO: One day we will be able to infer this type from the generic in Combobox itself.\n  // But today is not that day..\n  TType = Parameters<typeof ComboboxRoot>[0]['value'],\n>(props: ComboboxOptionProps<TTag, TType>, ref: Ref<HTMLLIElement>) {\n  let internalId = useId()\n  let {\n    id = `headlessui-combobox-option-${internalId}`,\n    disabled = false,\n    value,\n    order = null,\n    ...theirProps\n  } = props\n\n  let data = useData('Combobox.Option')\n  let actions = useActions('Combobox.Option')\n\n  let active = data.virtual\n    ? data.activeOptionIndex === data.calculateIndex(value)\n    : data.activeOptionIndex === null\n      ? false\n      : data.options[data.activeOptionIndex]?.id === id\n\n  let selected = data.isSelected(value)\n  let internalOptionRef = useRef<HTMLLIElement | null>(null)\n\n  let bag = useLatestValue<ComboboxOptionDataRef<TType>['current']>({\n    disabled,\n    value,\n    domRef: internalOptionRef,\n    order,\n  })\n\n  let virtualizer = useContext(VirtualContext)\n  let optionRef = useSyncRefs(\n    ref,\n    internalOptionRef,\n    virtualizer ? virtualizer.measureElement : null\n  )\n\n  let select = useEvent(() => actions.onChange(value))\n  useIsoMorphicEffect(() => actions.registerOption(id, bag), [bag, id])\n\n  let enableScrollIntoView = useRef(data.virtual || data.__demoMode ? false : true)\n  useIsoMorphicEffect(() => {\n    if (!data.virtual) return\n    if (!data.__demoMode) return\n    let d = disposables()\n    d.requestAnimationFrame(() => {\n      enableScrollIntoView.current = true\n    })\n    return d.dispose\n  }, [data.virtual, data.__demoMode])\n\n  useIsoMorphicEffect(() => {\n    if (!enableScrollIntoView.current) return\n    if (data.comboboxState !== ComboboxState.Open) return\n    if (!active) return\n    if (data.activationTrigger === ActivationTrigger.Pointer) return\n    let d = disposables()\n    d.requestAnimationFrame(() => {\n      internalOptionRef.current?.scrollIntoView?.({ block: 'nearest' })\n    })\n    return d.dispose\n  }, [\n    internalOptionRef,\n    active,\n    data.comboboxState,\n    data.activationTrigger,\n    /* We also want to trigger this when the position of the active item changes so that we can re-trigger the scrollIntoView */ data.activeOptionIndex,\n  ])\n\n  let handleClick = useEvent((event: { preventDefault: Function }) => {\n    if (disabled || data.virtual?.disabled(value)) return event.preventDefault()\n    select()\n\n    // We want to make sure that we don't accidentally trigger the virtual keyboard.\n    //\n    // This would happen if the input is focused, the options are open, you select an option (which\n    // would blur the input, and focus the option (button), then we re-focus the input).\n    //\n    // This would be annoying on mobile (or on devices with a virtual keyboard). Right now we are\n    // assuming that the virtual keyboard would open on mobile devices (iOS / Android). This\n    // assumption is not perfect, but will work in the majority of the cases.\n    //\n    // Ideally we can have a better check where we can explicitly check for the virtual keyboard.\n    // But right now this is still an experimental feature:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/virtualKeyboard\n    if (!isMobile()) {\n      requestAnimationFrame(() => data.inputRef.current?.focus({ preventScroll: true }))\n    }\n\n    if (data.mode === ValueMode.Single) {\n      requestAnimationFrame(() => actions.closeCombobox())\n    }\n  })\n\n  let handleFocus = useEvent(() => {\n    if (disabled || data.virtual?.disabled(value)) {\n      return actions.goToOption(Focus.Nothing)\n    }\n    let idx = data.calculateIndex(value)\n    actions.goToOption(Focus.Specific, idx)\n  })\n\n  let pointer = useTrackedPointer()\n\n  let handleEnter = useEvent((evt) => pointer.update(evt))\n\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled || data.virtual?.disabled(value)) return\n    if (active) return\n    let idx = data.calculateIndex(value)\n    actions.goToOption(Focus.Specific, idx, ActivationTrigger.Pointer)\n  })\n\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled || data.virtual?.disabled(value)) return\n    if (!active) return\n    if (data.optionsPropsRef.current.hold) return\n    actions.goToOption(Focus.Nothing)\n  })\n\n  let slot = useMemo(\n    () => ({ active, focus: active, selected, disabled }) satisfies OptionRenderPropArg,\n    [active, selected, disabled]\n  )\n\n  let ourProps = {\n    id,\n    ref: optionRef,\n    role: 'option',\n    tabIndex: disabled === true ? undefined : -1,\n    'aria-disabled': disabled === true ? true : undefined,\n    // According to the WAI-ARIA best practices, we should use aria-checked for\n    // multi-select,but Voice-Over disagrees. So we use aria-checked instead for\n    // both single and multi-select.\n    'aria-selected': selected,\n    disabled: undefined, // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerEnter: handleEnter,\n    onMouseEnter: handleEnter,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave,\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG,\n    name: 'Combobox.Option',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentCombobox extends HasDisplayName {\n  <TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n    props: ComboboxProps<TValue, true, true, TTag> & RefProp<typeof ComboboxFn>\n  ): JSX.Element\n  <TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n    props: ComboboxProps<TValue, true, false, TTag> & RefProp<typeof ComboboxFn>\n  ): JSX.Element\n  <TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n    props: ComboboxProps<TValue, false, true, TTag> & RefProp<typeof ComboboxFn>\n  ): JSX.Element\n  <TValue, TTag extends ElementType = typeof DEFAULT_COMBOBOX_TAG>(\n    props: ComboboxProps<TValue, false, false, TTag> & RefProp<typeof ComboboxFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentComboboxButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: ComboboxButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentComboboxInput extends HasDisplayName {\n  <TType, TTag extends ElementType = typeof DEFAULT_INPUT_TAG>(\n    props: ComboboxInputProps<TTag, TType> & RefProp<typeof InputFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentComboboxLabel extends _internal_ComponentLabel {}\n\nexport interface _internal_ComponentComboboxOptions extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG>(\n    props: ComboboxOptionsProps<TTag> & RefProp<typeof OptionsFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentComboboxOption extends HasDisplayName {\n  <\n    TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n    TType = Parameters<typeof ComboboxRoot>[0]['value'],\n  >(\n    props: ComboboxOptionProps<TTag, TType> & RefProp<typeof OptionFn>\n  ): JSX.Element\n}\n\nlet ComboboxRoot = forwardRefWithAs(ComboboxFn) as unknown as _internal_ComponentCombobox\nexport let ComboboxButton = forwardRefWithAs(\n  ButtonFn\n) as unknown as _internal_ComponentComboboxButton\nexport let ComboboxInput = forwardRefWithAs(InputFn) as unknown as _internal_ComponentComboboxInput\n/** @deprecated use `<Label>` instead of `<ComboboxLabel>` */\nexport let ComboboxLabel = Label as _internal_ComponentComboboxLabel\nexport let ComboboxOptions = forwardRefWithAs(\n  OptionsFn\n) as unknown as _internal_ComponentComboboxOptions\nexport let ComboboxOption = forwardRefWithAs(\n  OptionFn\n) as unknown as _internal_ComponentComboboxOption\n\nexport let Combobox = Object.assign(ComboboxRoot, {\n  Input: ComboboxInput,\n  Button: ComboboxButton,\n  /** @deprecated use `<Label>` instead of `<Combobox.Label>` */\n  Label: ComboboxLabel,\n  Options: ComboboxOptions,\n  Option: ComboboxOption,\n})\n", "import { useCallback } from 'react'\n\nexport type ByComparator<T> =\n  | (T extends null ? string : keyof T & string)\n  | ((a: T, z: T) => boolean)\n\nfunction defaultBy<T>(a: T, z: T) {\n  if (\n    a !== null &&\n    z !== null &&\n    typeof a === 'object' &&\n    typeof z === 'object' &&\n    'id' in a &&\n    'id' in z\n  ) {\n    return a.id === z.id\n  }\n\n  return a === z\n}\n\nexport function useByComparator<T>(by: ByComparator<T> = defaultBy) {\n  return useCallback(\n    (a: T, z: T) => {\n      if (typeof by === 'string') {\n        let property = by as unknown as keyof T\n        return a?.[property] === z?.[property]\n      }\n\n      return by(a, z)\n    },\n    [by]\n  )\n}\n", "import { useEffect, useRef, type MutableRefObject } from 'react'\nimport { FocusableMode, isFocusableElement } from '../utils/focus-management'\nimport { isMobile } from '../utils/platform'\nimport { useDocumentEvent } from './use-document-event'\nimport { useWindowEvent } from './use-window-event'\n\ntype Container = MutableRefObject<HTMLElement | null> | HTMLElement | null\ntype ContainerCollection = Container[] | Set<Container>\ntype ContainerInput = Container | ContainerCollection\n\nexport function useOutsideClick(\n  containers: ContainerInput | (() => ContainerInput),\n  cb: (event: MouseEvent | PointerEvent | FocusEvent | TouchEvent, target: HTMLElement) => void,\n  enabled: boolean = true\n) {\n  // TODO: remove this once the React bug has been fixed: https://github.com/facebook/react/issues/24657\n  let enabledRef = useRef(false)\n  useEffect(\n    process.env.NODE_ENV === 'test'\n      ? () => {\n          enabledRef.current = enabled\n        }\n      : () => {\n          requestAnimationFrame(() => {\n            enabledRef.current = enabled\n          })\n        },\n    [enabled]\n  )\n\n  function handleOutsideClick<E extends MouseEvent | PointerEvent | FocusEvent | TouchEvent>(\n    event: E,\n    resolveTarget: (event: E) => HTMLElement | null\n  ) {\n    if (!enabledRef.current) return\n\n    // Check whether the event got prevented already. This can happen if you use the\n    // useOutsideClick hook in both a Dialog and a Menu and the inner Menu \"cancels\" the default\n    // behaviour so that only the Menu closes and not the Dialog (yet)\n    if (event.defaultPrevented) return\n\n    let target = resolveTarget(event)\n\n    if (target === null) {\n      return\n    }\n\n    // Ignore if the target doesn't exist in the DOM anymore\n    if (!target.getRootNode().contains(target)) return\n\n    // Ignore if the target was removed from the DOM by the time the handler was called\n    if (!target.isConnected) return\n\n    let _containers = (function resolve(containers): ContainerCollection {\n      if (typeof containers === 'function') {\n        return resolve(containers())\n      }\n\n      if (Array.isArray(containers)) {\n        return containers\n      }\n\n      if (containers instanceof Set) {\n        return containers\n      }\n\n      return [containers]\n    })(containers)\n\n    // Ignore if the target exists in one of the containers\n    for (let container of _containers) {\n      if (container === null) continue\n      let domNode = container instanceof HTMLElement ? container : container.current\n      if (domNode?.contains(target)) {\n        return\n      }\n\n      // If the click crossed a shadow boundary, we need to check if the container\n      // is inside the tree by using `composedPath` to \"pierce\" the shadow boundary\n      if (event.composed && event.composedPath().includes(domNode as EventTarget)) {\n        return\n      }\n    }\n\n    // This allows us to check whether the event was defaultPrevented when you are nesting this\n    // inside a `<Dialog />` for example.\n    if (\n      // This check alllows us to know whether or not we clicked on a \"focusable\" element like a\n      // button or an input. This is a backwards compatibility check so that you can open a <Menu\n      // /> and click on another <Menu /> which should close Menu A and open Menu B. We might\n      // revisit that so that you will require 2 clicks instead.\n      !isFocusableElement(target, FocusableMode.Loose) &&\n      // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it\n      // unfocusable via the keyboard so that tabbing to the next item from the input doesn't\n      // first go to the button.\n      target.tabIndex !== -1\n    ) {\n      event.preventDefault()\n    }\n\n    return cb(event, target)\n  }\n\n  let initialClickTarget = useRef<EventTarget | null>(null)\n\n  useDocumentEvent(\n    'pointerdown',\n    (event) => {\n      if (enabledRef.current) {\n        initialClickTarget.current = event.composedPath?.()?.[0] || event.target\n      }\n    },\n    true\n  )\n\n  useDocumentEvent(\n    'mousedown',\n    (event) => {\n      if (enabledRef.current) {\n        initialClickTarget.current = event.composedPath?.()?.[0] || event.target\n      }\n    },\n    true\n  )\n\n  useDocumentEvent(\n    'click',\n    (event) => {\n      if (isMobile()) {\n        return\n      }\n\n      if (!initialClickTarget.current) {\n        return\n      }\n\n      handleOutsideClick(event, () => {\n        return initialClickTarget.current as HTMLElement\n      })\n\n      initialClickTarget.current = null\n    },\n\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    true\n  )\n\n  useDocumentEvent(\n    'touchend',\n    (event) => {\n      return handleOutsideClick(event, () => {\n        if (event.target instanceof HTMLElement) {\n          return event.target\n        }\n        return null\n      })\n    },\n\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    true\n  )\n\n  // When content inside an iframe is clicked `window` will receive a blur event\n  // This can happen when an iframe _inside_ a window is clicked\n  // Or, if headless UI is *in* the iframe, when a content in a window containing that iframe is clicked\n\n  // In this case we care only about the first case so we check to see if the active element is the iframe\n  // If so this was because of a click, focus, or other interaction with the child iframe\n  // and we can consider it an \"outside click\"\n  useWindowEvent(\n    'blur',\n    (event) => {\n      return handleOutsideClick(event, () => {\n        return window.document.activeElement instanceof HTMLIFrameElement\n          ? window.document.activeElement\n          : null\n      })\n    },\n    true\n  )\n}\n", "import type { MutableRefObject } from 'react'\nimport { disposables } from './disposables'\nimport { match } from './match'\nimport { getOwnerDocument } from './owner'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        (selector) => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : (selector) => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nlet autoFocusableSelector = [\n  // In a perfect world this was just `autofocus`, but React doesn't pass `autofocus` to the DOM...\n  '[data-autofocus]',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        (selector) => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : (selector) => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n\n  /** Focus the first focusable element with the `data-autofocus` attribute. */\n  AutoFocus = 1 << 6,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector)).sort(\n    // We want to move `tabIndex={0}` to the end of the list, this is what the browser does as well.\n    (a, z) =>\n      Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER))\n  )\n}\n\nexport function getAutoFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(autoFocusableSelector)).sort(\n    // We want to move `tabIndex={0}` to the end of the list, this is what the browser does as well.\n    (a, z) =>\n      Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER))\n  )\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === getOwnerDocument(element)?.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function restoreFocusIfNecessary(element: HTMLElement | null) {\n  let ownerDocument = getOwnerDocument(element)\n  disposables().nextFrame(() => {\n    if (\n      ownerDocument &&\n      !isFocusableElement(ownerDocument.activeElement as HTMLElement, FocusableMode.Strict)\n    ) {\n      focusElement(element)\n    }\n  })\n}\n\n// The method of triggering an action, this is used to determine how we should\n// restore focus after an action has been performed.\nenum ActivationMethod {\n  /* If the action was triggered by a keyboard event. */\n  Keyboard = 0,\n\n  /* If the action was triggered by a mouse / pointer / ... event.*/\n  Mouse = 1,\n}\n\n// We want to be able to set and remove the `data-headlessui-mouse` attribute on the `html` element.\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  document.addEventListener(\n    'keydown',\n    (event) => {\n      if (event.metaKey || event.altKey || event.ctrlKey) {\n        return\n      }\n\n      document.documentElement.dataset.headlessuiFocusVisible = ''\n    },\n    true\n  )\n\n  document.addEventListener(\n    'click',\n    (event) => {\n      // Event originated from an actual mouse click\n      if (event.detail === ActivationMethod.Mouse) {\n        delete document.documentElement.dataset.headlessuiFocusVisible\n      }\n\n      // Event originated from a keyboard event that triggered the `click` event\n      else if (event.detail === ActivationMethod.Keyboard) {\n        document.documentElement.dataset.headlessuiFocusVisible = ''\n      }\n    },\n    true\n  )\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select\nlet selectableSelector = ['textarea', 'input'].join(',')\nfunction isSelectableElement(\n  element: Element | null\n): element is HTMLInputElement | HTMLTextAreaElement {\n  return element?.matches?.(selectableSelector) ?? false\n}\n\nexport function sortByDomNode<T>(\n  nodes: T[],\n  resolveKey: (item: T) => HTMLElement | null = (i) => i as unknown as HTMLElement | null\n): T[] {\n  return nodes.slice().sort((aItem, zItem) => {\n    let a = resolveKey(aItem)\n    let z = resolveKey(zItem)\n\n    if (a === null || z === null) return 0\n\n    let position = a.compareDocumentPosition(z)\n\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1\n    return 0\n  })\n}\n\nexport function focusFrom(current: HTMLElement | null, focus: Focus) {\n  return focusIn(getFocusableElements(), focus, { relativeTo: current })\n}\n\nexport function focusIn(\n  container: HTMLElement | HTMLElement[],\n  focus: Focus,\n  {\n    sorted = true,\n    relativeTo = null,\n    skipElements = [],\n  }: Partial<{\n    sorted: boolean\n    relativeTo: HTMLElement | null\n    skipElements: (HTMLElement | MutableRefObject<HTMLElement | null>)[]\n  }> = {}\n) {\n  let ownerDocument = Array.isArray(container)\n    ? container.length > 0\n      ? container[0].ownerDocument\n      : document\n    : container.ownerDocument\n\n  let elements = Array.isArray(container)\n    ? sorted\n      ? sortByDomNode(container)\n      : container\n    : focus & Focus.AutoFocus\n      ? getAutoFocusableElements(container)\n      : getFocusableElements(container)\n\n  if (skipElements.length > 0 && elements.length > 1) {\n    elements = elements.filter(\n      (element) =>\n        !skipElements.some(\n          (skipElement) =>\n            skipElement != null && 'current' in skipElement\n              ? skipElement?.current === element // Handle MutableRefObject\n              : skipElement === element // Handle HTMLElement directly\n        )\n    )\n  }\n\n  relativeTo = relativeTo ?? (ownerDocument.activeElement as HTMLElement)\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(relativeTo)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(relativeTo)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== ownerDocument.activeElement)\n\n  // By default if you <Tab> to a text input or a textarea, the browser will\n  // select all the text once the focus is inside these DOM Nodes. However,\n  // since we are manually moving focus this behaviour is not happening. This\n  // code will make sure that the text gets selected as-if you did it manually.\n  // Note: We only do this when going forward / backward. Not for the\n  // Focus.First or Focus.Last actions. This is similar to the `autoFocus`\n  // behaviour on an input where the input will get focus but won't be\n  // selected.\n  if (focus & (Focus.Next | Focus.Previous) && isSelectableElement(next)) {\n    next.select()\n  }\n\n  return FocusResult.Success\n}\n", "// This file contains functions to detect the platform the app is running on. They aren't perfect,\n// and we are making assumptions here. But it's the best we can do for now.\n\nexport function isIOS() {\n  // TODO: This is not a great way to detect iOS, but it's the best I can do for now.\n  // - `window.platform` is deprecated\n  // - `window.userAgentData.platform` is still experimental (https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/platform)\n  // - `window.userAgent` also doesn't contain the required information\n  return (\n    // Check if it is an iPhone\n    /iPhone/gi.test(window.navigator.platform) ||\n    // Check if it is an iPad. iPad reports itself as \"MacIntel\", but we can check if it is a touch\n    // screen. Let's hope that Apple doesn't release a touch screen Mac (or maybe this would then\n    // work as expected \uD83E\uDD14).\n    (/Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0)\n  )\n}\n\nexport function isAndroid() {\n  return /Android/gi.test(window.navigator.userAgent)\n}\n\nexport function isMobile() {\n  return isIOS() || isAndroid()\n}\n", "import { useEffect } from 'react'\nimport { useLatestValue } from './use-latest-value'\n\nexport function useDocumentEvent<TType extends keyof DocumentEventMap>(\n  type: TType,\n  listener: (ev: DocumentEventMap[TType]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let listenerRef = useLatestValue(listener)\n\n  useEffect(() => {\n    function handler(event: DocumentEventMap[TType]) {\n      listenerRef.current(event)\n    }\n\n    document.addEventListener(type, handler, options)\n    return () => document.removeEventListener(type, handler, options)\n  }, [type, options])\n}\n", "import { useEffect } from 'react'\nimport { useLatestValue } from './use-latest-value'\n\nexport function useWindowEvent<TType extends keyof WindowEventMap>(\n  type: TType,\n  listener: (ev: WindowEventMap[TType]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let listenerRef = useLatestValue(listener)\n\n  useEffect(() => {\n    function handler(event: WindowEventMap[TType]) {\n      listenerRef.current(event)\n    }\n\n    window.addEventListener(type, handler, options)\n    return () => window.removeEventListener(type, handler, options)\n  }, [type, options])\n}\n", "import { useMemo } from 'react'\nimport { getOwnerDocument } from '../utils/owner'\n\nexport function useOwnerDocument(...args: Parameters<typeof getOwnerDocument>) {\n  return useMemo(() => getOwnerDocument(...args), [...args])\n}\n", "import { useState, type MutableRefObject } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nfunction resolveType<TTag>(props: { type?: string; as?: TTag }) {\n  if (props.type) return props.type\n\n  let tag = props.as ?? 'button'\n  if (typeof tag === 'string' && tag.toLowerCase() === 'button') return 'button'\n\n  return undefined\n}\n\nexport function useResolveButtonType<TTag>(\n  props: { type?: string; as?: TTag },\n  ref: MutableRefObject<HTMLElement | null>\n) {\n  let [type, setType] = useState(() => resolveType(props))\n\n  useIsoMorphicEffect(() => {\n    setType(resolveType(props))\n  }, [props.type, props.as])\n\n  useIsoMorphicEffect(() => {\n    if (type) return\n    if (!ref.current) return\n\n    if (ref.current instanceof HTMLButtonElement && !ref.current.hasAttribute('type')) {\n      setType('button')\n    }\n  }, [type, ref])\n\n  return type\n}\n", "import { useRef } from 'react'\n\ntype PointerPosition = [x: number, y: number]\n\nfunction eventToPosition(evt: PointerEvent): PointerPosition {\n  return [evt.screenX, evt.screenY]\n}\n\nexport function useTrackedPointer() {\n  let lastPos = useRef<PointerPosition>([-1, -1])\n\n  return {\n    wasMoved(evt: PointerEvent) {\n      // FIXME: Remove this once we use browser testing in all the relevant places.\n      // NOTE: This is replaced with a compile-time define during the build process\n      // This hack exists to work around a few failing tests caused by our inability to \"move\" the virtual pointer in JSDOM pointer events.\n      if (process.env.TEST_BYPASS_TRACKED_POINTER) {\n        return true\n      }\n\n      let newPos = eventToPosition(evt)\n\n      if (lastPos.current[0] === newPos[0] && lastPos.current[1] === newPos[1]) {\n        return false\n      }\n\n      lastPos.current = newPos\n      return true\n    },\n\n    update(evt: PointerEvent) {\n      lastPos.current = eventToPosition(evt)\n    },\n  }\n}\n", "import { useEffect, useRef } from 'react'\nimport { getOwnerDocument } from '../utils/owner'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\ntype AcceptNode = (\n  node: HTMLElement\n) =>\n  | typeof NodeFilter.FILTER_ACCEPT\n  | typeof NodeFilter.FILTER_SKIP\n  | typeof NodeFilter.FILTER_REJECT\n\nexport function useTreeWalker({\n  container,\n  accept,\n  walk,\n  enabled = true,\n}: {\n  container: HTMLElement | null\n  accept: AcceptNode\n  walk(node: HTMLElement): void\n  enabled?: boolean\n}) {\n  let acceptRef = useRef(accept)\n  let walkRef = useRef(walk)\n\n  useEffect(() => {\n    acceptRef.current = accept\n    walkRef.current = walk\n  }, [accept, walk])\n\n  useIsoMorphicEffect(() => {\n    if (!container) return\n    if (!enabled) return\n    let ownerDocument = getOwnerDocument(container)\n    if (!ownerDocument) return\n\n    let accept = acceptRef.current\n    let walk = walkRef.current\n\n    let acceptNode = Object.assign((node: HTMLElement) => accept(node), { acceptNode: accept })\n    let walker = ownerDocument.createTreeWalker(\n      container,\n      NodeFilter.SHOW_ELEMENT,\n      acceptNode,\n      // @ts-expect-error This `false` is a simple small fix for older browsers\n      false\n    )\n\n    while (walker.nextNode()) walk(walker.currentNode as HTMLElement)\n  }, [container, enabled, acceptRef, walkRef])\n}\n", "import { useEffect, useRef } from 'react'\nimport { useEvent } from './use-event'\n\nexport function useWatch<T extends any[]>(\n  cb: (newValues: [...T], oldValues: [...T]) => void | (() => void),\n  dependencies: [...T]\n) {\n  let track = useRef<typeof dependencies>([] as unknown as [...T])\n  let action = useEvent(cb)\n\n  useEffect(() => {\n    let oldValues = [...track.current] as unknown as [...T]\n\n    for (let [idx, value] of dependencies.entries()) {\n      if (track.current[idx] !== value) {\n        // At least 1 item changed\n        let returnValue = action(dependencies, oldValues)\n        track.current = dependencies\n        return returnValue\n      }\n    }\n  }, [action, ...dependencies])\n}\n", "import * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { stopEvent, getDocument, isMouseLikePointerType, contains, activeElement, isSafari, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, getTarget, getPlatform, isTypeableElement, isReactEvent, isRootElement, isEventTargetWithin, isMac, getUserAgent } from '@floating-ui/react/utils';\nimport { floor } from '@floating-ui/utils';\nimport { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/React.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = React.useState(() => new Map());\n  const register = React.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = React.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(FloatingListContext.Provider, {\n    value: React.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = React.useState(null);\n  const componentRef = React.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = React.useContext(FloatingListContext);\n  const ref = React.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return React.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  } else if (render) {\n    return /*#__PURE__*/React.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/React.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/React.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\nconst Composite = /*#__PURE__*/React.forwardRef(function Composite(_ref, forwardedRef) {\n  let {\n    render,\n    orientation = 'both',\n    loop = true,\n    cols = 1,\n    disabledIndices,\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    ...props\n  } = _ref;\n  const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = React.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = React.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const prevIndex = activeIndex;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      nextIndex = getGridNavigatedIndex(elementsRef, {\n        event,\n        orientation,\n        loop,\n        cols,\n        disabledIndices,\n        minIndex,\n        maxIndex,\n        prevIndex\n      });\n    }\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = {\n    ...props,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      props.onKeyDown == null || props.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/React.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\nconst CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n  let {\n    render,\n    ...props\n  } = _ref2;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = React.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...props,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      props.onFocus == null || props.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), strokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the floating tree, returning its id.\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      } else {\n        unset();\n      }\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = getDocument(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const data = React.useMemo(() => ({\n    id,\n    root,\n    portalContext,\n    uniqueId\n  }), [id, root, portalContext, uniqueId]);\n  const dataRef = React.useRef();\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n    };\n  }, [portalNode, data]);\n  index(() => {\n    if (dataRef.current === data) return;\n    dataRef.current = data;\n    const {\n      id,\n      root,\n      portalContext,\n      uniqueId\n    } = data;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    const attr = createAttribute('portal');\n    if (existingIdRoot) {\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      existingIdRoot.appendChild(subRoot);\n      setPortalNode(subRoot);\n    } else {\n      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n      if (container && !isElement(container)) container = container.current;\n      container = container || document.body;\n      let idWrapper = null;\n      if (id) {\n        idWrapper = document.createElement('div');\n        idWrapper.id = id;\n        container.appendChild(idWrapper);\n      }\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      container = idWrapper || container;\n      container.appendChild(subRoot);\n      setPortalNode(subRoot);\n    }\n  }, [data]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element \u2014 by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  if (element && getNodeName(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, refs, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = activeElement(doc);\n      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored \u2014 leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst activeLocks = /*#__PURE__*/new Set();\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  const didKeyDownRef = React.useRef(false);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested \u2014 by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const endedOrStartedInsideRef = React.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = getDocument(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = isElement(target) ? target : null;\n    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n      const nextParent = getParentNode(targetRootAncestor);\n      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n        break;\n      } else {\n        targetRootAncestor = nextParent;\n      }\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && isElement(target) && !isRootElement(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !contains(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\nlet devMessageSet;\nif (process.env.NODE_ENV !== \"production\") {\n  devMessageSet = /*#__PURE__*/new Set();\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements2;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  if (process.env.NODE_ENV !== \"production\") {\n    var _options$elements;\n    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';\n    if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {\n      var _devMessageSet;\n      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n        console.error(err);\n      }\n    }\n  }\n  const [_domReference, setDomReference] = React.useState(null);\n  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      floating,\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  const keyboardModalityRef = React.useRef(true);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = getWindow(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [floating, domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if (isVirtualPointerEvent(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = getTarget(event.nativeEvent);\n          if (visibleOnly && isElement(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if (isSafari() && isMac()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !isTypeableElement(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = activeElement(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\n\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const [virtualId, setVirtualId] = React.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = activeElement(getDocument(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if (isHTMLElement(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        indexRef.current = getGridNavigatedIndex(listRef, {\n          event,\n          orientation,\n          loop,\n          cols,\n          disabledIndices,\n          minIndex,\n          maxIndex,\n          prevIndex: indexRef.current,\n          stopEvent: true\n        });\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  stopEvent(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  stopEvent(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(!isTypeableCombobox(domReference) && ariaActiveDescendantProp),\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined,\n        ...(ariaRole === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(ariaRole === 'menu' && {\n          id: referenceId\n        }),\n        ...(ariaRole === 'menu' && isNested && {\n          role: 'menuitem'\n        }),\n        ...(role === 'select' && {\n          'aria-autocomplete': 'none'\n        }),\n        ...(role === 'combobox' && {\n          'aria-autocomplete': 'list'\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(ariaRole === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      },\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = {\n          role: 'option',\n          ...(active && {\n            id: floatingId + \"-option\"\n          })\n        };\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return {\n              ...commonProps,\n              'aria-selected': active && selected\n            };\n          case 'combobox':\n            {\n              return {\n                ...commonProps,\n                ...(active && {\n                  'aria-selected': true\n                })\n              };\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    } else {\n      setInitiated(true);\n      setStatus('close');\n    }\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      } else if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nexport { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { isShadowRoot, isHTMLElement } from '@floating-ui/utils/dom';\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return !isAndroid() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333\u2022 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n\nexport { TYPEABLE_SELECTOR, activeElement, contains, getDocument, getPlatform, getTarget, getUserAgent, isAndroid, isEventTargetWithin, isMac, isMouseLikePointerType, isReactEvent, isRootElement, isSafari, isTypeableCombobox, isTypeableElement, isVirtualClick, isVirtualPointerEvent, stopEvent };\n", "const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n", "import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length, i, keys;\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node != referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, [_setReference]);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, [_setFloating]);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      } else {\n        update();\n      }\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\nexport { arrow, useFloating };\n", "import {\n  autoUpdate,\n  flip as flipMiddleware,\n  inner as innerMiddleware,\n  offset as offsetMiddleware,\n  shift as shiftMiddleware,\n  size as sizeMiddleware,\n  useFloating,\n  useInnerOffset,\n  useInteractions,\n  type InnerProps,\n  type UseFloatingReturn,\n} from '@floating-ui/react'\nimport * as React from 'react'\nimport { createContext, useCallback, useContext, useMemo, useRef, useState } from 'react'\nimport { useDisposables } from '../hooks/use-disposables'\nimport { useEvent } from '../hooks/use-event'\nimport { useIsoMorphicEffect } from '../hooks/use-iso-morphic-effect'\n\ntype Align = 'start' | 'end'\ntype Placement = 'top' | 'right' | 'bottom' | 'left'\n\ntype BaseAnchorProps = {\n  /**\n   * The `gap` is the space between the trigger and the panel.\n   */\n  gap: number | string // For `var()` support\n\n  /**\n   * The `offset` is the amount the panel should be nudged from its original position.\n   */\n  offset: number | string // For `var()` support\n\n  /**\n   * The `padding` is the minimum space between the panel and the viewport.\n   */\n  padding: number | string // For `var()` support\n}\n\nexport type AnchorProps = Partial<\n  BaseAnchorProps & {\n    /**\n     * The `to` value defines which side of the trigger the panel should be placed on and its\n     * alignment.\n     */\n    to: `${Placement}` | `${Placement} ${Align}`\n  }\n>\n\nexport type AnchorPropsWithSelection = Partial<\n  BaseAnchorProps & {\n    /**\n     * The `to` value defines which side of the trigger the panel should be placed on and its\n     * alignment.\n     */\n    to: `${Placement | 'selection'}` | `${Placement | 'selection'} ${Align}`\n  }\n>\n\nexport type InternalFloatingPanelProps = Partial<{\n  inner: {\n    listRef: InnerProps['listRef']\n    index: InnerProps['index']\n  }\n}>\n\nlet FloatingContext = createContext<{\n  styles?: UseFloatingReturn<any>['floatingStyles']\n  setReference: UseFloatingReturn<any>['refs']['setReference']\n  setFloating: UseFloatingReturn<any>['refs']['setFloating']\n  getReferenceProps: ReturnType<typeof useInteractions>['getReferenceProps']\n  getFloatingProps: ReturnType<typeof useInteractions>['getFloatingProps']\n  slot: Partial<{\n    anchor: `${Placement | 'selection'}` | `${Placement | 'selection'} ${Align}`\n  }>\n}>({\n  styles: undefined,\n  setReference: () => {},\n  setFloating: () => {},\n  getReferenceProps: () => ({}),\n  getFloatingProps: () => ({}),\n  slot: {},\n})\nFloatingContext.displayName = 'FloatingContext'\nlet PlacementContext = createContext<((value: AnchorPropsWithSelection | null) => void) | null>(\n  null\n)\nPlacementContext.displayName = 'PlacementContext'\n\nexport function useFloatingReference() {\n  return useContext(FloatingContext).setReference\n}\n\nexport function useFloatingReferenceProps() {\n  return useContext(FloatingContext).getReferenceProps\n}\n\nexport function useFloatingPanelProps() {\n  let { getFloatingProps, slot } = useContext(FloatingContext)\n  return useCallback(\n    (...args: Parameters<typeof getFloatingProps>) => {\n      return Object.assign({}, getFloatingProps(...args), {\n        'data-anchor': slot.anchor,\n      })\n    },\n    [getFloatingProps, slot]\n  )\n}\n\nexport function useFloatingPanel(\n  placement?: AnchorPropsWithSelection & InternalFloatingPanelProps\n) {\n  let updatePlacementConfig = useContext(PlacementContext)\n  let stablePlacement = useMemo(\n    () => placement,\n    [\n      JSON.stringify(\n        placement,\n        typeof HTMLElement !== 'undefined'\n          ? (_, v) => {\n              if (v instanceof HTMLElement) {\n                return v.outerHTML\n              }\n              return v\n            }\n          : undefined\n      ),\n    ]\n  )\n  useIsoMorphicEffect(() => {\n    updatePlacementConfig?.(stablePlacement ?? null)\n  }, [updatePlacementConfig, stablePlacement])\n\n  let context = useContext(FloatingContext)\n\n  return useMemo(\n    () => [context.setFloating, context.styles] as const,\n    [context.setFloating, context.styles]\n  )\n}\n\n// TODO: Make this a config part of the `config`. Just need to decide on a name.\nlet MINIMUM_ITEMS_VISIBLE = 4\n\nexport function FloatingProvider({\n  children,\n  enabled = true,\n}: {\n  children: React.ReactNode\n  enabled?: boolean\n}) {\n  let [config, setConfig] = useState<\n    (AnchorPropsWithSelection & InternalFloatingPanelProps) | null\n  >(null)\n  let [innerOffset, setInnerOffset] = useState(0)\n  let overflowRef = useRef(null)\n\n  let [floatingEl, setFloatingElement] = useState<HTMLElement | null>(null)\n  useFixScrollingPixel(floatingEl)\n\n  let isEnabled = enabled && config !== null && floatingEl !== null\n\n  let {\n    to: placement = 'bottom',\n    gap = 0,\n    offset = 0,\n    padding = 0,\n    inner,\n  } = useResolvedConfig(config, floatingEl)\n  let [to, align = 'center'] = placement.split(' ') as [Placement | 'selection', Align | 'center']\n\n  // Reset\n  useIsoMorphicEffect(() => {\n    if (!isEnabled) return\n    setInnerOffset(0)\n  }, [isEnabled])\n\n  let { refs, floatingStyles, context } = useFloating({\n    open: isEnabled,\n\n    placement:\n      to === 'selection'\n        ? align === 'center'\n          ? 'bottom'\n          : `bottom-${align}`\n        : align === 'center'\n          ? `${to}`\n          : `${to}-${align}`,\n\n    // This component will be used in combination with a `Portal`, which means the floating\n    // element will be rendered outside of the current DOM tree.\n    strategy: 'fixed',\n\n    // We use the panel in a `Dialog` which is making the page inert, therefore no re-positioning is\n    // needed when scrolling changes.\n    transform: false,\n\n    middleware: [\n      // - The `mainAxis` is set to `gap` which defines the gap between the panel and the\n      //   trigger/reference.\n      // - The `crossAxis` is set to `offset` which nudges the panel from its original position.\n      //\n      // When we are showing the panel on top of the selected item, we don't want a gap between the\n      // reference and the panel, therefore setting the `mainAxis` to `0`.\n      offsetMiddleware({\n        mainAxis: to === 'selection' ? 0 : gap,\n        crossAxis: offset,\n      }),\n\n      // When the panel overflows the viewport, we will try to nudge the panel to the other side to\n      // ensure it's not clipped. We use the `padding` to define the  minimum space between the\n      // panel and the viewport.\n      shiftMiddleware({ padding }),\n\n      // The `flip` middleware will swap the `placement` of the panel if there is not enough room.\n      // This is not compatible with the `inner` middleware (which is only enabled when `to` is set\n      // to \"selection\").\n      to !== 'selection' && flipMiddleware(),\n\n      // The `inner` middleware will ensure the panel is always fully visible on screen and\n      // positioned on top of the reference and moved to the currently selected item.\n      to === 'selection' && inner\n        ? innerMiddleware({\n            ...inner,\n            padding, // For overflow detection\n            overflowRef,\n            offset: innerOffset,\n            minItemsVisible: MINIMUM_ITEMS_VISIBLE,\n            referenceOverflowThreshold: padding,\n            onFallbackChange(fallback) {\n              if (!fallback) return\n              let parent = context.elements.floating\n              if (!parent) return\n              let scrollPaddingBottom =\n                parseFloat(getComputedStyle(parent!).scrollPaddingBottom) || 0\n\n              // We want at least X visible items, but if there are less than X items in the list,\n              // we want to show as many as possible.\n              let missing = Math.min(MINIMUM_ITEMS_VISIBLE, parent.childElementCount)\n\n              let elementHeight = 0\n              let elementAmountVisible = 0\n\n              for (let child of context.elements.floating?.childNodes ?? []) {\n                if (child instanceof HTMLElement) {\n                  let childTop = child.offsetTop\n                  // It can be that the child is fully visible, but we also want to keep the scroll\n                  // padding into account to ensure the UI looks good. Therefore we fake that the\n                  // bottom of the child is actually `scrollPaddingBottom` amount of pixels lower.\n                  let childBottom = childTop + child.clientHeight + scrollPaddingBottom\n\n                  let parentTop = parent.scrollTop\n                  let parentBottom = parentTop + parent.clientHeight\n\n                  // Figure out if the child is fully visible in the scroll parent.\n                  if (childTop >= parentTop && childBottom <= parentBottom) {\n                    missing--\n                  } else {\n                    // Not fully visible, so we will use this child to calculate the height of\n                    // each item. We will also use this to calculate how much of the item is\n                    // already visible.\n                    elementAmountVisible = Math.max(\n                      0,\n                      Math.min(childBottom, parentBottom) - Math.max(childTop, parentTop)\n                    )\n                    elementHeight = child.clientHeight\n                    break\n                  }\n                }\n              }\n\n              // There are fewer visible items than we want, so we will try to nudge the offset\n              // to show more items.\n              if (missing >= 1) {\n                setInnerOffset((existingOffset) => {\n                  let newInnerOffset =\n                    elementHeight * missing - // `missing` amount of `elementHeight`\n                    elementAmountVisible + // The amount of the last item that is visible\n                    scrollPaddingBottom // The scroll padding to ensure the UI looks good\n\n                  // Nudged enough already, no need to continue\n                  if (existingOffset >= newInnerOffset) {\n                    return existingOffset\n                  }\n\n                  return newInnerOffset\n                })\n              }\n            },\n          })\n        : null,\n\n      // The `size` middleware will ensure the panel is never bigger than the viewport minus the\n      // provided `padding` that we want.\n      sizeMiddleware({\n        apply({ availableWidth, availableHeight, elements }) {\n          Object.assign(elements.floating.style, {\n            maxWidth: `${availableWidth - padding}px`,\n            maxHeight: `${availableHeight - padding}px`,\n          })\n        },\n      }),\n    ].filter(Boolean),\n    whileElementsMounted: autoUpdate,\n  })\n\n  // Calculate placement information to expose as data attributes\n  let [exposedTo = to, exposedAlign = align] = context.placement.split('-')\n  // If userland code is using custom styles specifically for `bottom`, but they chose `selection`,\n  // then we want to make sure to map it to selection again otherwise styles could be wrong.\n  if (to === 'selection') exposedTo = 'selection'\n\n  let data = useMemo(\n    () => ({\n      anchor: [exposedTo, exposedAlign].filter(Boolean).join(' ') as React.ContextType<\n        typeof FloatingContext\n      >['slot']['anchor'],\n    }),\n    [exposedTo, exposedAlign]\n  )\n\n  let innerOffsetConfig = useInnerOffset(context, {\n    overflowRef,\n    onChange: setInnerOffset,\n  })\n  let { getReferenceProps, getFloatingProps } = useInteractions([innerOffsetConfig])\n\n  let setFloatingRef = useEvent((el: HTMLElement | null) => {\n    setFloatingElement(el)\n    refs.setFloating(el)\n  })\n\n  return (\n    <PlacementContext.Provider value={setConfig}>\n      <FloatingContext.Provider\n        value={{\n          setFloating: setFloatingRef,\n          setReference: refs.setReference,\n          styles: !isEnabled ? {} : floatingStyles,\n          getReferenceProps,\n          getFloatingProps,\n          slot: data,\n        }}\n      >\n        {children}\n      </FloatingContext.Provider>\n    </PlacementContext.Provider>\n  )\n}\n\nfunction useFixScrollingPixel(element: HTMLElement | null) {\n  useIsoMorphicEffect(() => {\n    if (!element) return\n\n    let observer = new MutationObserver(() => {\n      let maxHeight = element.style.maxHeight\n      if (parseFloat(maxHeight) !== parseInt(maxHeight)) {\n        element.style.maxHeight = `${Math.ceil(parseFloat(maxHeight))}px`\n      }\n    })\n\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter: ['style'],\n    })\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [element])\n}\n\nfunction useResolvedConfig(\n  config: (AnchorPropsWithSelection & InternalFloatingPanelProps) | null,\n  element?: HTMLElement | null\n) {\n  let gap = useResolvePxValue(config?.gap, element)\n  let offset = useResolvePxValue(config?.offset, element)\n  let padding = useResolvePxValue(config?.padding, element)\n\n  return { ...config, gap, offset, padding }\n}\n\nfunction useResolvePxValue(\n  input?: string | number,\n  element?: HTMLElement | null,\n  defaultValue: number | undefined = undefined\n) {\n  let d = useDisposables()\n  let computeValue = useEvent((value?: string | number, element?: HTMLElement | null) => {\n    // Nullish\n    if (value == null) return [defaultValue, null] as const\n\n    // Number as-is\n    if (typeof value === 'number') return [value, null] as const\n\n    // String values, the interesting part\n    if (typeof value === 'string') {\n      if (!element) return [defaultValue, null] as const\n\n      let result = resolveCSSVariablePxValue(value, element)\n\n      return [\n        result,\n        (setValue: (value?: number) => void) => {\n          let variables = resolveVariables(value)\n\n          // TODO: Improve this part and make it work\n          //\n          // Observe variables themselves. Currently the browser doesn't support this, but the\n          // variables we are interested in resolve to a pixel value. Which means that we can use\n          // this variable in the `margin` of an element. Then we can observe the `margin` of the\n          // element and we will be notified when the variable changes.\n          //\n          // if (typeof ResizeObserver !== 'undefined') {\n          //   let tmpEl = document.createElement('div')\n          //   element.appendChild(tmpEl)\n          //\n          //   // Didn't use `fontSize` because a `fontSize` can't be negative.\n          //   tmpEl.style.setProperty('margin-top', '0px', 'important')\n          //\n          //   // Set the new value, if this is invalid the previous value will be used.\n          //   tmpEl.style.setProperty('margin-top', value, 'important')\n          //\n          //   let observer = new ResizeObserver(() => {\n          //     let newResult = resolveCSSVariableValue(value, element)\n          //\n          //     if (result !== newResult) {\n          //       setValue(newResult)\n          //       result = newResult\n          //     }\n          //   })\n          //   observer.observe(tmpEl)\n          //   d.add(() => observer.disconnect())\n          //   return d.dispose\n          // }\n\n          // Works as a fallback, but not very performant because we are polling the value.\n          {\n            let history = variables.map((variable) =>\n              window.getComputedStyle(element!).getPropertyValue(variable)\n            )\n\n            d.requestAnimationFrame(function check() {\n              d.nextFrame(check)\n\n              // Fast path, detect if the value of the CSS Variable has changed before completely\n              // computing the new value. Once we use `resolveCSSVariablePxValue` we will have to\n              // compute the actual px value by injecting a temporary element into the DOM.\n              //\n              // This is a lot of work, so we want to avoid it if possible.\n              let changed = false\n              for (let [idx, variable] of variables.entries()) {\n                let value = window.getComputedStyle(element!).getPropertyValue(variable)\n                if (history[idx] !== value) {\n                  history[idx] = value\n                  changed = true\n                  break\n                }\n              }\n\n              // Nothing changed, no need to perform the expensive computation.\n              if (!changed) return\n\n              let newResult = resolveCSSVariablePxValue(value, element)\n\n              if (result !== newResult) {\n                setValue(newResult)\n                result = newResult\n              }\n            })\n          }\n\n          return d.dispose\n        },\n      ] as const\n    }\n\n    return [defaultValue, null] as const\n  })\n\n  // Calculate the value immediately when the input or element changes. Later we can setup a watcher\n  // to track the value changes over time.\n  let immediateValue = useMemo(() => computeValue(input, element)[0], [input, element])\n  let [value = immediateValue, setValue] = useState<number | undefined>()\n\n  useIsoMorphicEffect(() => {\n    let [value, watcher] = computeValue(input, element)\n    setValue(value)\n\n    if (!watcher) return\n    return watcher(setValue)\n  }, [input, element])\n\n  return value\n}\n\nfunction resolveVariables(value: string): string[] {\n  let matches = /var\\((.*)\\)/.exec(value)\n  if (matches) {\n    let idx = matches[1].indexOf(',')\n    if (idx === -1) {\n      return [matches[1]]\n    }\n\n    let variable = matches[1].slice(0, idx).trim()\n    let fallback = matches[1].slice(idx + 1).trim()\n\n    if (fallback) {\n      return [variable, ...resolveVariables(fallback)]\n    }\n\n    return [variable]\n  }\n\n  return []\n}\n\nfunction resolveCSSVariablePxValue(input: string, element: HTMLElement) {\n  // Resolve the value: Instead of trying to compute the value ourselves by converting rem /\n  // vwh / ... values to pixels or by parsing out the fallback values and evaluating it\n  // (because it can contain calc expressions or other variables).\n  //\n  // We will let the browser compute all of it by creating a temporary element and setting\n  // the value as a CSS variable. Then we can read the computed value from the browser.\n  //\n  //\n  // BUG REPORT ABOUT INCORRECT VALUES, look here:\n  // ---------------------------------------------\n  //\n  // Currently this technically contains a bug because we are rendering a new element inside of the\n  // current element. Which means that if the passed in element has CSS that looks like:\n  //\n  // ```css\n  // .the-element {\n  //   --the-variable: 1rem\n  // }\n  //\n  // .the-element > * {\n  //   --the-variable: 2rem\n  // }\n  // ```\n  //\n  // Then this will result to resolved value of `2rem`, instead of `1rem`\n  let tmpEl = document.createElement('div')\n  element.appendChild(tmpEl)\n\n  // Set the value to `0px` otherwise if an invalid value is provided later the browser will read\n  // out the default value.\n  //\n  // Didn't use `fontSize` because a `fontSize` can't be negative.\n  tmpEl.style.setProperty('margin-top', '0px', 'important')\n\n  // Set the new value, if this is invalid the previous value will be used.\n  tmpEl.style.setProperty('margin-top', input, 'important')\n\n  // Reading the `margin-top` will already be in pixels (e.g.: 123px).\n  let pxValue = parseFloat(window.getComputedStyle(tmpEl).marginTop) || 0\n  element.removeChild(tmpEl)\n\n  return pxValue\n}\n", "import React, { createContext, useContext, type ReactElement, type ReactNode } from 'react'\n\nlet Context = createContext<State | null>(null)\nContext.displayName = 'OpenClosedContext'\n\nexport enum State {\n  Open = 1 << 0,\n  Closed = 1 << 1,\n  Closing = 1 << 2,\n  Opening = 1 << 3,\n}\n\nexport function useOpenClosed() {\n  return useContext(Context)\n}\n\ninterface Props {\n  value: State\n  children: ReactNode\n}\n\nexport function OpenClosedProvider({ value, children }: Props): ReactElement {\n  return <Context.Provider value={value}>{children}</Context.Provider>\n}\n", "export function onDocumentReady(cb: () => void) {\n  function check() {\n    if (document.readyState === 'loading') return\n    cb()\n    document.removeEventListener('DOMContentLoaded', check)\n  }\n\n  if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    document.addEventListener('DOMContentLoaded', check)\n    check()\n  }\n}\n", "import { onDocumentReady } from './document-ready'\n\nexport let history: HTMLElement[] = []\nonDocumentReady(() => {\n  function handle(e: Event) {\n    if (!(e.target instanceof HTMLElement)) return\n    if (e.target === document.body) return\n    if (history[0] === e.target) return\n\n    history.unshift(e.target)\n\n    // Filter out DOM Nodes that don't exist anymore\n    history = history.filter((x) => x != null && x.isConnected)\n    history.splice(10) // Only keep the 10 most recent items\n  }\n\n  window.addEventListener('click', handle, { capture: true })\n  window.addEventListener('mousedown', handle, { capture: true })\n  window.addEventListener('focus', handle, { capture: true })\n\n  document.body.addEventListener('click', handle, { capture: true })\n  document.body.addEventListener('mousedown', handle, { capture: true })\n  document.body.addEventListener('focus', handle, { capture: true })\n})\n", "function assertNever(x: never): never {\n  throw new Error('Unexpected object: ' + x)\n}\n\nexport enum Focus {\n  /** Focus the first non-disabled item. */\n  First,\n\n  /** Focus the previous non-disabled item. */\n  Previous,\n\n  /** Focus the next non-disabled item. */\n  Next,\n\n  /** Focus the last non-disabled item. */\n  Last,\n\n  /** Focus a specific item based on the `id` of the item. */\n  Specific,\n\n  /** Focus no items at all. */\n  Nothing,\n}\n\nexport function calculateActiveIndex<TItem>(\n  action: { focus: Focus.Specific; id: string } | { focus: Exclude<Focus, Focus.Specific> },\n  resolvers: {\n    resolveItems(): TItem[]\n    resolveActiveIndex(): number | null\n    resolveId(item: TItem, index: number, items: TItem[]): string\n    resolveDisabled(item: TItem, index: number, items: TItem[]): boolean\n  }\n) {\n  let items = resolvers.resolveItems()\n  if (items.length <= 0) return null\n\n  let currentActiveIndex = resolvers.resolveActiveIndex()\n  let activeIndex = currentActiveIndex ?? -1\n\n  switch (action.focus) {\n    case Focus.First: {\n      for (let i = 0; i < items.length; ++i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i\n        }\n      }\n      return currentActiveIndex\n    }\n\n    case Focus.Previous: {\n      // If nothing is active, focus the last relevant item\n      if (activeIndex === -1) activeIndex = items.length\n\n      for (let i = activeIndex - 1; i >= 0; --i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i\n        }\n      }\n      return currentActiveIndex\n    }\n\n    case Focus.Next: {\n      for (let i = activeIndex + 1; i < items.length; ++i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i\n        }\n      }\n      return currentActiveIndex\n    }\n\n    case Focus.Last: {\n      for (let i = items.length - 1; i >= 0; --i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i\n        }\n      }\n      return currentActiveIndex\n    }\n\n    case Focus.Specific: {\n      for (let i = 0; i < items.length; ++i) {\n        if (resolvers.resolveId(items[i], i, items) === action.id) {\n          return i\n        }\n      }\n      return currentActiveIndex\n    }\n\n    case Focus.Nothing:\n      return null\n\n    default:\n      assertNever(action)\n  }\n}\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { Fragment, useMemo, type ElementType, type Ref } from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport type { Props } from '../../types'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\n\nlet DEFAULT_DATA_INTERACTIVE_TAG = Fragment\n\ntype DataInteractiveRenderPropArg = {\n  hover: boolean\n  focus: boolean\n  active: boolean\n}\ntype DataInteractivePropsWeControl = never\n\nexport type DataInteractiveProps<TTag extends ElementType = typeof DEFAULT_DATA_INTERACTIVE_TAG> =\n  Props<TTag, DataInteractiveRenderPropArg, DataInteractivePropsWeControl, {}>\n\nfunction DataInteractiveFn<TTag extends ElementType = typeof DEFAULT_DATA_INTERACTIVE_TAG>(\n  props: DataInteractiveProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { ...theirProps } = props\n\n  // Ideally we can use a `disabled` prop, but that would depend on the props of the child element\n  // and we don't have access to that in this component.\n\n  let disabled = false\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing()\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled })\n  let { pressed: active, pressProps } = useActivePress({ disabled })\n\n  let ourProps = mergeProps({ ref }, focusProps, hoverProps, pressProps)\n\n  let slot = useMemo(\n    () => ({ hover, focus, active }) satisfies DataInteractiveRenderPropArg,\n    [hover, focus, active]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DATA_INTERACTIVE_TAG,\n    name: 'DataInteractive',\n  })\n}\n\nexport interface _internal_ComponentDataInteractive extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_DATA_INTERACTIVE_TAG>(\n    props: DataInteractiveProps<TTag> & RefProp<typeof DataInteractiveFn>\n  ): JSX.Element\n}\n\nexport let DataInteractive = forwardRefWithAs(\n  DataInteractiveFn\n) as unknown as _internal_ComponentDataInteractive\n", "'use client'\n\n// WAI-ARIA: https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/\nimport React, {\n  createContext,\n  createRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  type ContextType,\n  type ElementType,\n  type MutableRefObject,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n  type RefObject,\n} from 'react'\nimport { useDocumentOverflowLockedEffect } from '../../hooks/document-overflow/use-document-overflow'\nimport { useEvent } from '../../hooks/use-event'\nimport { useEventListener } from '../../hooks/use-event-listener'\nimport { useId } from '../../hooks/use-id'\nimport { useInert } from '../../hooks/use-inert'\nimport { useIsTouchDevice } from '../../hooks/use-is-touch-device'\nimport { useOutsideClick } from '../../hooks/use-outside-click'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useRootContainers } from '../../hooks/use-root-containers'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { HoistFormFields } from '../../internal/form-fields'\nimport { State, useOpenClosed } from '../../internal/open-closed'\nimport { ForcePortalRoot } from '../../internal/portal-force-root'\nimport { StackMessage, StackProvider } from '../../internal/stack-context'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { match } from '../../utils/match'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport {\n  Description,\n  useDescriptions,\n  type _internal_ComponentDescription,\n} from '../description/description'\nimport { FocusTrap, FocusTrapFeatures } from '../focus-trap/focus-trap'\nimport { Keys } from '../keyboard'\nimport { Portal, useNestedPortals } from '../portal/portal'\n\nenum DialogStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  titleId: string | null\n  panelRef: MutableRefObject<HTMLDivElement | null>\n}\n\nenum ActionTypes {\n  SetTitleId,\n}\n\ntype Actions = { type: ActionTypes.SetTitleId; id: string | null }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.SetTitleId](state, action) {\n    if (state.titleId === action.id) return state\n    return { ...state, titleId: action.id }\n  },\n}\n\nlet DialogContext = createContext<\n  | [\n      {\n        dialogState: DialogStates\n        close(): void\n        setTitleId(id: string | null): void\n      },\n      StateDefinition,\n    ]\n  | null\n>(null)\nDialogContext.displayName = 'DialogContext'\n\nfunction useDialogContext(component: string) {\n  let context = useContext(DialogContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Dialog /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDialogContext)\n    throw err\n  }\n  return context\n}\n\nfunction useScrollLock(\n  ownerDocument: Document | null,\n  enabled: boolean,\n  resolveAllowedContainers: () => HTMLElement[] = () => [document.body]\n) {\n  useDocumentOverflowLockedEffect(ownerDocument, enabled, (meta) => ({\n    containers: [...(meta.containers ?? []), resolveAllowedContainers],\n  }))\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_DIALOG_TAG = 'div' as const\ntype DialogRenderPropArg = {\n  open: boolean\n}\ntype DialogPropsWeControl = 'aria-describedby' | 'aria-labelledby' | 'aria-modal'\n\nlet DialogRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type DialogProps<TTag extends ElementType = typeof DEFAULT_DIALOG_TAG> = Props<\n  TTag,\n  DialogRenderPropArg,\n  DialogPropsWeControl,\n  PropsForFeatures<typeof DialogRenderFeatures> & {\n    open?: boolean\n    onClose(value: boolean): void\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    role?: 'dialog' | 'alertdialog'\n    autoFocus?: boolean\n    __demoMode?: boolean\n  }\n>\n\nfunction DialogFn<TTag extends ElementType = typeof DEFAULT_DIALOG_TAG>(\n  props: DialogProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let {\n    id = `headlessui-dialog-${internalId}`,\n    open,\n    onClose,\n    initialFocus,\n    role = 'dialog',\n    autoFocus = true,\n    __demoMode = false,\n    ...theirProps\n  } = props\n  let [nestedDialogCount, setNestedDialogCount] = useState(0)\n\n  let didWarnOnRole = useRef(false)\n\n  role = (function () {\n    if (role === 'dialog' || role === 'alertdialog') {\n      return role\n    }\n\n    if (!didWarnOnRole.current) {\n      didWarnOnRole.current = true\n      console.warn(\n        `Invalid role [${role}] passed to <Dialog />. Only \\`dialog\\` and and \\`alertdialog\\` are supported. Using \\`dialog\\` instead.`\n      )\n    }\n\n    return 'dialog'\n  })()\n\n  let usesOpenClosedState = useOpenClosed()\n  if (open === undefined && usesOpenClosedState !== null) {\n    // Update the `open` prop based on the open closed state\n    open = (usesOpenClosedState & State.Open) === State.Open\n  }\n\n  let internalDialogRef = useRef<HTMLDivElement | null>(null)\n  let dialogRef = useSyncRefs(internalDialogRef, ref)\n\n  let ownerDocument = useOwnerDocument(internalDialogRef)\n\n  // Validations\n  let hasOpen = props.hasOwnProperty('open') || usesOpenClosedState !== null\n  let hasOnClose = props.hasOwnProperty('onClose')\n  if (!hasOpen && !hasOnClose) {\n    throw new Error(\n      `You have to provide an \\`open\\` and an \\`onClose\\` prop to the \\`Dialog\\` component.`\n    )\n  }\n\n  if (!hasOpen) {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but forgot an \\`open\\` prop.`\n    )\n  }\n\n  if (!hasOnClose) {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but forgot an \\`onClose\\` prop.`\n    )\n  }\n\n  if (typeof open !== 'boolean') {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${open}`\n    )\n  }\n\n  if (typeof onClose !== 'function') {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${onClose}`\n    )\n  }\n\n  let dialogState = open ? DialogStates.Open : DialogStates.Closed\n\n  let [state, dispatch] = useReducer(stateReducer, {\n    titleId: null,\n    descriptionId: null,\n    panelRef: createRef(),\n  } as StateDefinition)\n\n  let close = useEvent(() => onClose(false))\n\n  let setTitleId = useEvent((id: string | null) => dispatch({ type: ActionTypes.SetTitleId, id }))\n\n  let ready = useServerHandoffComplete()\n  let enabled = ready ? (__demoMode ? false : dialogState === DialogStates.Open) : false\n  let hasNestedDialogs = nestedDialogCount > 1 // 1 is the current dialog\n  let hasParentDialog = useContext(DialogContext) !== null\n  let [portals, PortalWrapper] = useNestedPortals()\n\n  // We use this because reading these values during iniital render(s)\n  // can result in `null` rather then the actual elements\n  // This doesn't happen when using certain components like a\n  // `<Dialog.Title>` because they cause the parent to re-render\n  let defaultContainer: RefObject<HTMLElement> = {\n    get current() {\n      return state.panelRef.current ?? internalDialogRef.current\n    },\n  }\n\n  let {\n    resolveContainers: resolveRootContainers,\n    mainTreeNodeRef,\n    MainTreeNode,\n  } = useRootContainers({\n    portals,\n    defaultContainers: [defaultContainer],\n  })\n\n  // If there are multiple dialogs, then you can be the root, the leaf or one\n  // in between. We only care abou whether you are the top most one or not.\n  let position = !hasNestedDialogs ? 'leaf' : 'parent'\n\n  // When the `Dialog` is wrapped in a `Transition` (or another Headless UI component that exposes\n  // the OpenClosed state) then we get some information via context about its state. When the\n  // `Transition` is about to close, then the `State.Closing` state will be exposed. This allows us\n  // to enable/disable certain functionality in the `Dialog` upfront instead of waiting until the\n  // `Transition` is done transitioning.\n  let isClosing =\n    usesOpenClosedState !== null ? (usesOpenClosedState & State.Closing) === State.Closing : false\n\n  // Ensure other elements can't be interacted with\n  let inertOthersEnabled = (() => {\n    // Nested dialogs should not modify the `inert` property, only the root one should.\n    if (hasParentDialog) return false\n    if (isClosing) return false\n    return enabled\n  })()\n  let resolveRootOfMainTreeNode = useCallback(() => {\n    return (Array.from(ownerDocument?.querySelectorAll('body > *') ?? []).find((root) => {\n      // Skip the portal root, we don't want to make that one inert\n      if (root.id === 'headlessui-portal-root') return false\n\n      // Find the root of the main tree node\n      return root.contains(mainTreeNodeRef.current) && root instanceof HTMLElement\n    }) ?? null) as HTMLElement | null\n  }, [mainTreeNodeRef])\n  useInert(resolveRootOfMainTreeNode, inertOthersEnabled)\n\n  // This would mark the parent dialogs as inert\n  let inertParentDialogs = (() => {\n    if (hasNestedDialogs) return true\n    return enabled\n  })()\n  let resolveRootOfParentDialog = useCallback(() => {\n    return (Array.from(ownerDocument?.querySelectorAll('[data-headlessui-portal]') ?? []).find(\n      (root) => root.contains(mainTreeNodeRef.current) && root instanceof HTMLElement\n    ) ?? null) as HTMLElement | null\n  }, [mainTreeNodeRef])\n  useInert(resolveRootOfParentDialog, inertParentDialogs)\n\n  // Close Dialog on outside click\n  let outsideClickEnabled = (() => {\n    if (!enabled) return false\n    if (hasNestedDialogs) return false\n    return true\n  })()\n  useOutsideClick(resolveRootContainers, close, outsideClickEnabled)\n\n  // Handle `Escape` to close\n  let escapeToCloseEnabled = (() => {\n    if (hasNestedDialogs) return false\n    if (dialogState !== DialogStates.Open) return false\n    return true\n  })()\n  useEventListener(ownerDocument?.defaultView, 'keydown', (event) => {\n    if (!escapeToCloseEnabled) return\n    if (event.defaultPrevented) return\n    if (event.key !== Keys.Escape) return\n    event.preventDefault()\n    event.stopPropagation()\n    close()\n  })\n\n  // Scroll lock\n  let scrollLockEnabled = (() => {\n    if (isClosing) return false\n    if (dialogState !== DialogStates.Open) return false\n    if (hasParentDialog) return false\n    return true\n  })()\n  useScrollLock(ownerDocument, scrollLockEnabled, resolveRootContainers)\n\n  // Trigger close when the FocusTrap gets hidden\n  useEffect(() => {\n    if (dialogState !== DialogStates.Open) return\n    if (!internalDialogRef.current) return\n\n    let observer = new ResizeObserver((entries) => {\n      for (let entry of entries) {\n        let rect = entry.target.getBoundingClientRect()\n        if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {\n          close()\n        }\n      }\n    })\n\n    observer.observe(internalDialogRef.current)\n\n    return () => observer.disconnect()\n  }, [dialogState, internalDialogRef, close])\n\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let contextBag = useMemo<ContextType<typeof DialogContext>>(\n    () => [{ dialogState, close, setTitleId }, state],\n    [dialogState, state, close, setTitleId]\n  )\n\n  let slot = useMemo(\n    () => ({ open: dialogState === DialogStates.Open }) satisfies DialogRenderPropArg,\n    [dialogState]\n  )\n\n  let ourProps = {\n    ref: dialogRef,\n    id,\n    role,\n    tabIndex: -1,\n    'aria-modal': dialogState === DialogStates.Open ? true : undefined,\n    'aria-labelledby': state.titleId,\n    'aria-describedby': describedby,\n  }\n\n  let shouldAutoFocus = !useIsTouchDevice()\n\n  let focusTrapFeatures = enabled\n    ? match(position, {\n        parent: FocusTrapFeatures.RestoreFocus,\n        leaf: FocusTrapFeatures.All & ~FocusTrapFeatures.FocusLock,\n      })\n    : FocusTrapFeatures.None\n\n  // Enable AutoFocus feature\n  if (autoFocus) {\n    focusTrapFeatures |= FocusTrapFeatures.AutoFocus\n  }\n\n  // Remove initialFocus when we should not auto focus at all\n  if (!shouldAutoFocus) {\n    focusTrapFeatures &= ~FocusTrapFeatures.InitialFocus\n  }\n\n  return (\n    <StackProvider\n      type=\"Dialog\"\n      enabled={dialogState === DialogStates.Open}\n      element={internalDialogRef}\n      onUpdate={useEvent((message, type) => {\n        if (type !== 'Dialog') return\n\n        match(message, {\n          [StackMessage.Add]: () => setNestedDialogCount((count) => count + 1),\n          [StackMessage.Remove]: () => setNestedDialogCount((count) => count - 1),\n        })\n      })}\n    >\n      <ForcePortalRoot force={true}>\n        <Portal>\n          <DialogContext.Provider value={contextBag}>\n            <Portal.Group target={internalDialogRef}>\n              <ForcePortalRoot force={false}>\n                <DescriptionProvider slot={slot} name=\"Dialog.Description\">\n                  <PortalWrapper>\n                    <FocusTrap\n                      initialFocus={initialFocus}\n                      initialFocusFallback={internalDialogRef}\n                      containers={resolveRootContainers}\n                      features={focusTrapFeatures}\n                    >\n                      {render({\n                        ourProps,\n                        theirProps,\n                        slot,\n                        defaultTag: DEFAULT_DIALOG_TAG,\n                        features: DialogRenderFeatures,\n                        visible: dialogState === DialogStates.Open,\n                        name: 'Dialog',\n                      })}\n                    </FocusTrap>\n                  </PortalWrapper>\n                </DescriptionProvider>\n              </ForcePortalRoot>\n            </Portal.Group>\n          </DialogContext.Provider>\n        </Portal>\n      </ForcePortalRoot>\n      <HoistFormFields>\n        <MainTreeNode />\n      </HoistFormFields>\n    </StackProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ntype OverlayRenderPropArg = {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'aria-hidden'\n\nexport type DialogOverlayProps<TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG> = Props<\n  TTag,\n  OverlayRenderPropArg,\n  OverlayPropsWeControl\n>\n\nfunction OverlayFn<TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG>(\n  props: DialogOverlayProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-dialog-overlay-${internalId}`, ...theirProps } = props\n  let [{ dialogState, close }] = useDialogContext('Dialog.Overlay')\n  let overlayRef = useSyncRefs(ref)\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (event.target !== event.currentTarget) return\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    event.preventDefault()\n    event.stopPropagation()\n    close()\n  })\n\n  let slot = useMemo(\n    () => ({ open: dialogState === DialogStates.Open }) satisfies OverlayRenderPropArg,\n    [dialogState]\n  )\n\n  let ourProps = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    name: 'Dialog.Overlay',\n  })\n}\n\n// ---\n\nlet DEFAULT_BACKDROP_TAG = 'div' as const\ntype BackdropRenderPropArg = {\n  open: boolean\n}\ntype BackdropPropsWeControl = 'aria-hidden'\n\nexport type DialogBackdropProps<TTag extends ElementType = typeof DEFAULT_BACKDROP_TAG> = Props<\n  TTag,\n  BackdropRenderPropArg,\n  BackdropPropsWeControl\n>\n\nfunction BackdropFn<TTag extends ElementType = typeof DEFAULT_BACKDROP_TAG>(\n  props: DialogBackdropProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-dialog-backdrop-${internalId}`, ...theirProps } = props\n  let [{ dialogState }, state] = useDialogContext('Dialog.Backdrop')\n  let backdropRef = useSyncRefs(ref)\n\n  useEffect(() => {\n    if (state.panelRef.current === null) {\n      throw new Error(\n        `A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.`\n      )\n    }\n  }, [state.panelRef])\n\n  let slot = useMemo(\n    () => ({ open: dialogState === DialogStates.Open }) satisfies BackdropRenderPropArg,\n    [dialogState]\n  )\n\n  let ourProps = {\n    ref: backdropRef,\n    id,\n    'aria-hidden': true,\n  }\n\n  return (\n    <ForcePortalRoot force>\n      <Portal>\n        {render({\n          ourProps,\n          theirProps,\n          slot,\n          defaultTag: DEFAULT_BACKDROP_TAG,\n          name: 'Dialog.Backdrop',\n        })}\n      </Portal>\n    </ForcePortalRoot>\n  )\n}\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ntype PanelRenderPropArg = {\n  open: boolean\n}\n\nexport type DialogPanelProps<TTag extends ElementType = typeof DEFAULT_PANEL_TAG> = Props<\n  TTag,\n  PanelRenderPropArg\n>\n\nfunction PanelFn<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: DialogPanelProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-dialog-panel-${internalId}`, ...theirProps } = props\n  let [{ dialogState }, state] = useDialogContext('Dialog.Panel')\n  let panelRef = useSyncRefs(ref, state.panelRef)\n\n  let slot = useMemo(\n    () => ({ open: dialogState === DialogStates.Open }) satisfies PanelRenderPropArg,\n    [dialogState]\n  )\n\n  // Prevent the click events inside the Dialog.Panel from bubbling through the React Tree which\n  // could submit wrapping <form> elements even if we portalled the Dialog.\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    event.stopPropagation()\n  })\n\n  let ourProps = {\n    ref: panelRef,\n    id,\n    onClick: handleClick,\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG,\n    name: 'Dialog.Panel',\n  })\n}\n\n// ---\n\nlet DEFAULT_TITLE_TAG = 'h2' as const\ntype TitleRenderPropArg = {\n  open: boolean\n}\n\nexport type DialogTitleProps<TTag extends ElementType = typeof DEFAULT_TITLE_TAG> = Props<\n  TTag,\n  TitleRenderPropArg\n>\n\nfunction TitleFn<TTag extends ElementType = typeof DEFAULT_TITLE_TAG>(\n  props: DialogTitleProps<TTag>,\n  ref: Ref<HTMLHeadingElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-dialog-title-${internalId}`, ...theirProps } = props\n  let [{ dialogState, setTitleId }] = useDialogContext('Dialog.Title')\n\n  let titleRef = useSyncRefs(ref)\n\n  useEffect(() => {\n    setTitleId(id)\n    return () => setTitleId(null)\n  }, [id, setTitleId])\n\n  let slot = useMemo(\n    () => ({ open: dialogState === DialogStates.Open }) satisfies TitleRenderPropArg,\n    [dialogState]\n  )\n\n  let ourProps = { ref: titleRef, id }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TITLE_TAG,\n    name: 'Dialog.Title',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentDialog extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_DIALOG_TAG>(\n    props: DialogProps<TTag> & RefProp<typeof DialogFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDialogBackdrop extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BACKDROP_TAG>(\n    props: DialogBackdropProps<TTag> & RefProp<typeof BackdropFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDialogPanel extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n    props: DialogPanelProps<TTag> & RefProp<typeof PanelFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDialogOverlay extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG>(\n    props: DialogOverlayProps<TTag> & RefProp<typeof OverlayFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDialogTitle extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TITLE_TAG>(\n    props: DialogTitleProps<TTag> & RefProp<typeof TitleFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDialogDescription extends _internal_ComponentDescription {}\n\nlet DialogRoot = forwardRefWithAs(DialogFn) as unknown as _internal_ComponentDialog\nexport let DialogBackdrop = forwardRefWithAs(\n  BackdropFn\n) as unknown as _internal_ComponentDialogBackdrop\nexport let DialogPanel = forwardRefWithAs(PanelFn) as unknown as _internal_ComponentDialogPanel\nexport let DialogOverlay = forwardRefWithAs(\n  OverlayFn\n) as unknown as _internal_ComponentDialogOverlay\nexport let DialogTitle = forwardRefWithAs(TitleFn) as unknown as _internal_ComponentDialogTitle\n/** @deprecated use `<Description>` instead of `<DialogDescription>` */\nexport let DialogDescription = Description as _internal_ComponentDialogDescription\n\nexport let Dialog = Object.assign(DialogRoot, {\n  Backdrop: DialogBackdrop,\n  Panel: DialogPanel,\n  Overlay: DialogOverlay,\n  Title: DialogTitle,\n  /** @deprecated use `<Description>` instead of `<Dialog.Description>` */\n  Description: Description as _internal_ComponentDialogDescription,\n})\n", "// This was taken from the ESM / CJS compatible version found in Remix Router:\n// https://github.com/remix-run/react-router/tree/43cc1aacd8b132507618a4a1dd7de3674cd7bcf4/packages/react-router/lib/use-sync-external-store-shim\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react'\nimport { useSyncExternalStore as client } from './useSyncExternalStoreShimClient'\nimport { useSyncExternalStore as server } from './useSyncExternalStoreShimServer'\n\nconst canUseDOM: boolean = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\nconst isServerEnvironment = !canUseDOM\nconst shim = isServerEnvironment ? server : client\n\ntype UseSyncExternalStoreFn = <T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  getServerSnapshot?: () => T\n) => T\n\n// @ts-ignore\nexport const useSyncExternalStore: UseSyncExternalStoreFn =\n  'useSyncExternalStore' in React ? ((r) => r.useSyncExternalStore)(React) : shim\n", "// @ts-nocheck\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from 'react'\n\n// Make typescript happy\ndeclare var __DEV__: boolean\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction isPolyfill(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare\n  )\n}\n\nconst is: (x: any, y: any) => boolean = typeof Object.is === 'function' ? Object.is : isPolyfill\n\n// Intentionally not using named imports because Rollup uses dynamic\n// dispatch for CommonJS interop named imports.\nconst { useState, useEffect, useLayoutEffect, useDebugValue } = React\n\nlet didWarnOld18Alpha = false\nlet didWarnUncachedGetSnapshot = false\n\n// Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\nexport function useSyncExternalStore<T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  getServerSnapshot?: () => T\n): T {\n  if (__DEV__) {\n    if (!didWarnOld18Alpha) {\n      if ('startTransition' in React) {\n        didWarnOld18Alpha = true\n        console.error(\n          'You are using an outdated, pre-release alpha of React 18 that ' +\n            'does not support useSyncExternalStore. The ' +\n            'use-sync-external-store shim will not work correctly. Upgrade ' +\n            'to a newer pre-release.'\n        )\n      }\n    }\n  }\n\n  // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n  const value = getSnapshot()\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedValue = getSnapshot()\n      if (!is(value, cachedValue)) {\n        console.error('The result of getSnapshot should be cached to avoid an infinite loop')\n        didWarnUncachedGetSnapshot = true\n      }\n    }\n  }\n\n  // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n  const [{ inst }, forceUpdate] = useState({ inst: { value, getSnapshot } })\n\n  // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n  useLayoutEffect(() => {\n    inst.value = value\n    inst.getSnapshot = getSnapshot\n\n    // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst })\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe, value, getSnapshot])\n\n  useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({ inst })\n    }\n    const handleStoreChange = () => {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst })\n      }\n    }\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe])\n\n  useDebugValue(value)\n  return value\n}\n\nfunction checkIfSnapshotChanged(inst: any) {\n  const latestGetSnapshot = inst.getSnapshot\n  const prevValue = inst.value\n  try {\n    const nextValue = latestGetSnapshot()\n    return !is(prevValue, nextValue)\n  } catch (error) {\n    return true\n  }\n}\n", "// @ts-nocheck\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport function useSyncExternalStore<T>(\n  subscribe: (fn: () => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T\n): T {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot()\n}\n", "import { useSyncExternalStore } from '../use-sync-external-store-shim/index'\nimport type { Store } from '../utils/store'\n\nexport function useStore<T>(store: Store<T, any>) {\n  return useSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot)\n}\n", "type ChangeFn = () => void\ntype UnsubscribeFn = () => void\ntype ActionFn<T> = (this: T, ...args: any[]) => T | void\ntype StoreActions<Key extends string, T> = Record<Key, ActionFn<T>>\n\nexport interface Store<T, ActionKey extends string> {\n  getSnapshot(): T\n  subscribe(onChange: ChangeFn): UnsubscribeFn\n  dispatch(action: ActionKey, ...args: any[]): void\n}\n\nexport function createStore<T, ActionKey extends string>(\n  initial: () => T,\n  actions: StoreActions<ActionKey, T>\n): Store<T, ActionKey> {\n  let state: T = initial()\n\n  let listeners = new Set<ChangeFn>()\n\n  return {\n    getSnapshot() {\n      return state\n    },\n\n    subscribe(onChange) {\n      listeners.add(onChange)\n\n      return () => listeners.delete(onChange)\n    },\n\n    dispatch(key: ActionKey, ...args: any[]) {\n      let newState = actions[key].call(state, ...args)\n      if (newState) {\n        state = newState\n        listeners.forEach((listener) => listener())\n      }\n    },\n  }\n}\n", "import type { ScrollLockStep } from './overflow-store'\n\nexport function adjustScrollbarPadding(): ScrollLockStep {\n  let scrollbarWidthBefore: number\n\n  return {\n    before({ doc }) {\n      let documentElement = doc.documentElement\n      let ownerWindow = doc.defaultView ?? window\n\n      scrollbarWidthBefore = Math.max(0, ownerWindow.innerWidth - documentElement.clientWidth)\n    },\n\n    after({ doc, d }) {\n      let documentElement = doc.documentElement\n\n      // Account for the change in scrollbar width\n      // NOTE: This is a bit of a hack, but it's the only way to do this\n      let scrollbarWidthAfter = Math.max(\n        0,\n        documentElement.clientWidth - documentElement.offsetWidth\n      )\n      let scrollbarWidth = Math.max(0, scrollbarWidthBefore - scrollbarWidthAfter)\n\n      d.style(documentElement, 'paddingRight', `${scrollbarWidth}px`)\n    },\n  }\n}\n", "import { disposables } from '../../utils/disposables'\nimport { isIOS } from '../../utils/platform'\nimport type { ScrollLockStep } from './overflow-store'\n\ninterface ContainerMetadata {\n  containers: (() => HTMLElement[])[]\n}\n\nexport function handleIOSLocking(): ScrollLockStep<ContainerMetadata> {\n  if (!isIOS()) {\n    return {}\n  }\n\n  return {\n    before({ doc, d, meta }) {\n      function inAllowedContainer(el: HTMLElement) {\n        return meta.containers\n          .flatMap((resolve) => resolve())\n          .some((container) => container.contains(el))\n      }\n\n      d.microTask(() => {\n        // We need to be able to offset the body with the current scroll position. However, if you\n        // have `scroll-behavior: smooth` set, then changing the scrollTop in any way shape or form\n        // will trigger a \"smooth\" scroll and the new position would be incorrect.\n        //\n        // This is why we are forcing the `scroll-behaviour: auto` here, and then restoring it later.\n        // We have to be a bit careful, because removing `scroll-behavior: auto` back to\n        // `scroll-behavior: smooth` can start triggering smooth scrolling. Delaying this by a\n        // microTask will guarantee that everything is done such that both enter/exit of the Dialog is\n        // not using smooth scrolling.\n        if (window.getComputedStyle(doc.documentElement).scrollBehavior !== 'auto') {\n          let _d = disposables()\n          _d.style(doc.documentElement, 'scrollBehavior', 'auto')\n          d.add(() => d.microTask(() => _d.dispose()))\n        }\n\n        // Keep track of the current scroll position so that we can restore the scroll position if\n        // it has changed in the meantime.\n        let scrollPosition = window.scrollY ?? window.pageYOffset\n\n        // Relatively hacky, but if you click a link like `<a href=\"#foo\">` in the Dialog, and there\n        // exists an element on the page (outside of the Dialog) with that id, then the browser will\n        // scroll to that position. However, this is not the case if the element we want to scroll to\n        // is higher and the browser needs to scroll up, but it doesn't do that.\n        //\n        // Let's try and capture that element and store it, so that we can later scroll to it once the\n        // Dialog closes.\n        let scrollToElement: HTMLElement | null = null\n        d.addEventListener(\n          doc,\n          'click',\n          (e) => {\n            if (!(e.target instanceof HTMLElement)) {\n              return\n            }\n\n            try {\n              let anchor = e.target.closest('a')\n              if (!anchor) return\n              let { hash } = new URL(anchor.href)\n              let el = doc.querySelector(hash)\n              if (el && !inAllowedContainer(el as HTMLElement)) {\n                scrollToElement = el as HTMLElement\n              }\n            } catch (err) {}\n          },\n          true\n        )\n\n        // Rely on overscrollBehavior to prevent scrolling outside of the Dialog.\n        d.addEventListener(doc, 'touchstart', (e) => {\n          if (e.target instanceof HTMLElement) {\n            if (inAllowedContainer(e.target as HTMLElement)) {\n              // Find the root of the allowed containers\n              let rootContainer = e.target\n              while (\n                rootContainer.parentElement &&\n                inAllowedContainer(rootContainer.parentElement)\n              ) {\n                rootContainer = rootContainer.parentElement!\n              }\n\n              d.style(rootContainer, 'overscrollBehavior', 'contain')\n            } else {\n              d.style(e.target, 'touchAction', 'none')\n            }\n          }\n        })\n\n        d.addEventListener(\n          doc,\n          'touchmove',\n          (e) => {\n            // Check if we are scrolling inside any of the allowed containers, if not let's cancel the event!\n            if (e.target instanceof HTMLElement) {\n              if (inAllowedContainer(e.target as HTMLElement)) {\n                // Even if we are in an allowed container, on iOS the main page can still scroll, we\n                // have to make sure that we `event.preventDefault()` this event to prevent that.\n                //\n                // However, if we happen to scroll on an element that is overflowing, or any of its\n                // parents are overflowing, then we should not call `event.preventDefault()` because\n                // otherwise we are preventing the user from scrolling inside that container which\n                // is not what we want.\n                let scrollableParent = e.target\n                while (\n                  scrollableParent.parentElement &&\n                  // Assumption: We are always used in a Headless UI Portal. Once we reach the\n                  // portal itself, we can stop crawling up the tree.\n                  scrollableParent.dataset.headlessuiPortal !== ''\n                ) {\n                  // Check if the scrollable container is overflowing or not.\n                  //\n                  // NOTE: we could check the `overflow`, `overflow-y` and `overflow-x` properties\n                  // but when there is no overflow happening then the `overscrollBehavior` doesn't\n                  // seem to work and the main page will still scroll. So instead we check if the\n                  // scrollable container is overflowing or not and use that heuristic instead.\n                  if (\n                    scrollableParent.scrollHeight > scrollableParent.clientHeight ||\n                    scrollableParent.scrollWidth > scrollableParent.clientWidth\n                  ) {\n                    break\n                  }\n\n                  scrollableParent = scrollableParent.parentElement\n                }\n\n                // We crawled up the tree until the beginnging of the Portal, let's prevent the\n                // event if this is the case. If not, then we are in a container where we are\n                // allowed to scroll so we don't have to prevent the event.\n                if (scrollableParent.dataset.headlessuiPortal === '') {\n                  e.preventDefault()\n                }\n              }\n\n              // We are not in an allowed container, so let's prevent the event.\n              else {\n                e.preventDefault()\n              }\n            }\n          },\n          { passive: false }\n        )\n\n        // Restore scroll position if a scrollToElement was captured.\n        d.add(() => {\n          let newScrollPosition = window.scrollY ?? window.pageYOffset\n\n          // If the scroll position changed, then we can restore it to the previous value. This will\n          // happen if you focus an input field and the browser scrolls for you.\n          if (scrollPosition !== newScrollPosition) {\n            window.scrollTo(0, scrollPosition)\n          }\n\n          // If we captured an element that should be scrolled to, then we can try to do that if the\n          // element is still connected (aka, still in the DOM).\n          if (scrollToElement && scrollToElement.isConnected) {\n            scrollToElement.scrollIntoView({ block: 'nearest' })\n            scrollToElement = null\n          }\n        })\n      })\n    },\n  }\n}\n", "import type { ScrollLockStep } from './overflow-store'\n\nexport function preventScroll(): ScrollLockStep {\n  return {\n    before({ doc, d }) {\n      d.style(doc.documentElement, 'overflow', 'hidden')\n    },\n  }\n}\n", "import { disposables, type Disposables } from '../../utils/disposables'\nimport { createStore } from '../../utils/store'\nimport { adjustScrollbarPadding } from './adjust-scrollbar-padding'\nimport { handleIOSLocking } from './handle-ios-locking'\nimport { preventScroll } from './prevent-scroll'\n\ninterface DocEntry {\n  doc: Document\n  count: number\n  d: Disposables\n  meta: Set<MetaFn>\n}\n\nfunction buildMeta(fns: Iterable<MetaFn>) {\n  let tmp = {}\n  for (let fn of fns) {\n    Object.assign(tmp, fn(tmp))\n  }\n  return tmp\n}\n\nexport type MetaFn = (meta: Record<string, any>) => Record<string, any>\n\nexport interface Context<MetaType extends Record<string, any> = any> {\n  doc: Document\n  d: Disposables\n  meta: MetaType\n}\n\nexport interface ScrollLockStep<MetaType extends Record<string, any> = any> {\n  before?(ctx: Context<MetaType>): void\n  after?(ctx: Context<MetaType>): void\n}\n\nexport let overflows = createStore(() => new Map<Document, DocEntry>(), {\n  PUSH(doc: Document, meta: MetaFn) {\n    let entry = this.get(doc) ?? {\n      doc,\n      count: 0,\n      d: disposables(),\n      meta: new Set(),\n    }\n\n    entry.count++\n    entry.meta.add(meta)\n    this.set(doc, entry)\n\n    return this\n  },\n\n  POP(doc: Document, meta: MetaFn) {\n    let entry = this.get(doc)\n    if (entry) {\n      entry.count--\n      entry.meta.delete(meta)\n    }\n\n    return this\n  },\n\n  SCROLL_PREVENT({ doc, d, meta }: DocEntry) {\n    let ctx = {\n      doc,\n      d,\n      meta: buildMeta(meta),\n    }\n\n    let steps: ScrollLockStep<any>[] = [\n      handleIOSLocking(),\n      adjustScrollbarPadding(),\n      preventScroll(),\n    ]\n\n    // Run all `before` actions together\n    steps.forEach(({ before }) => before?.(ctx))\n\n    // Run all `after` actions together\n    steps.forEach(({ after }) => after?.(ctx))\n  },\n\n  SCROLL_ALLOW({ d }: DocEntry) {\n    d.dispose()\n  },\n\n  TEARDOWN({ doc }: DocEntry) {\n    this.delete(doc)\n  },\n})\n\n// Update the document overflow state when the store changes\n// This MUST happen outside of react for this to work properly.\noverflows.subscribe(() => {\n  let docs = overflows.getSnapshot()\n\n  let styles = new Map<Document, string | undefined>()\n\n  // Read data from all the documents\n  for (let [doc] of docs) {\n    styles.set(doc, doc.documentElement.style.overflow)\n  }\n\n  // Write data to all the documents\n  for (let entry of docs.values()) {\n    let isHidden = styles.get(entry.doc) === 'hidden'\n    let isLocked = entry.count !== 0\n    let willChange = (isLocked && !isHidden) || (!isLocked && isHidden)\n\n    if (willChange) {\n      overflows.dispatch(entry.count > 0 ? 'SCROLL_PREVENT' : 'SCROLL_ALLOW', entry)\n    }\n\n    // We have to clean up after ourselves so we don't leak memory\n    // Using a WeakMap would be ideal, but it's not iterable\n    if (entry.count === 0) {\n      overflows.dispatch('TEARDOWN', entry)\n    }\n  }\n})\n", "import { useStore } from '../../hooks/use-store'\nimport { useIsoMorphicEffect } from '../use-iso-morphic-effect'\nimport { overflows } from './overflow-store'\n\nexport function useDocumentOverflowLockedEffect(\n  doc: Document | null,\n  shouldBeLocked: boolean,\n  meta: (meta: Record<string, any>) => Record<string, any> = () => ({ containers: [] })\n) {\n  let store = useStore(overflows)\n  let entry = doc ? store.get(doc) : undefined\n  let locked = entry ? entry.count > 0 : false\n\n  useIsoMorphicEffect(() => {\n    if (!doc || !shouldBeLocked) {\n      return\n    }\n\n    // Prevent the document from scrolling\n    overflows.dispatch('PUSH', doc, meta)\n\n    // Allow document to scroll\n    return () => overflows.dispatch('POP', doc, meta)\n  }, [shouldBeLocked, doc])\n\n  return locked\n}\n", "import { useEffect } from 'react'\nimport { useLatestValue } from './use-latest-value'\n\nexport function useEventListener<TType extends keyof WindowEventMap>(\n  element: HTMLElement | Document | Window | EventTarget | null | undefined,\n  type: TType,\n  listener: (event: WindowEventMap[TType]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let listenerRef = useLatestValue(listener)\n\n  useEffect(() => {\n    element = element ?? window\n\n    function handler(event: WindowEventMap[TType]) {\n      listenerRef.current(event)\n    }\n\n    element.addEventListener(type, handler as any, options)\n    return () => element!.removeEventListener(type, handler as any, options)\n  }, [element, type, options])\n}\n", "import type { MutableRefObject } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nlet originals = new Map<HTMLElement, { 'aria-hidden': string | null; inert: boolean }>()\nlet counts = new Map<HTMLElement, number>()\n\nexport function useInert<TElement extends HTMLElement>(\n  node: MutableRefObject<TElement | null> | (() => TElement | null),\n  enabled = true\n) {\n  useIsoMorphicEffect(() => {\n    if (!enabled) return\n\n    let element = typeof node === 'function' ? node() : node.current\n    if (!element) return\n\n    function cleanup() {\n      if (!element) return // Should never happen\n\n      // Decrease counts\n      let count = counts.get(element) ?? 1 // Should always exist\n      if (count === 1) counts.delete(element) // We are the last one, so we can delete the count\n      else counts.set(element, count - 1) // We are not the last one\n\n      // Not the last one, so we don't restore the original values (yet)\n      if (count !== 1) return\n\n      let original = originals.get(element)\n      if (!original) return // Should never happen\n\n      // Restore original values\n      if (original['aria-hidden'] === null) element.removeAttribute('aria-hidden')\n      else element.setAttribute('aria-hidden', original['aria-hidden'])\n      element.inert = original.inert\n\n      // Remove tracking of original values\n      originals.delete(element)\n    }\n\n    // Increase count\n    let count = counts.get(element) ?? 0\n    counts.set(element, count + 1)\n\n    // Already marked as inert, no need to do it again\n    if (count !== 0) return cleanup\n\n    // Keep track of previous values, so that we can restore them when we are done\n    originals.set(element, {\n      'aria-hidden': element.getAttribute('aria-hidden'),\n      inert: element.inert,\n    })\n\n    // Mark as inert\n    element.setAttribute('aria-hidden', 'true')\n    element.inert = true\n\n    return cleanup\n  }, [node, enabled])\n}\n", "import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nexport function useIsTouchDevice() {\n  let [mq] = useState(() =>\n    typeof window !== 'undefined' && typeof window.matchMedia === 'function'\n      ? window.matchMedia('(pointer: coarse)')\n      : null\n  )\n  let [isTouchDevice, setIsTouchDevice] = useState(mq?.matches ?? false)\n\n  useIsoMorphicEffect(() => {\n    if (!mq) return\n\n    function handle(event: MediaQueryListEvent) {\n      setIsTouchDevice(event.matches)\n    }\n\n    mq.addEventListener('change', handle)\n    return () => mq!.removeEventListener('change', handle)\n  }, [mq])\n\n  return isTouchDevice\n}\n", "import React, { useMemo, useRef, type MutableRefObject } from 'react'\nimport { Hidden, HiddenFeatures } from '../internal/hidden'\nimport { useEvent } from './use-event'\nimport { useOwnerDocument } from './use-owner'\n\nexport function useRootContainers({\n  defaultContainers = [],\n  portals,\n  mainTreeNodeRef: _mainTreeNodeRef,\n}: {\n  defaultContainers?: (HTMLElement | null | MutableRefObject<HTMLElement | null>)[]\n  portals?: MutableRefObject<HTMLElement[]>\n  mainTreeNodeRef?: MutableRefObject<HTMLElement | null>\n} = {}) {\n  // Reference to a node in the \"main\" tree, not in the portalled Dialog tree.\n  let mainTreeNodeRef = useRef<HTMLElement | null>(_mainTreeNodeRef?.current ?? null)\n  let ownerDocument = useOwnerDocument(mainTreeNodeRef)\n\n  let resolveContainers = useEvent(() => {\n    let containers: HTMLElement[] = []\n\n    // Resolve default containers\n    for (let container of defaultContainers) {\n      if (container === null) continue\n      if (container instanceof HTMLElement) {\n        containers.push(container)\n      } else if ('current' in container && container.current instanceof HTMLElement) {\n        containers.push(container.current)\n      }\n    }\n\n    // Resolve portal containers\n    if (portals?.current) {\n      for (let portal of portals.current) {\n        containers.push(portal)\n      }\n    }\n\n    // Resolve third party (root) containers\n    for (let container of ownerDocument?.querySelectorAll('html > *, body > *') ?? []) {\n      if (container === document.body) continue // Skip `<body>`\n      if (container === document.head) continue // Skip `<head>`\n      if (!(container instanceof HTMLElement)) continue // Skip non-HTMLElements\n      if (container.id === 'headlessui-portal-root') continue // Skip the Headless UI portal root\n      if (container.contains(mainTreeNodeRef.current)) continue // Skip if it is the main app\n      if (container.contains((mainTreeNodeRef.current?.getRootNode() as ShadowRoot)?.host)) continue // Skip if it is the main app (and the component is inside a shadow root)\n      if (containers.some((defaultContainer) => container.contains(defaultContainer))) continue // Skip if the current container is part of a container we've already seen (e.g.: default container / portal)\n\n      containers.push(container)\n    }\n\n    return containers\n  })\n\n  return {\n    resolveContainers,\n    contains: useEvent((element: HTMLElement) =>\n      resolveContainers().some((container) => container.contains(element))\n    ),\n    mainTreeNodeRef,\n    MainTreeNode: useMemo(() => {\n      return function MainTreeNode() {\n        if (_mainTreeNodeRef != null) return null\n        return <Hidden features={HiddenFeatures.Hidden} ref={mainTreeNodeRef} />\n      }\n    }, [mainTreeNodeRef, _mainTreeNodeRef]),\n  }\n}\n\nexport function useMainTreeNode() {\n  let mainTreeNodeRef = useRef<HTMLElement | null>(null)\n\n  return {\n    mainTreeNodeRef,\n    MainTreeNode: useMemo(() => {\n      return function MainTreeNode() {\n        return <Hidden features={HiddenFeatures.Hidden} ref={mainTreeNodeRef} />\n      }\n    }, [mainTreeNodeRef]),\n  }\n}\n", "import React, { createContext, useContext, type ReactNode } from 'react'\n\nlet ForcePortalRootContext = createContext(false)\n\nexport function usePortalRoot() {\n  return useContext(ForcePortalRootContext)\n}\n\ninterface ForcePortalRootProps {\n  force: boolean\n  children: ReactNode\n}\n\nexport function ForcePortalRoot(props: ForcePortalRootProps) {\n  return (\n    <ForcePortalRootContext.Provider value={props.force}>\n      {props.children}\n    </ForcePortalRootContext.Provider>\n  )\n}\n", "import React, { createContext, useContext, type MutableRefObject, type ReactNode } from 'react'\nimport { useEvent } from '../hooks/use-event'\nimport { useIsoMorphicEffect } from '../hooks/use-iso-morphic-effect'\n\ntype OnUpdate = (\n  message: StackMessage,\n  type: string,\n  element: MutableRefObject<HTMLElement | null>\n) => void\n\nlet StackContext = createContext<OnUpdate>(() => {})\nStackContext.displayName = 'StackContext'\n\nexport enum StackMessage {\n  Add,\n  Remove,\n}\n\nexport function useStackContext() {\n  return useContext(StackContext)\n}\n\nexport function StackProvider({\n  children,\n  onUpdate,\n  type,\n  element,\n  enabled,\n}: {\n  children: ReactNode\n  onUpdate?: OnUpdate\n  type: string\n  element: MutableRefObject<HTMLElement | null>\n  enabled?: boolean\n}) {\n  let parentUpdate = useStackContext()\n\n  let notify = useEvent((...args: Parameters<OnUpdate>) => {\n    // Notify our layer\n    onUpdate?.(...args)\n\n    // Notify the parent\n    parentUpdate(...args)\n  })\n\n  useIsoMorphicEffect(() => {\n    let shouldNotify = enabled === undefined || enabled === true\n\n    shouldNotify && notify(StackMessage.Add, type, element)\n\n    return () => {\n      shouldNotify && notify(StackMessage.Remove, type, element)\n    }\n  }, [notify, type, element, enabled])\n\n  return <StackContext.Provider value={notify}>{children}</StackContext.Provider>\n}\n", "'use client'\n\nimport React, {\n  useRef,\n  type ElementType,\n  type MutableRefObject,\n  type FocusEvent as ReactFocusEvent,\n  type Ref,\n} from 'react'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useEvent } from '../../hooks/use-event'\nimport { useEventListener } from '../../hooks/use-event-listener'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useOnUnmount } from '../../hooks/use-on-unmount'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { Direction as TabDirection, useTabDirection } from '../../hooks/use-tab-direction'\nimport { useWatch } from '../../hooks/use-watch'\nimport { Hidden, HiddenFeatures } from '../../internal/hidden'\nimport type { Props } from '../../types'\nimport { history } from '../../utils/active-element-history'\nimport { Focus, FocusResult, focusElement, focusIn } from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport { microTask } from '../../utils/micro-task'\nimport { forwardRefWithAs, render, type HasDisplayName, type RefProp } from '../../utils/render'\n\ntype Containers =\n  // Lazy resolved containers\n  | (() => Iterable<HTMLElement>)\n\n  // List of containers\n  | MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n\nfunction resolveContainers(containers?: Containers): Set<HTMLElement> {\n  if (!containers) return new Set<HTMLElement>()\n  if (typeof containers === 'function') return new Set(containers())\n\n  let all = new Set<HTMLElement>()\n  for (let container of containers.current) {\n    if (container.current instanceof HTMLElement) {\n      all.add(container.current)\n    }\n  }\n  return all\n}\n\nlet DEFAULT_FOCUS_TRAP_TAG = 'div' as const\n\nexport enum FocusTrapFeatures {\n  /** No features enabled for the focus trap. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the focus trap. */\n  RestoreFocus = 1 << 4,\n\n  /** Initial focus should look for the `data-autofocus` */\n  AutoFocus = 1 << 5,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\ntype FocusTrapRenderPropArg = {}\ntype FocusTrapPropsWeControl = never\n\nexport type FocusTrapProps<TTag extends ElementType = typeof DEFAULT_FOCUS_TRAP_TAG> = Props<\n  TTag,\n  FocusTrapRenderPropArg,\n  FocusTrapPropsWeControl,\n  {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    // A fallback element to focus, but this element will be skipped when tabbing around. This is\n    // only done for focusing a fallback parent container (e.g.: A `Dialog`, but you want to tab\n    // *inside* the dialog excluding the dialog itself).\n    initialFocusFallback?: MutableRefObject<HTMLElement | null>\n    features?: FocusTrapFeatures\n    containers?: Containers\n  }\n>\n\nfunction FocusTrapFn<TTag extends ElementType = typeof DEFAULT_FOCUS_TRAP_TAG>(\n  props: FocusTrapProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let container = useRef<HTMLDivElement | null>(null)\n  let focusTrapRef = useSyncRefs(container, ref)\n  let {\n    initialFocus,\n    initialFocusFallback,\n    containers,\n    features = FocusTrapFeatures.All,\n    ...theirProps\n  } = props\n\n  if (!useServerHandoffComplete()) {\n    features = FocusTrapFeatures.None\n  }\n\n  let ownerDocument = useOwnerDocument(container)\n\n  useRestoreFocus({ ownerDocument }, Boolean(features & FocusTrapFeatures.RestoreFocus))\n  let previousActiveElement = useInitialFocus(\n    { ownerDocument, container, initialFocus, initialFocusFallback },\n    features\n  )\n\n  useFocusLock(\n    { ownerDocument, container, containers, previousActiveElement },\n    Boolean(features & FocusTrapFeatures.FocusLock)\n  )\n\n  let direction = useTabDirection()\n  let handleFocus = useEvent((e: ReactFocusEvent) => {\n    let el = container.current as HTMLElement\n    if (!el) return\n\n    // TODO: Cleanup once we are using real browser tests\n    let wrapper = process.env.NODE_ENV === 'test' ? microTask : (cb: Function) => cb()\n    wrapper(() => {\n      match(direction.current, {\n        [TabDirection.Forwards]: () => {\n          focusIn(el, Focus.First, {\n            skipElements: [e.relatedTarget, initialFocusFallback] as HTMLElement[],\n          })\n        },\n        [TabDirection.Backwards]: () => {\n          focusIn(el, Focus.Last, {\n            skipElements: [e.relatedTarget, initialFocusFallback] as HTMLElement[],\n          })\n        },\n      })\n    })\n  })\n\n  let d = useDisposables()\n  let recentlyUsedTabKey = useRef(false)\n  let ourProps = {\n    ref: focusTrapRef,\n    onKeyDown(e: KeyboardEvent) {\n      if (e.key == 'Tab') {\n        recentlyUsedTabKey.current = true\n        d.requestAnimationFrame(() => {\n          recentlyUsedTabKey.current = false\n        })\n      }\n    },\n    onBlur(e: ReactFocusEvent) {\n      if (!Boolean(features & FocusTrapFeatures.FocusLock)) return\n\n      let allContainers = resolveContainers(containers)\n      if (container.current instanceof HTMLElement) allContainers.add(container.current)\n\n      let relatedTarget = e.relatedTarget\n      if (!(relatedTarget instanceof HTMLElement)) return\n\n      // Known guards, leave them alone!\n      if (relatedTarget.dataset.headlessuiFocusGuard === 'true') {\n        return\n      }\n\n      // Blur is triggered due to focus on relatedTarget, and the relatedTarget is not inside any\n      // of the dialog containers. In other words, let's move focus back in!\n      if (!contains(allContainers, relatedTarget)) {\n        // Was the blur invoked via the keyboard? Redirect to the next in line.\n        if (recentlyUsedTabKey.current) {\n          focusIn(\n            container.current as HTMLElement,\n            match(direction.current, {\n              [TabDirection.Forwards]: () => Focus.Next,\n              [TabDirection.Backwards]: () => Focus.Previous,\n            }) | Focus.WrapAround,\n            { relativeTo: e.target as HTMLElement }\n          )\n        }\n\n        // It was invoked via something else (e.g.: click, programmatically, ...). Redirect to the\n        // previous active item in the FocusTrap\n        else if (e.target instanceof HTMLElement) {\n          focusElement(e.target)\n        }\n      }\n    },\n  }\n\n  return (\n    <>\n      {Boolean(features & FocusTrapFeatures.TabLock) && (\n        <Hidden\n          as=\"button\"\n          type=\"button\"\n          data-headlessui-focus-guard\n          onFocus={handleFocus}\n          features={HiddenFeatures.Focusable}\n        />\n      )}\n      {render({\n        ourProps,\n        theirProps,\n        defaultTag: DEFAULT_FOCUS_TRAP_TAG,\n        name: 'FocusTrap',\n      })}\n      {Boolean(features & FocusTrapFeatures.TabLock) && (\n        <Hidden\n          as=\"button\"\n          type=\"button\"\n          data-headlessui-focus-guard\n          onFocus={handleFocus}\n          features={HiddenFeatures.Focusable}\n        />\n      )}\n    </>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentFocusTrap extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_FOCUS_TRAP_TAG>(\n    props: FocusTrapProps<TTag> & RefProp<typeof FocusTrapFn>\n  ): JSX.Element\n}\n\nlet FocusTrapRoot = forwardRefWithAs(FocusTrapFn) as unknown as _internal_ComponentFocusTrap\n\nexport let FocusTrap = Object.assign(FocusTrapRoot, {\n  features: FocusTrapFeatures,\n})\n\n// ---\n\nfunction useRestoreElement(enabled: boolean = true) {\n  let localHistory = useRef<HTMLElement[]>(history.slice())\n\n  useWatch(\n    ([newEnabled], [oldEnabled]) => {\n      // We are disabling the restore element, so we need to clear it.\n      if (oldEnabled === true && newEnabled === false) {\n        // However, let's schedule it in a microTask, so that we can still read the value in the\n        // places where we are restoring the focus.\n        microTask(() => {\n          localHistory.current.splice(0)\n        })\n      }\n\n      // We are enabling the restore element, so we need to set it to the last \"focused\" element.\n      if (oldEnabled === false && newEnabled === true) {\n        localHistory.current = history.slice()\n      }\n    },\n    [enabled, history, localHistory]\n  )\n\n  // We want to return the last element that is still connected to the DOM, so we can restore the\n  // focus to it.\n  return useEvent(() => {\n    return localHistory.current.find((x) => x != null && x.isConnected) ?? null\n  })\n}\n\nfunction useRestoreFocus({ ownerDocument }: { ownerDocument: Document | null }, enabled: boolean) {\n  let getRestoreElement = useRestoreElement(enabled)\n\n  // Restore the focus to the previous element when `enabled` becomes false again\n  useWatch(() => {\n    if (enabled) return\n\n    if (ownerDocument?.activeElement === ownerDocument?.body) {\n      focusElement(getRestoreElement())\n    }\n  }, [enabled])\n\n  // Restore the focus to the previous element when the component is unmounted\n  useOnUnmount(() => {\n    if (!enabled) return\n\n    focusElement(getRestoreElement())\n  })\n}\n\nfunction useInitialFocus(\n  {\n    ownerDocument,\n    container,\n    initialFocus,\n    initialFocusFallback,\n  }: {\n    ownerDocument: Document | null\n    container: MutableRefObject<HTMLElement | null>\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    initialFocusFallback?: MutableRefObject<HTMLElement | null>\n  },\n  features: FocusTrapFeatures\n) {\n  let enabled = Boolean(features & FocusTrapFeatures.InitialFocus)\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n\n  let mounted = useIsMounted()\n\n  // Handle initial focus\n  useWatch(() => {\n    if (!enabled) {\n      // If we are disabling the initialFocus, then we should focus the fallback element if one is\n      // provided. This is needed to ensure _something_ is focused. Typically a wrapping element\n      // (e.g.: `Dialog` component).\n      //\n      // Note: we _don't_ want to move focus to the `initialFocus` ref, because the `InitialFocus`\n      // feature is disabled.\n      if (initialFocusFallback?.current) {\n        focusElement(initialFocusFallback.current)\n      }\n\n      return\n    }\n    let containerElement = container.current\n    if (!containerElement) return\n\n    // Delaying the focus to the next microtask ensures that a few conditions are true:\n    // - The container is rendered\n    // - Transitions could be started\n    // If we don't do this, then focusing an element will immediately cancel any transitions. This\n    // is not ideal because transitions will look broken.\n    // There is an additional issue with doing this immediately. The FocusTrap is used inside a\n    // Dialog, the Dialog is rendered inside of a Portal and the Portal is rendered at the end of\n    // the `document.body`. This means that the moment we call focus, the browser immediately\n    // tries to focus the element, which will still be at the bodem resulting in the page to\n    // scroll down. Delaying this will prevent the page to scroll down entirely.\n    microTask(() => {\n      if (!mounted.current) {\n        return\n      }\n\n      let activeElement = ownerDocument?.activeElement as HTMLElement\n\n      if (initialFocus?.current) {\n        if (initialFocus?.current === activeElement) {\n          previousActiveElement.current = activeElement\n          return // Initial focus ref is already the active element\n        }\n      } else if (containerElement!.contains(activeElement)) {\n        previousActiveElement.current = activeElement\n        return // Already focused within Dialog\n      }\n\n      // Try to focus the initialFocus ref\n      if (initialFocus?.current) {\n        focusElement(initialFocus.current)\n      } else {\n        if (features & FocusTrapFeatures.AutoFocus) {\n          // Try to focus the first focusable element with `Focus.AutoFocus` feature enabled\n          if (focusIn(containerElement!, Focus.First | Focus.AutoFocus) !== FocusResult.Error) {\n            return // Worked, bail\n          }\n        }\n\n        // Try to focus the first focusable element.\n        else if (focusIn(containerElement!, Focus.First) !== FocusResult.Error) {\n          return // Worked, bail\n        }\n\n        // Try the fallback\n        if (initialFocusFallback?.current) {\n          focusElement(initialFocusFallback.current)\n          if (ownerDocument?.activeElement === initialFocusFallback.current) {\n            return // Worked, bail\n          }\n        }\n\n        // Nothing worked\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n\n      previousActiveElement.current = ownerDocument?.activeElement as HTMLElement\n    })\n  }, [initialFocusFallback, enabled, features])\n\n  return previousActiveElement\n}\n\nfunction useFocusLock(\n  {\n    ownerDocument,\n    container,\n    containers,\n    previousActiveElement,\n  }: {\n    ownerDocument: Document | null\n    container: MutableRefObject<HTMLElement | null>\n    containers?: Containers\n    previousActiveElement: MutableRefObject<HTMLElement | null>\n  },\n  enabled: boolean\n) {\n  let mounted = useIsMounted()\n\n  // Prevent programmatically escaping the container\n  useEventListener(\n    ownerDocument?.defaultView,\n    'focus',\n    (event) => {\n      if (!enabled) return\n      if (!mounted.current) return\n\n      let allContainers = resolveContainers(containers)\n      if (container.current instanceof HTMLElement) allContainers.add(container.current)\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<HTMLElement>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.contains(element)) return true\n  }\n\n  return false\n}\n", "import { useRef } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nexport function useIsMounted() {\n  let mounted = useRef(false)\n\n  useIsoMorphicEffect(() => {\n    mounted.current = true\n\n    return () => {\n      mounted.current = false\n    }\n  }, [])\n\n  return mounted\n}\n", "import { useEffect, useRef } from 'react'\nimport { microTask } from '../utils/micro-task'\nimport { useEvent } from './use-event'\n\nexport function useOnUnmount(cb: () => void) {\n  let stableCb = useEvent(cb)\n\n  let trulyUnmounted = useRef(false)\n  useEffect(() => {\n    trulyUnmounted.current = false\n\n    return () => {\n      trulyUnmounted.current = true\n      microTask(() => {\n        if (!trulyUnmounted.current) return\n\n        stableCb()\n      })\n    }\n  }, [stableCb])\n}\n", "import { useRef } from 'react'\nimport { useWindowEvent } from './use-window-event'\n\nexport enum Direction {\n  Forwards,\n  Backwards,\n}\n\nexport function useTabDirection() {\n  let direction = useRef(Direction.Forwards)\n\n  useWindowEvent(\n    'keydown',\n    (event) => {\n      if (event.key === 'Tab') {\n        direction.current = event.shiftKey ? Direction.Backwards : Direction.Forwards\n      }\n    },\n    true\n  )\n\n  return direction\n}\n", "'use client'\n\nimport React, {\n  Fragment,\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ContextType,\n  type ElementType,\n  type MutableRefObject,\n  type Ref,\n} from 'react'\nimport { createPortal } from 'react-dom'\nimport { useEvent } from '../../hooks/use-event'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useOnUnmount } from '../../hooks/use-on-unmount'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { optionalRef, useSyncRefs } from '../../hooks/use-sync-refs'\nimport { usePortalRoot } from '../../internal/portal-force-root'\nimport type { Props } from '../../types'\nimport { env } from '../../utils/env'\nimport { forwardRefWithAs, render, type HasDisplayName, type RefProp } from '../../utils/render'\n\nfunction usePortalTarget(ref: MutableRefObject<HTMLElement | null>): HTMLElement | null {\n  let forceInRoot = usePortalRoot()\n  let groupTarget = useContext(PortalGroupContext)\n\n  let ownerDocument = useOwnerDocument(ref)\n\n  let [target, setTarget] = useState(() => {\n    // Group context is used, but still null\n    if (!forceInRoot && groupTarget !== null) return null\n\n    // No group context is used, let's create a default portal root\n    if (env.isServer) return null\n    let existingRoot = ownerDocument?.getElementById('headlessui-portal-root')\n    if (existingRoot) return existingRoot\n\n    if (ownerDocument === null) return null\n\n    let root = ownerDocument.createElement('div')\n    root.setAttribute('id', 'headlessui-portal-root')\n    return ownerDocument.body.appendChild(root)\n  })\n\n  // Ensure the portal root is always in the DOM\n  useEffect(() => {\n    if (target === null) return\n\n    if (!ownerDocument?.body.contains(target)) {\n      ownerDocument?.body.appendChild(target)\n    }\n  }, [target, ownerDocument])\n\n  useEffect(() => {\n    if (forceInRoot) return\n    if (groupTarget === null) return\n    setTarget(groupTarget.current)\n  }, [groupTarget, setTarget, forceInRoot])\n\n  return target\n}\n\n// ---\n\nlet DEFAULT_PORTAL_TAG = Fragment\ntype PortalRenderPropArg = {}\ntype PortalPropsWeControl = never\n\nexport type PortalProps<TTag extends ElementType = typeof DEFAULT_PORTAL_TAG> = Props<\n  TTag,\n  PortalRenderPropArg,\n  PortalPropsWeControl\n>\n\nfunction PortalFn<TTag extends ElementType = typeof DEFAULT_PORTAL_TAG>(\n  props: PortalProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let theirProps = props\n  let internalPortalRootRef = useRef<HTMLElement | null>(null)\n  let portalRef = useSyncRefs(\n    optionalRef<(typeof internalPortalRootRef)['current']>((ref) => {\n      internalPortalRootRef.current = ref\n    }),\n    ref\n  )\n  let ownerDocument = useOwnerDocument(internalPortalRootRef)\n  let target = usePortalTarget(internalPortalRootRef)\n  let [element] = useState<HTMLDivElement | null>(() =>\n    env.isServer ? null : ownerDocument?.createElement('div') ?? null\n  )\n  let parent = useContext(PortalParentContext)\n  let ready = useServerHandoffComplete()\n\n  useIsoMorphicEffect(() => {\n    if (!target || !element) return\n\n    // Element already exists in target, always calling target.appendChild(element) will cause a\n    // brief unmount/remount.\n    if (!target.contains(element)) {\n      element.setAttribute('data-headlessui-portal', '')\n      target.appendChild(element)\n    }\n  }, [target, element])\n\n  useIsoMorphicEffect(() => {\n    if (!element) return\n    if (!parent) return\n\n    return parent.register(element)\n  }, [parent, element])\n\n  useOnUnmount(() => {\n    if (!target || !element) return\n\n    if (element instanceof Node && target.contains(element)) {\n      target.removeChild(element)\n    }\n\n    if (target.childNodes.length <= 0) {\n      target.parentElement?.removeChild(target)\n    }\n  })\n\n  if (!ready) return null\n\n  let ourProps = { ref: portalRef }\n\n  return !target || !element\n    ? null\n    : createPortal(\n        render({\n          ourProps,\n          theirProps,\n          slot: {},\n          defaultTag: DEFAULT_PORTAL_TAG,\n          name: 'Portal',\n        }),\n        element\n      )\n}\n\n// ---\n\nlet DEFAULT_GROUP_TAG = Fragment\ntype GroupRenderPropArg = {}\ntype GroupPropsWeControl = never\n\nlet PortalGroupContext = createContext<MutableRefObject<HTMLElement | null> | null>(null)\n\nexport type PortalGroupProps<TTag extends ElementType = typeof DEFAULT_GROUP_TAG> = Props<\n  TTag,\n  GroupRenderPropArg,\n  GroupPropsWeControl,\n  {\n    target: MutableRefObject<HTMLElement | null>\n  }\n>\n\nfunction GroupFn<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n  props: PortalGroupProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { target, ...theirProps } = props\n  let groupRef = useSyncRefs(ref)\n\n  let ourProps = { ref: groupRef }\n\n  return (\n    <PortalGroupContext.Provider value={target}>\n      {render({\n        ourProps,\n        theirProps,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n    </PortalGroupContext.Provider>\n  )\n}\n\n// ---\n\nlet PortalParentContext = createContext<{\n  register: (portal: HTMLElement) => () => void\n  unregister: (portal: HTMLElement) => void\n  portals: MutableRefObject<HTMLElement[]>\n} | null>(null)\n\nexport function useNestedPortals() {\n  let parent = useContext(PortalParentContext)\n  let portals = useRef<HTMLElement[]>([])\n\n  let register = useEvent((portal: HTMLElement) => {\n    portals.current.push(portal)\n    if (parent) parent.register(portal)\n    return () => unregister(portal)\n  })\n\n  let unregister = useEvent((portal: HTMLElement) => {\n    let idx = portals.current.indexOf(portal)\n    if (idx !== -1) portals.current.splice(idx, 1)\n    if (parent) parent.unregister(portal)\n  })\n\n  let api = useMemo<ContextType<typeof PortalParentContext>>(\n    () => ({ register, unregister, portals }),\n    [register, unregister, portals]\n  )\n\n  return [\n    portals,\n    useMemo(() => {\n      return function PortalWrapper({ children }: { children: React.ReactNode }) {\n        return <PortalParentContext.Provider value={api}>{children}</PortalParentContext.Provider>\n      }\n    }, [api]),\n  ] as const\n}\n\n// ---\n\nexport interface _internal_ComponentPortal extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PORTAL_TAG>(\n    props: PortalProps<TTag> & RefProp<typeof PortalFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentPortalGroup extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n    props: PortalGroupProps<TTag> & RefProp<typeof GroupFn>\n  ): JSX.Element\n}\n\nlet PortalRoot = forwardRefWithAs(PortalFn) as unknown as _internal_ComponentPortal\nexport let PortalGroup = forwardRefWithAs(GroupFn) as unknown as _internal_ComponentPortalGroup\n\nexport let Portal = Object.assign(PortalRoot, { Group: PortalGroup })\n", "'use client'\n\n// WAI-ARIA: https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  type ContextType,\n  type Dispatch,\n  type ElementType,\n  type MutableRefObject,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { optionalRef, useSyncRefs } from '../../hooks/use-sync-refs'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { match } from '../../utils/match'\nimport { getOwnerDocument } from '../../utils/owner'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  useMergeRefsFn,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport { startTransition } from '../../utils/start-transition'\nimport { Keys } from '../keyboard'\n\nenum DisclosureStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  disclosureState: DisclosureStates\n\n  linkedPanel: boolean\n\n  buttonRef: MutableRefObject<HTMLButtonElement | null>\n  panelRef: MutableRefObject<HTMLDivElement | null>\n\n  buttonId: string | null\n  panelId: string | null\n}\n\nenum ActionTypes {\n  ToggleDisclosure,\n  CloseDisclosure,\n\n  SetButtonId,\n  SetPanelId,\n\n  LinkPanel,\n  UnlinkPanel,\n}\n\ntype Actions =\n  | { type: ActionTypes.ToggleDisclosure }\n  | { type: ActionTypes.CloseDisclosure }\n  | { type: ActionTypes.SetButtonId; buttonId: string | null }\n  | { type: ActionTypes.SetPanelId; panelId: string | null }\n  | { type: ActionTypes.LinkPanel }\n  | { type: ActionTypes.UnlinkPanel }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.ToggleDisclosure]: (state) => ({\n    ...state,\n    disclosureState: match(state.disclosureState, {\n      [DisclosureStates.Open]: DisclosureStates.Closed,\n      [DisclosureStates.Closed]: DisclosureStates.Open,\n    }),\n  }),\n  [ActionTypes.CloseDisclosure]: (state) => {\n    if (state.disclosureState === DisclosureStates.Closed) return state\n    return { ...state, disclosureState: DisclosureStates.Closed }\n  },\n  [ActionTypes.LinkPanel](state) {\n    if (state.linkedPanel === true) return state\n    return { ...state, linkedPanel: true }\n  },\n  [ActionTypes.UnlinkPanel](state) {\n    if (state.linkedPanel === false) return state\n    return { ...state, linkedPanel: false }\n  },\n  [ActionTypes.SetButtonId](state, action) {\n    if (state.buttonId === action.buttonId) return state\n    return { ...state, buttonId: action.buttonId }\n  },\n  [ActionTypes.SetPanelId](state, action) {\n    if (state.panelId === action.panelId) return state\n    return { ...state, panelId: action.panelId }\n  },\n}\n\nlet DisclosureContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nDisclosureContext.displayName = 'DisclosureContext'\n\nfunction useDisclosureContext(component: string) {\n  let context = useContext(DisclosureContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDisclosureContext)\n    throw err\n  }\n  return context\n}\n\nlet DisclosureAPIContext = createContext<{\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n} | null>(null)\nDisclosureAPIContext.displayName = 'DisclosureAPIContext'\n\nfunction useDisclosureAPIContext(component: string) {\n  let context = useContext(DisclosureAPIContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useDisclosureAPIContext)\n    throw err\n  }\n  return context\n}\n\nlet DisclosurePanelContext = createContext<string | null>(null)\nDisclosurePanelContext.displayName = 'DisclosurePanelContext'\n\nfunction useDisclosurePanelContext() {\n  return useContext(DisclosurePanelContext)\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_DISCLOSURE_TAG = Fragment\ntype DisclosureRenderPropArg = {\n  open: boolean\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n}\ntype DisclosurePropsWeControl = never\n\nexport type DisclosureProps<TTag extends ElementType = typeof DEFAULT_DISCLOSURE_TAG> = Props<\n  TTag,\n  DisclosureRenderPropArg,\n  DisclosurePropsWeControl,\n  {\n    defaultOpen?: boolean\n  }\n>\n\nfunction DisclosureFn<TTag extends ElementType = typeof DEFAULT_DISCLOSURE_TAG>(\n  props: DisclosureProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { defaultOpen = false, ...theirProps } = props\n  let internalDisclosureRef = useRef<HTMLElement | null>(null)\n  let disclosureRef = useSyncRefs(\n    ref,\n    optionalRef(\n      (ref) => {\n        internalDisclosureRef.current = ref as unknown as HTMLElement | null\n      },\n      props.as === undefined ||\n        // @ts-expect-error The `as` prop _can_ be a Fragment\n        props.as === Fragment\n    )\n  )\n\n  let panelRef = useRef<StateDefinition['panelRef']['current']>(null)\n  let buttonRef = useRef<StateDefinition['buttonRef']['current']>(null)\n\n  let reducerBag = useReducer(stateReducer, {\n    disclosureState: defaultOpen ? DisclosureStates.Open : DisclosureStates.Closed,\n    linkedPanel: false,\n    buttonRef,\n    panelRef,\n    buttonId: null,\n    panelId: null,\n  } as StateDefinition)\n  let [{ disclosureState, buttonId }, dispatch] = reducerBag\n\n  let close = useEvent((focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => {\n    dispatch({ type: ActionTypes.CloseDisclosure })\n    let ownerDocument = getOwnerDocument(internalDisclosureRef)\n    if (!ownerDocument) return\n    if (!buttonId) return\n\n    let restoreElement = (() => {\n      if (!focusableElement) return ownerDocument.getElementById(buttonId)\n      if (focusableElement instanceof HTMLElement) return focusableElement\n      if (focusableElement.current instanceof HTMLElement) return focusableElement.current\n\n      return ownerDocument.getElementById(buttonId)\n    })()\n\n    restoreElement?.focus()\n  })\n\n  let api = useMemo<ContextType<typeof DisclosureAPIContext>>(() => ({ close }), [close])\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: disclosureState === DisclosureStates.Open,\n        close,\n      }) satisfies DisclosureRenderPropArg,\n    [disclosureState, close]\n  )\n\n  let ourProps = {\n    ref: disclosureRef,\n  }\n\n  return (\n    <DisclosureContext.Provider value={reducerBag}>\n      <DisclosureAPIContext.Provider value={api}>\n        <OpenClosedProvider\n          value={match(disclosureState, {\n            [DisclosureStates.Open]: State.Open,\n            [DisclosureStates.Closed]: State.Closed,\n          })}\n        >\n          {render({\n            ourProps,\n            theirProps,\n            slot,\n            defaultTag: DEFAULT_DISCLOSURE_TAG,\n            name: 'Disclosure',\n          })}\n        </OpenClosedProvider>\n      </DisclosureAPIContext.Provider>\n    </DisclosureContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ntype ButtonRenderPropArg = {\n  open: boolean\n  hover: boolean\n  active: boolean\n  focus: boolean\n  autofocus: boolean\n}\ntype ButtonPropsWeControl = 'aria-controls' | 'aria-expanded'\n\nexport type DisclosureButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    disabled?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: DisclosureButtonProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-disclosure-button-${internalId}`, ...theirProps } = props\n  let [state, dispatch] = useDisclosureContext('Disclosure.Button')\n  let panelContext = useDisclosurePanelContext()\n  let isWithinPanel = panelContext === null ? false : panelContext === state.panelId\n\n  let internalButtonRef = useRef<HTMLButtonElement | null>(null)\n  let buttonRef = useSyncRefs(internalButtonRef, ref, !isWithinPanel ? state.buttonRef : null)\n  let mergeRefs = useMergeRefsFn()\n\n  useEffect(() => {\n    if (isWithinPanel) return\n\n    dispatch({ type: ActionTypes.SetButtonId, buttonId: id })\n    return () => {\n      dispatch({ type: ActionTypes.SetButtonId, buttonId: null })\n    }\n  }, [id, dispatch, isWithinPanel])\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    if (isWithinPanel) {\n      if (state.disclosureState === DisclosureStates.Closed) return\n\n      switch (event.key) {\n        case Keys.Space:\n        case Keys.Enter:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.ToggleDisclosure })\n          state.buttonRef.current?.focus()\n          break\n      }\n    } else {\n      switch (event.key) {\n        case Keys.Space:\n        case Keys.Enter:\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.ToggleDisclosure })\n          break\n      }\n    }\n  })\n\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return\n    if (props.disabled) return\n\n    if (isWithinPanel) {\n      dispatch({ type: ActionTypes.ToggleDisclosure })\n      state.buttonRef.current?.focus()\n    } else {\n      dispatch({ type: ActionTypes.ToggleDisclosure })\n    }\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: props.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: props.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: state.disclosureState === DisclosureStates.Open,\n        hover,\n        active,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies ButtonRenderPropArg,\n    [state, hover, active, focus, props.autoFocus]\n  )\n\n  let type = useResolveButtonType(props, internalButtonRef)\n  let ourProps = isWithinPanel\n    ? mergeProps(\n        {\n          ref: buttonRef,\n          type,\n          onKeyDown: handleKeyDown,\n          onClick: handleClick,\n        },\n        focusProps,\n        hoverProps,\n        pressProps\n      )\n    : mergeProps(\n        {\n          ref: buttonRef,\n          id,\n          type,\n          'aria-expanded': state.disclosureState === DisclosureStates.Open,\n          'aria-controls': state.linkedPanel ? state.panelId : undefined,\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp,\n          onClick: handleClick,\n        },\n        focusProps,\n        hoverProps,\n        pressProps\n      )\n\n  return render({\n    mergeRefs,\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Disclosure.Button',\n  })\n}\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ntype PanelRenderPropArg = {\n  open: boolean\n  close: (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => void\n}\ntype DisclosurePanelPropsWeControl = never\n\nlet PanelRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type DisclosurePanelProps<TTag extends ElementType = typeof DEFAULT_PANEL_TAG> = Props<\n  TTag,\n  PanelRenderPropArg,\n  DisclosurePanelPropsWeControl,\n  PropsForFeatures<typeof PanelRenderFeatures>\n>\n\nfunction PanelFn<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: DisclosurePanelProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-disclosure-panel-${internalId}`, ...theirProps } = props\n  let [state, dispatch] = useDisclosureContext('Disclosure.Panel')\n  let { close } = useDisclosureAPIContext('Disclosure.Panel')\n  let mergeRefs = useMergeRefsFn()\n\n  let panelRef = useSyncRefs(ref, state.panelRef, (el) => {\n    startTransition(() => dispatch({ type: el ? ActionTypes.LinkPanel : ActionTypes.UnlinkPanel }))\n  })\n\n  useEffect(() => {\n    dispatch({ type: ActionTypes.SetPanelId, panelId: id })\n    return () => {\n      dispatch({ type: ActionTypes.SetPanelId, panelId: null })\n    }\n  }, [id, dispatch])\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return state.disclosureState === DisclosureStates.Open\n  })()\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: state.disclosureState === DisclosureStates.Open,\n        close,\n      }) satisfies PanelRenderPropArg,\n    [state, close]\n  )\n\n  let ourProps = {\n    ref: panelRef,\n    id,\n  }\n\n  return (\n    <DisclosurePanelContext.Provider value={state.panelId}>\n      {render({\n        mergeRefs,\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_PANEL_TAG,\n        features: PanelRenderFeatures,\n        visible,\n        name: 'Disclosure.Panel',\n      })}\n    </DisclosurePanelContext.Provider>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentDisclosure extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_DISCLOSURE_TAG>(\n    props: DisclosureProps<TTag> & RefProp<typeof DisclosureFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDisclosureButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: DisclosureButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentDisclosurePanel extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n    props: DisclosurePanelProps<TTag> & RefProp<typeof PanelFn>\n  ): JSX.Element\n}\n\nlet DisclosureRoot = forwardRefWithAs(DisclosureFn) as unknown as _internal_ComponentDisclosure\nexport let DisclosureButton = forwardRefWithAs(\n  ButtonFn\n) as unknown as _internal_ComponentDisclosureButton\nexport let DisclosurePanel = forwardRefWithAs(\n  PanelFn\n) as unknown as _internal_ComponentDisclosurePanel\n\nexport let Disclosure = Object.assign(DisclosureRoot, {\n  Button: DisclosureButton,\n  Panel: DisclosurePanel,\n})\n", "import React from 'react'\n\nexport let startTransition =\n  // Prefer React's `startTransition` if it's available.\n  React.startTransition ??\n  function startTransition(cb: () => void) {\n    cb()\n  }\n", "'use client'\n\nimport React, { useMemo, type ElementType, type Ref } from 'react'\nimport { useId } from '../../hooks/use-id'\nimport { DisabledProvider, useDisabled } from '../../internal/disabled'\nimport { FormFieldsProvider } from '../../internal/form-fields'\nimport { IdProvider } from '../../internal/id'\nimport type { Props } from '../../types'\nimport { forwardRefWithAs, render, type HasDisplayName } from '../../utils/render'\nimport { useDescriptions } from '../description/description'\nimport { useLabels } from '../label/label'\n\nlet DEFAULT_FIELD_TAG = 'div' as const\n\ntype FieldRenderPropArg = {}\ntype FieldPropsWeControl = never\n\nexport type FieldProps<TTag extends ElementType = typeof DEFAULT_FIELD_TAG> = Props<\n  TTag,\n  FieldRenderPropArg,\n  FieldPropsWeControl,\n  {\n    disabled?: boolean\n  }\n>\n\nfunction FieldFn<TTag extends ElementType = typeof DEFAULT_FIELD_TAG>(\n  props: FieldProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let inputId = `headlessui-control-${useId()}`\n\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedBy, DescriptionProvider] = useDescriptions()\n\n  let providedDisabled = useDisabled()\n  let { disabled = providedDisabled || false, ...theirProps } = props\n\n  let slot = useMemo(() => ({ disabled }) satisfies FieldRenderPropArg, [disabled])\n\n  let ourProps = {\n    ref,\n    disabled,\n    'aria-disabled': disabled || undefined,\n  }\n\n  return (\n    <DisabledProvider value={disabled}>\n      <LabelProvider value={labelledby}>\n        <DescriptionProvider value={describedBy}>\n          <IdProvider id={inputId}>\n            {render({\n              ourProps,\n              theirProps: {\n                ...theirProps,\n                children: <FormFieldsProvider>{theirProps.children}</FormFieldsProvider>,\n              },\n              slot,\n              defaultTag: DEFAULT_FIELD_TAG,\n              name: 'Field',\n            })}\n          </IdProvider>\n        </DescriptionProvider>\n      </LabelProvider>\n    </DisabledProvider>\n  )\n}\n\nexport interface _internal_ComponentField extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_FIELD_TAG>(props: FieldProps<TTag>): JSX.Element\n}\n\nexport let Field = forwardRefWithAs(FieldFn) as unknown as _internal_ComponentField\n", "'use client'\n\nimport React, { useMemo, type ElementType, type Ref } from 'react'\nimport { DisabledProvider, useDisabled } from '../../internal/disabled'\nimport type { Props } from '../../types'\nimport { forwardRefWithAs, render, type HasDisplayName } from '../../utils/render'\nimport { useLabels } from '../label/label'\n\nlet DEFAULT_FIELDSET_TAG = 'div' as const\n\ntype FieldsetRenderPropArg = {}\ntype FieldsetPropsWeControl = 'aria-controls'\n\nexport type FieldsetProps<TTag extends ElementType = typeof DEFAULT_FIELDSET_TAG> = Props<\n  TTag,\n  FieldsetRenderPropArg,\n  FieldsetPropsWeControl,\n  {\n    disabled?: boolean\n  }\n>\n\nfunction FieldsetFn<TTag extends ElementType = typeof DEFAULT_FIELDSET_TAG>(\n  props: FieldsetProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let providedDisabled = useDisabled()\n  let { disabled = providedDisabled || false, ...theirProps } = props\n\n  let [labelledBy, LabelProvider] = useLabels()\n\n  let slot = useMemo(() => ({ disabled }) satisfies FieldsetRenderPropArg, [disabled])\n\n  let ourProps = {\n    ref,\n    role: 'group',\n\n    'aria-labelledby': labelledBy,\n    'aria-disabled': disabled || undefined,\n  }\n\n  return (\n    <DisabledProvider value={disabled}>\n      <LabelProvider>\n        {render({\n          ourProps,\n          theirProps,\n          slot,\n          defaultTag: DEFAULT_FIELDSET_TAG,\n          name: 'Fieldset',\n        })}\n      </LabelProvider>\n    </DisabledProvider>\n  )\n}\n\nexport interface _internal_ComponentFieldset extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_FIELDSET_TAG>(props: FieldsetProps<TTag>): JSX.Element\n}\n\nexport let Fieldset = forwardRefWithAs(FieldsetFn) as unknown as _internal_ComponentFieldset\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { useMemo, type ElementType, type Ref } from 'react'\nimport { useId } from '../../hooks/use-id'\nimport { useDisabled } from '../../internal/disabled'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { useLabelledBy } from '../label/label'\n\nlet DEFAULT_INPUT_TAG = 'input' as const\n\ntype InputRenderPropArg = {\n  disabled: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n  invalid: boolean\n}\ntype InputPropsWeControl = 'aria-labelledby' | 'aria-describedby'\n\nexport type InputProps<TTag extends ElementType = typeof DEFAULT_INPUT_TAG> = Props<\n  TTag,\n  InputRenderPropArg,\n  InputPropsWeControl,\n  {\n    disabled?: boolean\n    invalid?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction InputFn<TTag extends ElementType = typeof DEFAULT_INPUT_TAG>(\n  props: InputProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-input-${internalId}`,\n    disabled = providedDisabled || false,\n    invalid = false,\n    ...theirProps\n  } = props\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({\n    isTextInput: true,\n    autoFocus: props.autoFocus ?? false,\n  })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      'aria-invalid': invalid ? '' : undefined,\n      disabled: disabled || undefined,\n    },\n    focusProps,\n    hoverProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        disabled,\n        invalid,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies InputRenderPropArg,\n    [disabled, invalid, hover, focus, props.autoFocus]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_INPUT_TAG,\n    name: 'Input',\n  })\n}\n\nexport interface _internal_ComponentInput extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_INPUT_TAG>(\n    props: InputProps<TTag> & RefProp<typeof InputFn>\n  ): JSX.Element\n}\n\nexport let Input = forwardRefWithAs(InputFn) as unknown as _internal_ComponentInput\n", "'use client'\n\nimport React, { type ElementType, type Ref } from 'react'\nimport type { Props } from '../../types'\nimport { forwardRefWithAs, type HasDisplayName } from '../../utils/render'\nimport { Label } from '../label/label'\n\nlet DEFAULT_LEGEND_TAG = Label\n\ntype LegendRenderPropArg = {}\ntype LegendPropsWeControl = never\n\nexport type LegendProps<TTag extends ElementType = typeof DEFAULT_LEGEND_TAG> = Props<\n  TTag,\n  LegendRenderPropArg,\n  LegendPropsWeControl,\n  {}\n>\n\nfunction LegendFn<TTag extends ElementType = typeof DEFAULT_LEGEND_TAG>(\n  props: LegendProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  // @ts-expect-error The props can still contain an `as` prop, but we are already passing an as\n  // prop as `div` (as a default). Now the ref is inferred as the ref for a `div`, but it can still\n  // be anything.\n  return <Label as=\"div\" ref={ref} {...props} />\n}\n\nexport interface _internal_ComponentLegend extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_LEGEND_TAG>(props: LegendProps<TTag>): JSX.Element\n}\n\nexport let Legend = forwardRefWithAs(LegendFn) as unknown as _internal_ComponentLegend\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  createRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  type CSSProperties,\n  type ElementType,\n  type MutableRefObject,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useByComparator, type ByComparator } from '../../hooks/use-by-comparator'\nimport { useComputed } from '../../hooks/use-computed'\nimport { useControllable } from '../../hooks/use-controllable'\nimport { useDidElementMove } from '../../hooks/use-did-element-move'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useElementSize } from '../../hooks/use-element-size'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useOutsideClick } from '../../hooks/use-outside-click'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useTextValue } from '../../hooks/use-text-value'\nimport { useTrackedPointer } from '../../hooks/use-tracked-pointer'\nimport { useDisabled } from '../../internal/disabled'\nimport {\n  FloatingProvider,\n  useFloatingPanel,\n  useFloatingPanelProps,\n  useFloatingReference,\n  useFloatingReferenceProps,\n  type AnchorPropsWithSelection,\n} from '../../internal/floating'\nimport { FormFields } from '../../internal/form-fields'\nimport { useProvidedId } from '../../internal/id'\nimport { Modal, type ModalProps } from '../../internal/modal'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { EnsureArray, Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { Focus, calculateActiveIndex } from '../../utils/calculate-active-index'\nimport { disposables } from '../../utils/disposables'\nimport { FocusableMode, isFocusableElement, sortByDomNode } from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport { getOwnerDocument } from '../../utils/owner'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { Keys } from '../keyboard'\nimport { Label, useLabelledBy, useLabels, type _internal_ComponentLabel } from '../label/label'\nimport { Portal } from '../portal/portal'\n\nenum ListboxStates {\n  Open,\n  Closed,\n}\n\nenum ValueMode {\n  Single,\n  Multi,\n}\n\nenum ActivationTrigger {\n  Pointer,\n  Other,\n}\n\ntype ListboxOptionDataRef<T> = MutableRefObject<{\n  textValue?: string\n  disabled: boolean\n  value: T\n  domRef: MutableRefObject<HTMLElement | null>\n}>\n\ninterface StateDefinition<T> {\n  dataRef: MutableRefObject<_Data>\n\n  listboxState: ListboxStates\n\n  options: { id: string; dataRef: ListboxOptionDataRef<T> }[]\n  searchQuery: string\n  activeOptionIndex: number | null\n  activationTrigger: ActivationTrigger\n}\n\nenum ActionTypes {\n  OpenListbox,\n  CloseListbox,\n\n  GoToOption,\n  Search,\n  ClearSearch,\n\n  RegisterOption,\n  UnregisterOption,\n}\n\nfunction adjustOrderedState<T>(\n  state: StateDefinition<T>,\n  adjustment: (options: StateDefinition<T>['options']) => StateDefinition<T>['options'] = (i) => i\n) {\n  let currentActiveOption =\n    state.activeOptionIndex !== null ? state.options[state.activeOptionIndex] : null\n\n  let sortedOptions = sortByDomNode(\n    adjustment(state.options.slice()),\n    (option) => option.dataRef.current.domRef.current\n  )\n\n  // If we inserted an option before the current active option then the active option index\n  // would be wrong. To fix this, we will re-lookup the correct index.\n  let adjustedActiveOptionIndex = currentActiveOption\n    ? sortedOptions.indexOf(currentActiveOption)\n    : null\n\n  // Reset to `null` in case the currentActiveOption was removed.\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null\n  }\n\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex,\n  }\n}\n\ntype Actions<T> =\n  | { type: ActionTypes.CloseListbox }\n  | { type: ActionTypes.OpenListbox }\n  | { type: ActionTypes.GoToOption; focus: Focus.Specific; id: string; trigger?: ActivationTrigger }\n  | {\n      type: ActionTypes.GoToOption\n      focus: Exclude<Focus, Focus.Specific>\n      trigger?: ActivationTrigger\n    }\n  | { type: ActionTypes.Search; value: string }\n  | { type: ActionTypes.ClearSearch }\n  | { type: ActionTypes.RegisterOption; id: string; dataRef: ListboxOptionDataRef<T> }\n  | { type: ActionTypes.UnregisterOption; id: string }\n\nlet reducers: {\n  [P in ActionTypes]: <T>(\n    state: StateDefinition<T>,\n    action: Extract<Actions<T>, { type: P }>\n  ) => StateDefinition<T>\n} = {\n  [ActionTypes.CloseListbox](state) {\n    if (state.dataRef.current.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n    return { ...state, activeOptionIndex: null, listboxState: ListboxStates.Closed }\n  },\n  [ActionTypes.OpenListbox](state) {\n    if (state.dataRef.current.disabled) return state\n    if (state.listboxState === ListboxStates.Open) return state\n\n    // Check if we have a selected value that we can make active\n    let activeOptionIndex = state.activeOptionIndex\n    let { isSelected } = state.dataRef.current\n    let optionIdx = state.options.findIndex((option) => isSelected(option.dataRef.current.value))\n\n    if (optionIdx !== -1) {\n      activeOptionIndex = optionIdx\n    }\n\n    return { ...state, listboxState: ListboxStates.Open, activeOptionIndex }\n  },\n  [ActionTypes.GoToOption](state, action) {\n    if (state.dataRef.current.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n\n    let base = {\n      ...state,\n      searchQuery: '',\n      activationTrigger: action.trigger ?? ActivationTrigger.Other,\n    }\n\n    // Optimization:\n    //\n    // There is no need to sort the DOM nodes if we know that we don't want to focus anything\n    if (action.focus === Focus.Nothing) {\n      return {\n        ...base,\n        activeOptionIndex: null,\n      }\n    }\n\n    // Optimization:\n    //\n    // There is no need to sort the DOM nodes if we know exactly where to go\n    if (action.focus === Focus.Specific) {\n      return {\n        ...base,\n        activeOptionIndex: state.options.findIndex((o) => o.id === action.id),\n      }\n    }\n\n    // Optimization:\n    //\n    // If the current DOM node and the previous DOM node are next to eachother, or if the previous\n    // DOM node is already the first DOM node, then we don't have to sort all the DOM nodes.\n    else if (action.focus === Focus.Previous) {\n      let activeOptionIdx = state.activeOptionIndex\n      if (activeOptionIdx !== null) {\n        let currentDom = state.options[activeOptionIdx].dataRef.current.domRef\n        let previousOptionIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.options,\n          resolveActiveIndex: () => state.activeOptionIndex,\n          resolveId: (option) => option.id,\n          resolveDisabled: (option) => option.dataRef.current.disabled,\n        })\n        if (previousOptionIndex !== null) {\n          let previousDom = state.options[previousOptionIndex].dataRef.current.domRef\n          if (\n            // Next to eachother\n            currentDom.current?.previousElementSibling === previousDom.current ||\n            // Or already the first element\n            previousDom.current?.previousElementSibling === null\n          ) {\n            return {\n              ...base,\n              activeOptionIndex: previousOptionIndex,\n            }\n          }\n        }\n      }\n    }\n\n    // Optimization:\n    //\n    // If the current DOM node and the next DOM node are next to eachother, or if the next DOM node\n    // is already the last DOM node, then we don't have to sort all the DOM nodes.\n    else if (action.focus === Focus.Next) {\n      let activeOptionIdx = state.activeOptionIndex\n      if (activeOptionIdx !== null) {\n        let currentDom = state.options[activeOptionIdx].dataRef.current.domRef\n        let nextOptionIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.options,\n          resolveActiveIndex: () => state.activeOptionIndex,\n          resolveId: (option) => option.id,\n          resolveDisabled: (option) => option.dataRef.current.disabled,\n        })\n        if (nextOptionIndex !== null) {\n          let nextDom = state.options[nextOptionIndex].dataRef.current.domRef\n          if (\n            // Next to eachother\n            currentDom.current?.nextElementSibling === nextDom.current ||\n            // Or already the last element\n            nextDom.current?.nextElementSibling === null\n          ) {\n            return {\n              ...base,\n              activeOptionIndex: nextOptionIndex,\n            }\n          }\n        }\n      }\n    }\n\n    // Slow path:\n    //\n    // Ensure all the options are correctly sorted according to DOM position\n    let adjustedState = adjustOrderedState(state)\n    let activeOptionIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.options,\n      resolveActiveIndex: () => adjustedState.activeOptionIndex,\n      resolveId: (option) => option.id,\n      resolveDisabled: (option) => option.dataRef.current.disabled,\n    })\n\n    return {\n      ...base,\n      ...adjustedState,\n      activeOptionIndex,\n    }\n  },\n  [ActionTypes.Search]: (state, action) => {\n    if (state.dataRef.current.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n\n    let wasAlreadySearching = state.searchQuery !== ''\n    let offset = wasAlreadySearching ? 0 : 1\n\n    let searchQuery = state.searchQuery + action.value.toLowerCase()\n\n    let reOrderedOptions =\n      state.activeOptionIndex !== null\n        ? state.options\n            .slice(state.activeOptionIndex + offset)\n            .concat(state.options.slice(0, state.activeOptionIndex + offset))\n        : state.options\n\n    let matchingOption = reOrderedOptions.find(\n      (option) =>\n        !option.dataRef.current.disabled &&\n        option.dataRef.current.textValue?.startsWith(searchQuery)\n    )\n\n    let matchIdx = matchingOption ? state.options.indexOf(matchingOption) : -1\n\n    if (matchIdx === -1 || matchIdx === state.activeOptionIndex) return { ...state, searchQuery }\n    return {\n      ...state,\n      searchQuery,\n      activeOptionIndex: matchIdx,\n      activationTrigger: ActivationTrigger.Other,\n    }\n  },\n  [ActionTypes.ClearSearch](state) {\n    if (state.dataRef.current.disabled) return state\n    if (state.listboxState === ListboxStates.Closed) return state\n    if (state.searchQuery === '') return state\n    return { ...state, searchQuery: '' }\n  },\n  [ActionTypes.RegisterOption]: (state, action) => {\n    let option = { id: action.id, dataRef: action.dataRef }\n    let adjustedState = adjustOrderedState(state, (options) => [...options, option])\n\n    // Check if we need to make the newly registered option active.\n    if (state.activeOptionIndex === null) {\n      if (state.dataRef.current.isSelected(action.dataRef.current.value)) {\n        adjustedState.activeOptionIndex = adjustedState.options.indexOf(option)\n      }\n    }\n\n    return { ...state, ...adjustedState }\n  },\n  [ActionTypes.UnregisterOption]: (state, action) => {\n    let adjustedState = adjustOrderedState(state, (options) => {\n      let idx = options.findIndex((a) => a.id === action.id)\n      if (idx !== -1) options.splice(idx, 1)\n      return options\n    })\n\n    return {\n      ...state,\n      ...adjustedState,\n      activationTrigger: ActivationTrigger.Other,\n    }\n  },\n}\n\nlet ListboxActionsContext = createContext<{\n  openListbox(): void\n  closeListbox(): void\n  registerOption(id: string, dataRef: ListboxOptionDataRef<unknown>): () => void\n  goToOption(focus: Focus.Specific, id: string, trigger?: ActivationTrigger): void\n  goToOption(focus: Focus, id?: string, trigger?: ActivationTrigger): void\n  selectOption(id: string): void\n  selectActiveOption(): void\n  onChange(value: unknown): void\n  search(query: string): void\n  clearSearch(): void\n} | null>(null)\nListboxActionsContext.displayName = 'ListboxActionsContext'\n\nfunction useActions(component: string) {\n  let context = useContext(ListboxActionsContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Listbox /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useActions)\n    throw err\n  }\n  return context\n}\ntype _Actions = ReturnType<typeof useActions>\n\nlet ListboxDataContext = createContext<\n  | ({\n      value: unknown\n      disabled: boolean\n      invalid: boolean\n      mode: ValueMode\n      orientation: 'horizontal' | 'vertical'\n      activeOptionIndex: number | null\n      compare(a: unknown, z: unknown): boolean\n      isSelected(value: unknown): boolean\n\n      optionsPropsRef: MutableRefObject<{\n        static: boolean\n        hold: boolean\n      }>\n\n      listRef: MutableRefObject<Map<string, HTMLElement | null>>\n\n      buttonRef: MutableRefObject<HTMLButtonElement | null>\n      optionsRef: MutableRefObject<HTMLUListElement | null>\n    } & Omit<StateDefinition<unknown>, 'dataRef'>)\n  | null\n>(null)\nListboxDataContext.displayName = 'ListboxDataContext'\n\nfunction useData(component: string) {\n  let context = useContext(ListboxDataContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Listbox /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useData)\n    throw err\n  }\n  return context\n}\ntype _Data = ReturnType<typeof useData>\n\nfunction stateReducer<T>(state: StateDefinition<T>, action: Actions<T>) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_LISTBOX_TAG = Fragment\ntype ListboxRenderPropArg<T> = {\n  open: boolean\n  disabled: boolean\n  invalid: boolean\n  value: T\n}\n\nexport type ListboxProps<\n  TTag extends ElementType = typeof DEFAULT_LISTBOX_TAG,\n  TType = string,\n  TActualType = TType,\n> = Props<\n  TTag,\n  ListboxRenderPropArg<TType>,\n  'value' | 'defaultValue' | 'onChange' | 'by' | 'disabled' | 'horizontal' | 'name' | 'multiple',\n  {\n    value?: TType\n    defaultValue?: TType\n    onChange?(value: TType): void\n    by?: ByComparator<TActualType>\n    disabled?: boolean\n    invalid?: boolean\n    horizontal?: boolean\n    form?: string\n    name?: string\n    multiple?: boolean\n  }\n>\n\nfunction ListboxFn<\n  TTag extends ElementType = typeof DEFAULT_LISTBOX_TAG,\n  TType = string,\n  TActualType = TType extends (infer U)[] ? U : TType,\n>(props: ListboxProps<TTag, TType, TActualType>, ref: Ref<HTMLElement>) {\n  let providedDisabled = useDisabled()\n  let {\n    value: controlledValue,\n    defaultValue,\n    form,\n    name,\n    onChange: controlledOnChange,\n    by,\n    invalid = false,\n    disabled = providedDisabled || false,\n    horizontal = false,\n    multiple = false,\n    ...theirProps\n  } = props\n  const orientation = horizontal ? 'horizontal' : 'vertical'\n  let listboxRef = useSyncRefs(ref)\n\n  let [value = multiple ? [] : undefined, theirOnChange] = useControllable<any>(\n    controlledValue,\n    controlledOnChange,\n    defaultValue\n  )\n\n  let [state, dispatch] = useReducer(stateReducer, {\n    dataRef: createRef(),\n    listboxState: ListboxStates.Closed,\n    options: [],\n    searchQuery: '',\n    activeOptionIndex: null,\n    activationTrigger: ActivationTrigger.Other,\n    optionsVisible: false,\n  } as StateDefinition<TType>)\n\n  let optionsPropsRef = useRef<_Data['optionsPropsRef']['current']>({ static: false, hold: false })\n\n  let buttonRef = useRef<_Data['buttonRef']['current']>(null)\n  let optionsRef = useRef<_Data['optionsRef']['current']>(null)\n  let listRef = useRef<_Data['listRef']['current']>(new Map())\n\n  let compare = useByComparator(by)\n\n  let isSelected: (value: TActualType) => boolean = useCallback(\n    (compareValue) =>\n      match(data.mode, {\n        [ValueMode.Multi]: () => {\n          return (value as unknown as EnsureArray<TType>).some((option) =>\n            compare(option, compareValue)\n          )\n        },\n        [ValueMode.Single]: () => {\n          return compare(value as TActualType, compareValue)\n        },\n      }),\n    [value]\n  )\n\n  let data = useMemo<_Data>(\n    () => ({\n      ...state,\n      value,\n      disabled,\n      invalid,\n      mode: multiple ? ValueMode.Multi : ValueMode.Single,\n      orientation,\n      compare,\n      isSelected,\n      optionsPropsRef,\n      buttonRef,\n      optionsRef,\n      listRef,\n    }),\n    [value, disabled, invalid, multiple, state, listRef]\n  )\n\n  useIsoMorphicEffect(() => {\n    state.dataRef.current = data\n  }, [data])\n\n  // Handle outside click\n  useOutsideClick(\n    [data.buttonRef, data.optionsRef],\n    (event, target) => {\n      dispatch({ type: ActionTypes.CloseListbox })\n\n      if (!isFocusableElement(target, FocusableMode.Loose)) {\n        event.preventDefault()\n        data.buttonRef.current?.focus()\n      }\n    },\n    data.listboxState === ListboxStates.Open\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.listboxState === ListboxStates.Open,\n        disabled,\n        invalid,\n        value,\n      }) satisfies ListboxRenderPropArg<TType>,\n    [data, disabled, value, invalid]\n  )\n\n  let selectOption = useEvent((id: string) => {\n    let option = data.options.find((item) => item.id === id)\n    if (!option) return\n\n    onChange(option.dataRef.current.value)\n  })\n\n  let selectActiveOption = useEvent(() => {\n    if (data.activeOptionIndex !== null) {\n      let { dataRef, id } = data.options[data.activeOptionIndex]\n      onChange(dataRef.current.value)\n\n      // It could happen that the `activeOptionIndex` stored in state is actually null,\n      // but we are getting the fallback active option back instead.\n      dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, id })\n    }\n  })\n\n  let openListbox = useEvent(() => dispatch({ type: ActionTypes.OpenListbox }))\n  let closeListbox = useEvent(() => dispatch({ type: ActionTypes.CloseListbox }))\n\n  let d = useDisposables()\n  let goToOption = useEvent((focus, id, trigger) => {\n    d.dispose()\n    d.microTask(() => {\n      if (focus === Focus.Specific) {\n        return dispatch({ type: ActionTypes.GoToOption, focus: Focus.Specific, id: id!, trigger })\n      }\n\n      return dispatch({ type: ActionTypes.GoToOption, focus, trigger })\n    })\n  })\n\n  let registerOption = useEvent((id, dataRef) => {\n    dispatch({ type: ActionTypes.RegisterOption, id, dataRef })\n    return () => dispatch({ type: ActionTypes.UnregisterOption, id })\n  })\n\n  let onChange = useEvent((value: unknown) => {\n    return match(data.mode, {\n      [ValueMode.Single]() {\n        return theirOnChange?.(value as TType)\n      },\n      [ValueMode.Multi]() {\n        let copy = (data.value as TActualType[]).slice()\n\n        let idx = copy.findIndex((item) => compare(item, value as TActualType))\n        if (idx === -1) {\n          copy.push(value as TActualType)\n        } else {\n          copy.splice(idx, 1)\n        }\n\n        return theirOnChange?.(copy as unknown as TType[])\n      },\n    })\n  })\n\n  let search = useEvent((value: string) => dispatch({ type: ActionTypes.Search, value }))\n  let clearSearch = useEvent(() => dispatch({ type: ActionTypes.ClearSearch }))\n\n  let actions = useMemo<_Actions>(\n    () => ({\n      onChange,\n      registerOption,\n      goToOption,\n      closeListbox,\n      openListbox,\n      selectActiveOption,\n      selectOption,\n      search,\n      clearSearch,\n    }),\n    []\n  )\n\n  let [labelledby, LabelProvider] = useLabels({ inherit: true })\n\n  let ourProps = { ref: listboxRef }\n\n  let reset = useCallback(() => {\n    return theirOnChange?.(defaultValue)\n  }, [theirOnChange /* Explicitly ignoring `defaultValue` */])\n\n  return (\n    <LabelProvider\n      value={labelledby}\n      props={{\n        htmlFor: data.buttonRef.current?.id,\n      }}\n      slot={{\n        open: data.listboxState === ListboxStates.Open,\n        disabled,\n      }}\n    >\n      <FloatingProvider>\n        <ListboxActionsContext.Provider value={actions}>\n          <ListboxDataContext.Provider value={data}>\n            <OpenClosedProvider\n              value={match(data.listboxState, {\n                [ListboxStates.Open]: State.Open,\n                [ListboxStates.Closed]: State.Closed,\n              })}\n            >\n              {name != null && value != null && (\n                <FormFields data={{ [name]: value }} form={form} onReset={reset} />\n              )}\n              {render({\n                ourProps,\n                theirProps,\n                slot,\n                defaultTag: DEFAULT_LISTBOX_TAG,\n                name: 'Listbox',\n              })}\n            </OpenClosedProvider>\n          </ListboxDataContext.Provider>\n        </ListboxActionsContext.Provider>\n      </FloatingProvider>\n    </LabelProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ntype ButtonRenderPropArg = {\n  disabled: boolean\n  invalid: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n  open: boolean\n  active: boolean\n  value: any\n}\ntype ButtonPropsWeControl =\n  | 'aria-controls'\n  | 'aria-expanded'\n  | 'aria-haspopup'\n  | 'aria-labelledby'\n  | 'disabled'\n\nexport type ListboxButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    autoFocus?: boolean\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: ListboxButtonProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let { id = providedId || `headlessui-listbox-button-${internalId}`, ...theirProps } = props\n  let data = useData('Listbox.Button')\n  let actions = useActions('Listbox.Button')\n  let buttonRef = useSyncRefs(data.buttonRef, ref, useFloatingReference())\n  let getFloatingReferenceProps = useFloatingReferenceProps()\n\n  let d = useDisposables()\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/#keyboard-interaction-13\n\n      case Keys.Space:\n      case Keys.Enter:\n      case Keys.ArrowDown:\n        event.preventDefault()\n        actions.openListbox()\n        d.nextFrame(() => {\n          if (!data.value) actions.goToOption(Focus.First)\n        })\n        break\n\n      case Keys.ArrowUp:\n        event.preventDefault()\n        actions.openListbox()\n        d.nextFrame(() => {\n          if (!data.value) actions.goToOption(Focus.Last)\n        })\n        break\n    }\n  })\n\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    if (data.listboxState === ListboxStates.Open) {\n      actions.closeListbox()\n      d.nextFrame(() => data.buttonRef.current?.focus({ preventScroll: true }))\n    } else {\n      event.preventDefault()\n      actions.openListbox()\n    }\n  })\n\n  let labelledBy = useLabelledBy([id])\n  let describedBy = useDescribedBy()\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: data.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: data.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: data.listboxState === ListboxStates.Open,\n        active: active || data.listboxState === ListboxStates.Open,\n        disabled: data.disabled,\n        invalid: data.invalid,\n        value: data.value,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies ButtonRenderPropArg,\n    [\n      data.listboxState,\n      data.disabled,\n      data.value,\n      hover,\n      focus,\n      active,\n      data.invalid,\n      props.autoFocus,\n    ]\n  )\n\n  let ourProps = mergeProps(\n    getFloatingReferenceProps(),\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, data.buttonRef),\n      'aria-haspopup': 'listbox',\n      'aria-controls': data.optionsRef.current?.id,\n      'aria-expanded': data.listboxState === ListboxStates.Open,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      disabled: data.disabled,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onClick: handleClick,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Listbox.Button',\n  })\n}\n\n// ---\n\nlet SelectedOptionContext = createContext(false)\n\nlet DEFAULT_OPTIONS_TAG = 'ul' as const\ntype OptionsRenderPropArg = {\n  open: boolean\n}\ntype OptionsPropsWeControl =\n  | 'aria-activedescendant'\n  | 'aria-labelledby'\n  | 'aria-multiselectable'\n  | 'aria-orientation'\n  | 'role'\n  | 'tabIndex'\n\nlet OptionsRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type ListboxOptionsProps<TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG> = Props<\n  TTag,\n  OptionsRenderPropArg,\n  OptionsPropsWeControl,\n  {\n    anchor?: AnchorPropsWithSelection\n    modal?: boolean\n  } & PropsForFeatures<typeof OptionsRenderFeatures>\n>\n\nfunction OptionsFn<TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG>(\n  props: ListboxOptionsProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-listbox-options-${internalId}`, anchor, modal, ...theirProps } = props\n\n  // Always use `modal` when `anchor` is passed in\n  if (anchor != null && modal == null) {\n    modal = true\n  } else if (modal == null) {\n    modal = false\n  }\n\n  let data = useData('Listbox.Options')\n  let actions = useActions('Listbox.Options')\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return data.listboxState === ListboxStates.Open\n  })()\n\n  let initialOption = useRef<number | null>(null)\n\n  useEffect(() => {\n    if (!anchor?.to?.includes('selection')) return\n\n    if (!visible) {\n      initialOption.current = null\n      return\n    }\n\n    let elements = Array.from(data.listRef.current.values())\n    // TODO: Do not rely on DOM elements here\n    initialOption.current = elements.findIndex((el) => el?.dataset.selected === '')\n    // Default to first option if nothing is selected\n    if (initialOption.current === -1) {\n      initialOption.current = elements.findIndex((el) => el?.dataset.disabled === undefined)\n      actions.goToOption(Focus.First)\n    }\n  }, [visible, data.listRef])\n\n  // We keep track whether the button moved or not, we only check this when the menu state becomes\n  // closed. If the button moved, then we want to cancel pending transitions to prevent that the\n  // attached `MenuItems` is still transitioning while the button moved away.\n  //\n  // If we don't cancel these transitions then there will be a period where the `MenuItems` is\n  // visible and moving around because it is trying to re-position itself based on the new position.\n  //\n  // This can be solved by only transitioning the `opacity` instead of everything, but if you _do_\n  // want to transition the y-axis for example you will run into the same issue again.\n  let didButtonMove = useDidElementMove(data.buttonRef, data.listboxState !== ListboxStates.Open)\n\n  // Now that we know that the button did move or not, we can either disable the panel and all of\n  // its transitions, or rely on the `visible` state to hide the panel whenever necessary.\n  let panelEnabled = didButtonMove ? false : visible\n\n  let anchorOptions = (() => {\n    if (anchor == null) return undefined\n    if (data.listRef.current.size <= 0) return { ...anchor, inner: undefined }\n\n    let elements = Array.from(data.listRef.current.values())\n\n    return {\n      ...anchor,\n      inner: {\n        listRef: { current: elements },\n        index: initialOption.current!,\n      },\n    }\n  })()\n\n  let [floatingRef, style] = useFloatingPanel(anchorOptions)\n  let getFloatingPanelProps = useFloatingPanelProps()\n  let optionsRef = useSyncRefs(data.optionsRef, ref, anchor ? floatingRef : null)\n\n  let d = useDisposables()\n  let searchDisposables = useDisposables()\n\n  useEffect(() => {\n    let container = data.optionsRef.current\n    if (!container) return\n    if (data.listboxState !== ListboxStates.Open) return\n    if (container === getOwnerDocument(container)?.activeElement) return\n\n    container?.focus({ preventScroll: true })\n  }, [data.listboxState, data.optionsRef])\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLUListElement>) => {\n    searchDisposables.dispose()\n\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menu/#keyboard-interaction-12\n\n      // @ts-expect-error Fallthrough is expected here\n      case Keys.Space:\n        if (data.searchQuery !== '') {\n          event.preventDefault()\n          event.stopPropagation()\n          return actions.search(event.key)\n        }\n      // When in type ahead mode, fallthrough\n      case Keys.Enter:\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (data.activeOptionIndex !== null) {\n          let { dataRef } = data.options[data.activeOptionIndex]\n          actions.onChange(dataRef.current.value)\n        }\n        if (data.mode === ValueMode.Single) {\n          actions.closeListbox()\n          disposables().nextFrame(() => data.buttonRef.current?.focus({ preventScroll: true }))\n        }\n        break\n\n      case match(data.orientation, { vertical: Keys.ArrowDown, horizontal: Keys.ArrowRight }):\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.Next)\n\n      case match(data.orientation, { vertical: Keys.ArrowUp, horizontal: Keys.ArrowLeft }):\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.Previous)\n\n      case Keys.Home:\n      case Keys.PageUp:\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.First)\n\n      case Keys.End:\n      case Keys.PageDown:\n        event.preventDefault()\n        event.stopPropagation()\n        return actions.goToOption(Focus.Last)\n\n      case Keys.Escape:\n        event.preventDefault()\n        event.stopPropagation()\n        actions.closeListbox()\n        return d.nextFrame(() => data.buttonRef.current?.focus({ preventScroll: true }))\n\n      case Keys.Tab:\n        event.preventDefault()\n        event.stopPropagation()\n        break\n\n      default:\n        if (event.key.length === 1) {\n          actions.search(event.key)\n          searchDisposables.setTimeout(() => actions.clearSearch(), 350)\n        }\n        break\n    }\n  })\n\n  let labelledby = useComputed(() => data.buttonRef.current?.id, [data.buttonRef.current])\n  let slot = useMemo(\n    () => ({ open: data.listboxState === ListboxStates.Open }) satisfies OptionsRenderPropArg,\n    [data]\n  )\n\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    id,\n    ref: optionsRef,\n    'aria-activedescendant':\n      data.activeOptionIndex === null ? undefined : data.options[data.activeOptionIndex]?.id,\n    'aria-multiselectable': data.mode === ValueMode.Multi ? true : undefined,\n    'aria-labelledby': labelledby,\n    'aria-orientation': data.orientation,\n    onKeyDown: handleKeyDown,\n    role: 'listbox',\n    tabIndex: 0,\n    style: {\n      ...style,\n      '--button-width': useElementSize(data.buttonRef, true).width,\n    } as CSSProperties,\n  })\n\n  let Wrapper = modal ? Modal : anchor ? Portal : Fragment\n  let wrapperProps = modal\n    ? ({ enabled: data.listboxState === ListboxStates.Open } satisfies ModalProps)\n    : {}\n\n  // Frozen state, the selected value will only update visually when the user re-opens the <Listbox />\n  let [frozenValue, setFrozenValue] = useState(data.value)\n  if (\n    data.value !== frozenValue &&\n    data.listboxState === ListboxStates.Open &&\n    data.mode !== ValueMode.Multi\n  ) {\n    setFrozenValue(data.value)\n  }\n  let isSelected = useEvent((compareValue: unknown) => {\n    return data.compare(frozenValue, compareValue)\n  })\n\n  return (\n    <Wrapper {...wrapperProps}>\n      <ListboxDataContext.Provider\n        value={data.mode === ValueMode.Multi ? data : { ...data, isSelected }}\n      >\n        {render({\n          ourProps,\n          theirProps,\n          slot,\n          defaultTag: DEFAULT_OPTIONS_TAG,\n          features: OptionsRenderFeatures,\n          visible: panelEnabled,\n          name: 'Listbox.Options',\n        })}\n      </ListboxDataContext.Provider>\n    </Wrapper>\n  )\n}\n\n// ---\n\nlet DEFAULT_OPTION_TAG = 'li' as const\ntype OptionRenderPropArg = {\n  /** @deprecated use `focus` instead */\n  active: boolean\n  focus: boolean\n  selected: boolean\n  disabled: boolean\n\n  selectedOption: boolean\n}\ntype OptionPropsWeControl = 'aria-disabled' | 'aria-selected' | 'role' | 'tabIndex'\n\nexport type ListboxOptionProps<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  TType = string,\n> = Props<\n  TTag,\n  OptionRenderPropArg,\n  OptionPropsWeControl,\n  {\n    disabled?: boolean\n    value: TType\n  }\n>\n\nfunction OptionFn<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  // TODO: One day we will be able to infer this type from the generic in Listbox itself.\n  // But today is not that day..\n  TType = Parameters<typeof ListboxRoot>[0]['value'],\n>(props: ListboxOptionProps<TTag, TType>, ref: Ref<HTMLElement>) {\n  let internalId = useId()\n  let {\n    id = `headlessui-listbox-option-${internalId}`,\n    disabled = false,\n    value,\n    ...theirProps\n  } = props\n  let usedInSelectedOption = useContext(SelectedOptionContext) === true\n  let data = useData('Listbox.Option')\n  let actions = useActions('Listbox.Option')\n\n  let active =\n    data.activeOptionIndex !== null ? data.options[data.activeOptionIndex].id === id : false\n\n  let selected = data.isSelected(value)\n  let internalOptionRef = useRef<HTMLLIElement | null>(null)\n  let getTextValue = useTextValue(internalOptionRef)\n  let bag = useLatestValue<ListboxOptionDataRef<TType>['current']>({\n    disabled,\n    value,\n    domRef: internalOptionRef,\n    get textValue() {\n      return getTextValue()\n    },\n  })\n\n  let optionRef = useSyncRefs(ref, internalOptionRef, (el) => {\n    if (!el) {\n      data.listRef.current.delete(id)\n    } else {\n      data.listRef.current.set(id, el)\n    }\n  })\n\n  useIsoMorphicEffect(() => {\n    if (data.listboxState !== ListboxStates.Open) return\n    if (!active) return\n    if (data.activationTrigger === ActivationTrigger.Pointer) return\n    let d = disposables()\n    d.requestAnimationFrame(() => {\n      internalOptionRef.current?.scrollIntoView?.({ block: 'nearest' })\n    })\n    return d.dispose\n  }, [\n    internalOptionRef,\n    active,\n    data.listboxState,\n    data.activationTrigger,\n    /* We also want to trigger this when the position of the active item changes so that we can re-trigger the scrollIntoView */ data.activeOptionIndex,\n  ])\n\n  useIsoMorphicEffect(() => {\n    if (usedInSelectedOption) return\n    return actions.registerOption(id, bag)\n  }, [bag, id, usedInSelectedOption])\n\n  let handleClick = useEvent((event: { preventDefault: Function }) => {\n    if (disabled) return event.preventDefault()\n    actions.onChange(value)\n    if (data.mode === ValueMode.Single) {\n      actions.closeListbox()\n      disposables().nextFrame(() => data.buttonRef.current?.focus({ preventScroll: true }))\n    }\n  })\n\n  let handleFocus = useEvent(() => {\n    if (disabled) return actions.goToOption(Focus.Nothing)\n    actions.goToOption(Focus.Specific, id)\n  })\n\n  let pointer = useTrackedPointer()\n\n  let handleEnter = useEvent((evt) => {\n    pointer.update(evt)\n    if (disabled) return\n    if (active) return\n    actions.goToOption(Focus.Specific, id, ActivationTrigger.Pointer)\n  })\n\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled) return\n    if (active) return\n    actions.goToOption(Focus.Specific, id, ActivationTrigger.Pointer)\n  })\n\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled) return\n    if (!active) return\n    actions.goToOption(Focus.Nothing)\n  })\n\n  let slot = useMemo(\n    () =>\n      ({\n        active,\n        focus: active,\n        selected,\n        disabled,\n        selectedOption: selected && usedInSelectedOption,\n      }) satisfies OptionRenderPropArg,\n    [active, selected, disabled, usedInSelectedOption]\n  )\n  let ourProps = !usedInSelectedOption\n    ? {\n        id,\n        ref: optionRef,\n        role: 'option',\n        tabIndex: disabled === true ? undefined : -1,\n        'aria-disabled': disabled === true ? true : undefined,\n        // According to the WAI-ARIA best practices, we should use aria-checked for\n        // multi-select,but Voice-Over disagrees. So we use aria-checked instead for\n        // both single and multi-select.\n        'aria-selected': selected,\n        disabled: undefined, // Never forward the `disabled` prop\n        onClick: handleClick,\n        onFocus: handleFocus,\n        onPointerEnter: handleEnter,\n        onMouseEnter: handleEnter,\n        onPointerMove: handleMove,\n        onMouseMove: handleMove,\n        onPointerLeave: handleLeave,\n        onMouseLeave: handleLeave,\n      }\n    : {}\n\n  if (!selected && usedInSelectedOption) {\n    return null\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG,\n    name: 'Listbox.Option',\n  })\n}\n\n// ---\n\nlet DEFAULT_SELECTED_OPTION_TAG = Fragment\ntype SelectedOptionRenderPropArg = {}\ntype SelectedOptionPropsWeControl = never\n\nexport type ListboxSelectedOptionProps<\n  TTag extends ElementType = typeof DEFAULT_SELECTED_OPTION_TAG,\n> = Props<\n  TTag,\n  SelectedOptionRenderPropArg,\n  SelectedOptionPropsWeControl,\n  {\n    options: React.ReactNode\n    placeholder?: React.ReactNode\n  }\n>\n\nfunction SelectedFn<TTag extends ElementType = typeof DEFAULT_SELECTED_OPTION_TAG>(\n  props: ListboxSelectedOptionProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { options: children, placeholder, ...theirProps } = props\n\n  let selectedRef = useSyncRefs(ref)\n  let ourProps = { ref: selectedRef }\n  let data = useData('ListboxSelectedOption')\n  let slot = useMemo(() => ({}) satisfies SelectedOptionRenderPropArg, [])\n\n  let shouldShowPlaceholder =\n    data.value === undefined ||\n    data.value === null ||\n    (data.mode === ValueMode.Multi && Array.isArray(data.value) && data.value.length === 0)\n\n  return (\n    <SelectedOptionContext.Provider value={true}>\n      {render({\n        ourProps,\n        theirProps: {\n          ...theirProps,\n          children: <>{placeholder && shouldShowPlaceholder ? placeholder : children}</>,\n        },\n        slot,\n        defaultTag: DEFAULT_SELECTED_OPTION_TAG,\n        name: 'ListboxSelectedOption',\n      })}\n    </SelectedOptionContext.Provider>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentListbox extends HasDisplayName {\n  <\n    TTag extends ElementType = typeof DEFAULT_LISTBOX_TAG,\n    TType = string,\n    TActualType = TType extends (infer U)[] ? U : TType,\n  >(\n    props: ListboxProps<TTag, TType, TActualType> & RefProp<typeof ListboxFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentListboxButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: ListboxButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentListboxLabel extends _internal_ComponentLabel {}\n\nexport interface _internal_ComponentListboxOptions extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_OPTIONS_TAG>(\n    props: ListboxOptionsProps<TTag> & RefProp<typeof OptionsFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentListboxOption extends HasDisplayName {\n  <\n    TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n    TType = Parameters<typeof ListboxRoot>[0]['value'],\n  >(\n    props: ListboxOptionProps<TTag, TType> & RefProp<typeof OptionFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentListboxSelectedOption extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_SELECTED_OPTION_TAG>(\n    props: ListboxSelectedOptionProps<TTag> & RefProp<typeof SelectedFn>\n  ): JSX.Element\n}\n\nlet ListboxRoot = forwardRefWithAs(ListboxFn) as unknown as _internal_ComponentListbox\nexport let ListboxButton = forwardRefWithAs(ButtonFn) as unknown as _internal_ComponentListboxButton\n/** @deprecated use `<Label>` instead of `<ListboxLabel>` */\nexport let ListboxLabel = Label as _internal_ComponentListboxLabel\nexport let ListboxOptions = forwardRefWithAs(\n  OptionsFn\n) as unknown as _internal_ComponentListboxOptions\nexport let ListboxOption = forwardRefWithAs(OptionFn) as unknown as _internal_ComponentListboxOption\nexport let ListboxSelectedOption = forwardRefWithAs(\n  SelectedFn\n) as unknown as _internal_ComponentListboxSelectedOption\n\nexport let Listbox = Object.assign(ListboxRoot, {\n  Button: ListboxButton,\n  /** @deprecated use `<Label>` instead of `<Listbox.Label>` */\n  Label: ListboxLabel,\n  Options: ListboxOptions,\n  Option: ListboxOption,\n})\n", "import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useLatestValue } from './use-latest-value'\n\nexport function useComputed<T>(cb: () => T, dependencies: React.DependencyList) {\n  let [value, setValue] = useState(cb)\n  let cbRef = useLatestValue(cb)\n  useIsoMorphicEffect(() => setValue(cbRef.current), [cbRef, setValue, ...dependencies])\n  return value\n}\n", "import { useRef, type MutableRefObject } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nexport function useDidElementMove(\n  element: MutableRefObject<HTMLElement | null>,\n  enabled: boolean = true\n) {\n  let elementPosition = useRef({ left: 0, top: 0 })\n  useIsoMorphicEffect(() => {\n    let el = element.current\n    if (!el) return\n\n    let DOMRect = el.getBoundingClientRect()\n    if (DOMRect) elementPosition.current = DOMRect\n  }, [enabled])\n\n  if (element.current == null) return false\n  if (!enabled) return false\n  if (element.current === document.activeElement) return false\n\n  let buttonRect = element.current.getBoundingClientRect()\n\n  let didElementMove =\n    buttonRect.top !== elementPosition.current.top ||\n    buttonRect.left !== elementPosition.current.left\n\n  return didElementMove\n}\n", "import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nfunction computeSize(element: HTMLElement | null) {\n  if (element === null) return { width: 0, height: 0 }\n  let { width, height } = element.getBoundingClientRect()\n  return { width, height }\n}\n\nexport function useElementSize(ref: React.MutableRefObject<HTMLElement | null>, unit = false) {\n  let [size, setSize] = useState(() => computeSize(ref.current))\n\n  useIsoMorphicEffect(() => {\n    let element = ref.current\n    if (!element) return\n\n    let observer = new ResizeObserver(() => {\n      setSize(computeSize(element))\n    })\n\n    observer.observe(element)\n\n    return () => {\n      observer.disconnect()\n    }\n  }, [ref])\n\n  if (unit) {\n    return {\n      width: `${size.width}px`,\n      height: `${size.height}px`,\n    }\n  }\n\n  return size\n}\n", "import { useRef, type MutableRefObject } from 'react'\nimport { getTextValue } from '../utils/get-text-value'\nimport { useEvent } from './use-event'\n\nexport function useTextValue(element: MutableRefObject<HTMLElement | null>) {\n  let cacheKey = useRef<string>('')\n  let cacheValue = useRef<string>('')\n\n  return useEvent(() => {\n    let el = element.current\n    if (!el) return ''\n\n    // Check for a cached version\n    let currentKey = el.innerText\n    if (cacheKey.current === currentKey) {\n      return cacheValue.current\n    }\n\n    // Calculate the value\n    let value = getTextValue(el).trim().toLowerCase()\n    cacheKey.current = currentKey\n    cacheValue.current = value\n    return value\n  })\n}\n", "let emojiRegex =\n  /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g\n\nfunction getTextContents(element: HTMLElement): string {\n  // Using innerText instead of textContent because:\n  //\n  // > textContent gets the content of all elements, including <script> and <style> elements. In\n  // > contrast, innerText only shows \"human-readable\" elements.\n  // >\n  // > \u2014 https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n  let currentInnerText = element.innerText ?? ''\n\n  // Remove all the elements that shouldn't be there.\n  //\n  // [hidden]       \u2014 The user doesn't see it\n  // [aria-hidden]  \u2014 The screen reader doesn't see it\n  // [role=\"img\"]   \u2014 Even if it is text, it is used as an image\n  //\n  // This is probably the slowest part, but if you want complete control over the text value, then\n  // it is better to set an `aria-label` instead.\n  let copy = element.cloneNode(true)\n  if (!(copy instanceof HTMLElement)) {\n    return currentInnerText\n  }\n\n  let dropped = false\n  // Drop the elements that shouldn't be there.\n  for (let child of copy.querySelectorAll('[hidden],[aria-hidden],[role=\"img\"]')) {\n    child.remove()\n    dropped = true\n  }\n\n  // Now that the elements are removed, we can get the innerText such that we can strip the emojis.\n  let value = dropped ? copy.innerText ?? '' : currentInnerText\n\n  // Check if it contains some emojis or not, if so, we need to remove them\n  // because ideally we work with simple text values.\n  //\n  // Ideally we can use the much simpler RegEx: /\\p{Extended_Pictographic}/u\n  // but we can't rely on this yet, so we use the more complex one.\n  if (emojiRegex.test(value)) {\n    value = value.replace(emojiRegex, '')\n  }\n\n  return value\n}\n\nexport function getTextValue(element: HTMLElement): string {\n  // Try to use the `aria-label` first\n  let label = element.getAttribute('aria-label')\n  if (typeof label === 'string') return label.trim()\n\n  // Try to use the `aria-labelledby` second\n  let labelledby = element.getAttribute('aria-labelledby')\n  if (labelledby) {\n    // aria-labelledby can be a space-separated list of IDs, so we need to split them up and\n    // combine them into a single string.\n    let labels = labelledby\n      .split(' ')\n      .map((labelledby) => {\n        let labelEl = document.getElementById(labelledby)\n        if (labelEl) {\n          let label = labelEl.getAttribute('aria-label')\n          // Try to use the `aria-label` first (of the referenced element)\n          if (typeof label === 'string') return label.trim()\n\n          // This time, the `aria-labelledby` isn't used anymore (in Safari), so we just have to\n          // look at the contents itself.\n          return getTextContents(labelEl).trim()\n        }\n\n        return null\n      })\n      .filter(Boolean)\n\n    if (labels.length > 0) return labels.join(', ')\n  }\n\n  // Try to use the text contents of the element itself\n  return getTextContents(element).trim()\n}\n", "// WAI-ARIA: https://www.w3.org/WAI/ARIA/apg/patterns/modalmodal/\nimport React, {\n  useCallback,\n  useMemo,\n  useRef,\n  type ElementType,\n  type MutableRefObject,\n  type Ref,\n  type RefObject,\n} from 'react'\nimport { FocusTrap, FocusTrapFeatures } from '../components/focus-trap/focus-trap'\nimport { Portal, useNestedPortals } from '../components/portal/portal'\nimport { useDocumentOverflowLockedEffect } from '../hooks/document-overflow/use-document-overflow'\nimport { useId } from '../hooks/use-id'\nimport { useInert } from '../hooks/use-inert'\nimport { useOwnerDocument } from '../hooks/use-owner'\nimport { useRootContainers } from '../hooks/use-root-containers'\nimport { useSyncRefs } from '../hooks/use-sync-refs'\nimport { HoistFormFields } from '../internal/form-fields'\nimport type { Props } from '../types'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../utils/render'\nimport { ForcePortalRoot } from './portal-force-root'\n\nfunction useScrollLock(\n  ownerDocument: Document | null,\n  enabled: boolean,\n  resolveAllowedContainers: () => HTMLElement[] = () => [document.body]\n) {\n  useDocumentOverflowLockedEffect(ownerDocument, enabled, (meta) => ({\n    containers: [...(meta.containers ?? []), resolveAllowedContainers],\n  }))\n}\n\nexport enum ModalFeatures {\n  /** No modal features */\n  None = 0,\n\n  /** Make the whole page but the Modal `inert` */\n  Inert = 1 << 0,\n\n  /** Enable scroll locking to prevent scrolling the rest off the page (the body) */\n  ScrollLock = 1 << 1,\n\n  /**\n   * Enable focus trapping, focus trapping features can be configured via the `focusTrapFeatures`\n   * prop\n   */\n  FocusTrap = 1 << 2,\n\n  All = Inert | ScrollLock | FocusTrap,\n}\n\n// ---\n\nlet DEFAULT_MODAL_TAG = 'div' as const\ntype ModalRenderPropArg = {}\ntype ModalPropsWeControl = 'aria-dialog'\n\nlet ModalRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type ModalProps<TTag extends ElementType = typeof DEFAULT_MODAL_TAG> = Props<\n  TTag,\n  ModalRenderPropArg,\n  ModalPropsWeControl,\n  PropsForFeatures<typeof ModalRenderFeatures> & {\n    enabled?: boolean\n    features?: ModalFeatures\n    focusTrapFeatures?: FocusTrapFeatures\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    role?: 'dialog' | 'alertdialog'\n  }\n>\n\nfunction ModalFn<TTag extends ElementType = typeof DEFAULT_MODAL_TAG>(\n  props: ModalProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let {\n    id = `headlessui-modal-${internalId}`,\n    initialFocus,\n    role = 'dialog',\n    features = ModalFeatures.All,\n    enabled = true,\n    focusTrapFeatures = FocusTrapFeatures.All,\n    ...theirProps\n  } = props\n\n  if (!enabled) {\n    features = ModalFeatures.None\n  }\n\n  let didWarnOnRole = useRef(false)\n\n  role = (function () {\n    if (role === 'dialog' || role === 'alertdialog') {\n      return role\n    }\n\n    if (!didWarnOnRole.current) {\n      didWarnOnRole.current = true\n      console.warn(\n        `Invalid role [${role}] passed to <Modal />. Only \\`dialog\\` and and \\`alertdialog\\` are supported. Using \\`dialog\\` instead.`\n      )\n    }\n\n    return 'dialog'\n  })()\n\n  let internalModalRef = useRef<HTMLDivElement | null>(null)\n  let modalRef = useSyncRefs(internalModalRef, ref)\n\n  let ownerDocument = useOwnerDocument(internalModalRef)\n\n  let [portals, PortalWrapper] = useNestedPortals()\n\n  // We use this because reading these values during iniital render(s)\n  // can result in `null` rather then the actual elements\n  let defaultContainer: RefObject<HTMLElement> = {\n    get current() {\n      return internalModalRef.current\n    },\n  }\n\n  let {\n    resolveContainers: resolveRootContainers,\n    mainTreeNodeRef,\n    MainTreeNode,\n  } = useRootContainers({\n    portals,\n    defaultContainers: [defaultContainer],\n  })\n\n  // Ensure other elements can't be interacted with\n  let resolveRootOfMainTreeNode = useCallback(() => {\n    return (Array.from(ownerDocument?.querySelectorAll('body > *') ?? []).find((root) => {\n      // Skip the portal root, we don't want to make that one inert\n      if (root.id === 'headlessui-portal-root') return false\n\n      // Find the root of the main tree node\n      return root.contains(mainTreeNodeRef.current) && root instanceof HTMLElement\n    }) ?? null) as HTMLElement | null\n  }, [mainTreeNodeRef])\n  useInert(resolveRootOfMainTreeNode, Boolean(features & ModalFeatures.Inert))\n\n  // This would mark the parent modals as inert\n  let resolveRootOfParentModal = useCallback(() => {\n    return (Array.from(ownerDocument?.querySelectorAll('[data-headlessui-portal]') ?? []).find(\n      (root) => root.contains(mainTreeNodeRef.current) && root instanceof HTMLElement\n    ) ?? null) as HTMLElement | null\n  }, [mainTreeNodeRef])\n  useInert(resolveRootOfParentModal, Boolean(features & ModalFeatures.Inert))\n\n  // Scroll lock\n  useScrollLock(ownerDocument, Boolean(features & ModalFeatures.ScrollLock), resolveRootContainers)\n\n  let slot = useMemo(() => ({}) satisfies ModalRenderPropArg, [])\n\n  let ourProps = {\n    ref: modalRef,\n    id,\n    role,\n    'aria-modal': enabled || undefined,\n  }\n\n  return (\n    <>\n      <ForcePortalRoot force={true}>\n        <Portal>\n          <FocusTrap\n            initialFocus={initialFocus}\n            containers={resolveRootContainers}\n            features={\n              Boolean(features & ModalFeatures.FocusTrap)\n                ? focusTrapFeatures\n                : FocusTrapFeatures.None\n            }\n          >\n            <ForcePortalRoot force={false}>\n              <PortalWrapper>\n                {render({\n                  ourProps,\n                  theirProps,\n                  slot,\n                  defaultTag: DEFAULT_MODAL_TAG,\n                  features: ModalRenderFeatures,\n                  name: 'Modal',\n                })}\n              </PortalWrapper>\n            </ForcePortalRoot>\n          </FocusTrap>\n        </Portal>\n      </ForcePortalRoot>\n      <HoistFormFields>\n        <MainTreeNode />\n      </HoistFormFields>\n    </>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentModal extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_MODAL_TAG>(\n    props: ModalProps<TTag> & RefProp<typeof ModalFn>\n  ): JSX.Element\n}\n\nlet ModalRoot = forwardRefWithAs(ModalFn) as unknown as _internal_ComponentModal\n\nexport let Modal = Object.assign(ModalRoot, {})\n", "'use client'\n\n// WAI-ARIA: https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  createRef,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  type CSSProperties,\n  type Dispatch,\n  type ElementType,\n  type MutableRefObject,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useDidElementMove } from '../../hooks/use-did-element-move'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useElementSize } from '../../hooks/use-element-size'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useOutsideClick } from '../../hooks/use-outside-click'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useTextValue } from '../../hooks/use-text-value'\nimport { useTrackedPointer } from '../../hooks/use-tracked-pointer'\nimport { useTreeWalker } from '../../hooks/use-tree-walker'\nimport {\n  FloatingProvider,\n  useFloatingPanel,\n  useFloatingPanelProps,\n  useFloatingReference,\n  useFloatingReferenceProps,\n  type AnchorProps,\n} from '../../internal/floating'\nimport { Modal, ModalFeatures, type ModalProps } from '../../internal/modal'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { Focus, calculateActiveIndex } from '../../utils/calculate-active-index'\nimport { disposables } from '../../utils/disposables'\nimport {\n  Focus as FocusManagementFocus,\n  FocusableMode,\n  focusFrom,\n  isFocusableElement,\n  restoreFocusIfNecessary,\n  sortByDomNode,\n} from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescriptions } from '../description/description'\nimport { Keys } from '../keyboard'\nimport { useLabelContext, useLabels } from '../label/label'\nimport { Portal } from '../portal/portal'\n\nenum MenuStates {\n  Open,\n  Closed,\n}\n\nenum ActivationTrigger {\n  Pointer,\n  Other,\n}\n\ntype MenuItemDataRef = MutableRefObject<{\n  textValue?: string\n  disabled: boolean\n  domRef: MutableRefObject<HTMLElement | null>\n}>\n\ninterface StateDefinition {\n  __demoMode: boolean\n  menuState: MenuStates\n  buttonRef: MutableRefObject<HTMLButtonElement | null>\n  itemsRef: MutableRefObject<HTMLDivElement | null>\n  items: { id: string; dataRef: MenuItemDataRef }[]\n  searchQuery: string\n  activeItemIndex: number | null\n  activationTrigger: ActivationTrigger\n}\n\nenum ActionTypes {\n  OpenMenu,\n  CloseMenu,\n\n  GoToItem,\n  Search,\n  ClearSearch,\n  RegisterItem,\n  UnregisterItem,\n}\n\nfunction adjustOrderedState(\n  state: StateDefinition,\n  adjustment: (items: StateDefinition['items']) => StateDefinition['items'] = (i) => i\n) {\n  let currentActiveItem = state.activeItemIndex !== null ? state.items[state.activeItemIndex] : null\n\n  let sortedItems = sortByDomNode(\n    adjustment(state.items.slice()),\n    (item) => item.dataRef.current.domRef.current\n  )\n\n  // If we inserted an item before the current active item then the active item index\n  // would be wrong. To fix this, we will re-lookup the correct index.\n  let adjustedActiveItemIndex = currentActiveItem ? sortedItems.indexOf(currentActiveItem) : null\n\n  // Reset to `null` in case the currentActiveItem was removed.\n  if (adjustedActiveItemIndex === -1) {\n    adjustedActiveItemIndex = null\n  }\n\n  return {\n    items: sortedItems,\n    activeItemIndex: adjustedActiveItemIndex,\n  }\n}\n\ntype Actions =\n  | { type: ActionTypes.CloseMenu }\n  | { type: ActionTypes.OpenMenu }\n  | { type: ActionTypes.GoToItem; focus: Focus.Specific; id: string; trigger?: ActivationTrigger }\n  | {\n      type: ActionTypes.GoToItem\n      focus: Exclude<Focus, Focus.Specific>\n      trigger?: ActivationTrigger\n    }\n  | { type: ActionTypes.Search; value: string }\n  | { type: ActionTypes.ClearSearch }\n  | { type: ActionTypes.RegisterItem; id: string; dataRef: MenuItemDataRef }\n  | { type: ActionTypes.UnregisterItem; id: string }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.CloseMenu](state) {\n    if (state.menuState === MenuStates.Closed) return state\n    return { ...state, activeItemIndex: null, menuState: MenuStates.Closed }\n  },\n  [ActionTypes.OpenMenu](state) {\n    if (state.menuState === MenuStates.Open) return state\n    return {\n      ...state,\n      /* We can turn off demo mode once we re-open the `Menu` */\n      __demoMode: false,\n      menuState: MenuStates.Open,\n    }\n  },\n  [ActionTypes.GoToItem]: (state, action) => {\n    if (state.menuState === MenuStates.Closed) return state\n\n    let base = {\n      ...state,\n      searchQuery: '',\n      activationTrigger: action.trigger ?? ActivationTrigger.Other,\n    }\n\n    // Optimization:\n    //\n    // There is no need to sort the DOM nodes if we know that we don't want to focus anything\n    if (action.focus === Focus.Nothing) {\n      return {\n        ...base,\n        activeItemIndex: null,\n      }\n    }\n\n    // Optimization:\n    //\n    // There is no need to sort the DOM nodes if we know exactly where to go\n    if (action.focus === Focus.Specific) {\n      return {\n        ...base,\n        activeItemIndex: state.items.findIndex((o) => o.id === action.id),\n      }\n    }\n\n    // Optimization:\n    //\n    // If the current DOM node and the previous DOM node are next to eachother, or if the previous\n    // DOM node is already the first DOM node, then we don't have to sort all the DOM nodes.\n    else if (action.focus === Focus.Previous) {\n      let activeItemIdx = state.activeItemIndex\n      if (activeItemIdx !== null) {\n        let currentDom = state.items[activeItemIdx].dataRef.current.domRef\n        let previousItemIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.items,\n          resolveActiveIndex: () => state.activeItemIndex,\n          resolveId: (item) => item.id,\n          resolveDisabled: (item) => item.dataRef.current.disabled,\n        })\n        if (previousItemIndex !== null) {\n          let previousDom = state.items[previousItemIndex].dataRef.current.domRef\n          if (\n            // Next to eachother\n            currentDom.current?.previousElementSibling === previousDom.current ||\n            // Or already the first element\n            previousDom.current?.previousElementSibling === null\n          ) {\n            return {\n              ...base,\n              activeItemIndex: previousItemIndex,\n            }\n          }\n        }\n      }\n    }\n\n    // Optimization:\n    //\n    // If the current DOM node and the next DOM node are next to eachother, or if the next DOM node\n    // is already the last DOM node, then we don't have to sort all the DOM nodes.\n    else if (action.focus === Focus.Next) {\n      let activeItemIdx = state.activeItemIndex\n      if (activeItemIdx !== null) {\n        let currentDom = state.items[activeItemIdx].dataRef.current.domRef\n        let nextItemIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.items,\n          resolveActiveIndex: () => state.activeItemIndex,\n          resolveId: (item) => item.id,\n          resolveDisabled: (item) => item.dataRef.current.disabled,\n        })\n        if (nextItemIndex !== null) {\n          let nextDom = state.items[nextItemIndex].dataRef.current.domRef\n          if (\n            // Next to eachother\n            currentDom.current?.nextElementSibling === nextDom.current ||\n            // Or already the last element\n            nextDom.current?.nextElementSibling === null\n          ) {\n            return {\n              ...base,\n              activeItemIndex: nextItemIndex,\n            }\n          }\n        }\n      }\n    }\n\n    // Slow path:\n    //\n    // Ensure all the items are correctly sorted according to DOM position\n    let adjustedState = adjustOrderedState(state)\n    let activeItemIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.items,\n      resolveActiveIndex: () => adjustedState.activeItemIndex,\n      resolveId: (item) => item.id,\n      resolveDisabled: (item) => item.dataRef.current.disabled,\n    })\n\n    return {\n      ...base,\n      ...adjustedState,\n      activeItemIndex,\n    }\n  },\n  [ActionTypes.Search]: (state, action) => {\n    let wasAlreadySearching = state.searchQuery !== ''\n    let offset = wasAlreadySearching ? 0 : 1\n    let searchQuery = state.searchQuery + action.value.toLowerCase()\n\n    let reOrderedItems =\n      state.activeItemIndex !== null\n        ? state.items\n            .slice(state.activeItemIndex + offset)\n            .concat(state.items.slice(0, state.activeItemIndex + offset))\n        : state.items\n\n    let matchingItem = reOrderedItems.find(\n      (item) =>\n        item.dataRef.current.textValue?.startsWith(searchQuery) && !item.dataRef.current.disabled\n    )\n\n    let matchIdx = matchingItem ? state.items.indexOf(matchingItem) : -1\n    if (matchIdx === -1 || matchIdx === state.activeItemIndex) return { ...state, searchQuery }\n    return {\n      ...state,\n      searchQuery,\n      activeItemIndex: matchIdx,\n      activationTrigger: ActivationTrigger.Other,\n    }\n  },\n  [ActionTypes.ClearSearch](state) {\n    if (state.searchQuery === '') return state\n    return { ...state, searchQuery: '', searchActiveItemIndex: null }\n  },\n  [ActionTypes.RegisterItem]: (state, action) => {\n    let adjustedState = adjustOrderedState(state, (items) => [\n      ...items,\n      { id: action.id, dataRef: action.dataRef },\n    ])\n\n    return { ...state, ...adjustedState }\n  },\n  [ActionTypes.UnregisterItem]: (state, action) => {\n    let adjustedState = adjustOrderedState(state, (items) => {\n      let idx = items.findIndex((a) => a.id === action.id)\n      if (idx !== -1) items.splice(idx, 1)\n      return items\n    })\n\n    return {\n      ...state,\n      ...adjustedState,\n      activationTrigger: ActivationTrigger.Other,\n    }\n  },\n}\n\nlet MenuContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nMenuContext.displayName = 'MenuContext'\n\nfunction useMenuContext(component: string) {\n  let context = useContext(MenuContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Menu /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useMenuContext)\n    throw err\n  }\n  return context\n}\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_MENU_TAG = Fragment\ntype MenuRenderPropArg = {\n  open: boolean\n  close: () => void\n}\ntype MenuPropsWeControl = never\n\nexport type MenuProps<TTag extends ElementType = typeof DEFAULT_MENU_TAG> = Props<\n  TTag,\n  MenuRenderPropArg,\n  MenuPropsWeControl,\n  {\n    __demoMode?: boolean\n  }\n>\n\nfunction MenuFn<TTag extends ElementType = typeof DEFAULT_MENU_TAG>(\n  props: MenuProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { __demoMode = false, ...theirProps } = props\n  let reducerBag = useReducer(stateReducer, {\n    __demoMode,\n    menuState: __demoMode ? MenuStates.Open : MenuStates.Closed,\n    buttonRef: createRef(),\n    itemsRef: createRef(),\n    items: [],\n    searchQuery: '',\n    activeItemIndex: null,\n    activationTrigger: ActivationTrigger.Other,\n  } as StateDefinition)\n  let [{ menuState, itemsRef, buttonRef }, dispatch] = reducerBag\n  let menuRef = useSyncRefs(ref)\n\n  // Handle outside click\n  useOutsideClick(\n    [buttonRef, itemsRef],\n    (event, target) => {\n      dispatch({ type: ActionTypes.CloseMenu })\n\n      if (!isFocusableElement(target, FocusableMode.Loose)) {\n        event.preventDefault()\n        buttonRef.current?.focus()\n      }\n    },\n    menuState === MenuStates.Open\n  )\n\n  let close = useEvent(() => {\n    dispatch({ type: ActionTypes.CloseMenu })\n  })\n\n  let slot = useMemo(\n    () => ({ open: menuState === MenuStates.Open, close }) satisfies MenuRenderPropArg,\n    [menuState, close]\n  )\n\n  let ourProps = { ref: menuRef }\n\n  return (\n    <FloatingProvider>\n      <MenuContext.Provider value={reducerBag}>\n        <OpenClosedProvider\n          value={match(menuState, {\n            [MenuStates.Open]: State.Open,\n            [MenuStates.Closed]: State.Closed,\n          })}\n        >\n          {render({\n            ourProps,\n            theirProps,\n            slot,\n            defaultTag: DEFAULT_MENU_TAG,\n            name: 'Menu',\n          })}\n        </OpenClosedProvider>\n      </MenuContext.Provider>\n    </FloatingProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ntype ButtonRenderPropArg = {\n  open: boolean\n  active: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n}\ntype ButtonPropsWeControl = 'aria-controls' | 'aria-expanded' | 'aria-haspopup'\n\nexport type MenuButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    disabled?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: MenuButtonProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-menu-button-${internalId}`, ...theirProps } = props\n  let [state, dispatch] = useMenuContext('Menu.Button')\n  let getFloatingReferenceProps = useFloatingReferenceProps()\n  let buttonRef = useSyncRefs(state.buttonRef, ref, useFloatingReference())\n\n  let d = useDisposables()\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/#keyboard-interaction-13\n\n      case Keys.Space:\n      case Keys.Enter:\n      case Keys.ArrowDown:\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.OpenMenu })\n        d.nextFrame(() => dispatch({ type: ActionTypes.GoToItem, focus: Focus.First }))\n        break\n\n      case Keys.ArrowUp:\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.OpenMenu })\n        d.nextFrame(() => dispatch({ type: ActionTypes.GoToItem, focus: Focus.Last }))\n        break\n    }\n  })\n\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    if (props.disabled) return\n    if (state.menuState === MenuStates.Open) {\n      dispatch({ type: ActionTypes.CloseMenu })\n      d.nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n    } else {\n      event.preventDefault()\n      dispatch({ type: ActionTypes.OpenMenu })\n    }\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: props.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: props.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        open: state.menuState === MenuStates.Open,\n        active: active || state.menuState === MenuStates.Open,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies ButtonRenderPropArg,\n    [state, hover, focus, active, props.autoFocus]\n  )\n\n  let ourProps = mergeProps(\n    getFloatingReferenceProps(),\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, state.buttonRef),\n      'aria-haspopup': 'menu',\n      'aria-controls': state.itemsRef.current?.id,\n      'aria-expanded': state.menuState === MenuStates.Open,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onClick: handleClick,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Menu.Button',\n  })\n}\n\n// ---\n\nlet DEFAULT_ITEMS_TAG = 'div' as const\ntype ItemsRenderPropArg = {\n  open: boolean\n}\ntype ItemsPropsWeControl = 'aria-activedescendant' | 'aria-labelledby' | 'role' | 'tabIndex'\n\nlet ItemsRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type MenuItemsProps<TTag extends ElementType = typeof DEFAULT_ITEMS_TAG> = Props<\n  TTag,\n  ItemsRenderPropArg,\n  ItemsPropsWeControl,\n  {\n    anchor?: AnchorProps\n    modal?: boolean\n\n    // ItemsRenderFeatures\n    static?: boolean\n    unmount?: boolean\n  }\n>\n\nfunction ItemsFn<TTag extends ElementType = typeof DEFAULT_ITEMS_TAG>(\n  props: MenuItemsProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-menu-items-${internalId}`, anchor, modal, ...theirProps } = props\n  let [state, dispatch] = useMenuContext('Menu.Items')\n  let [floatingRef, style] = useFloatingPanel(anchor)\n  let getFloatingPanelProps = useFloatingPanelProps()\n  let itemsRef = useSyncRefs(state.itemsRef, ref, anchor ? floatingRef : null)\n  let ownerDocument = useOwnerDocument(state.itemsRef)\n\n  // Always use `modal` when `anchor` is passed in\n  if (anchor != null && modal == null) {\n    modal = true\n  } else if (modal == null) {\n    modal = false\n  }\n\n  let searchDisposables = useDisposables()\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return state.menuState === MenuStates.Open\n  })()\n\n  // We keep track whether the button moved or not, we only check this when the menu state becomes\n  // closed. If the button moved, then we want to cancel pending transitions to prevent that the\n  // attached `MenuItems` is still transitioning while the button moved away.\n  //\n  // If we don't cancel these transitions then there will be a period where the `MenuItems` is\n  // visible and moving around because it is trying to re-position itself based on the new position.\n  //\n  // This can be solved by only transitioning the `opacity` instead of everything, but if you _do_\n  // want to transition the y-axis for example you will run into the same issue again.\n  let didButtonMove = useDidElementMove(state.buttonRef, state.menuState !== MenuStates.Open)\n\n  // Now that we know that the button did move or not, we can either disable the panel and all of\n  // its transitions, or rely on the `visible` state to hide the panel whenever necessary.\n  let panelEnabled = didButtonMove ? false : visible\n\n  useEffect(() => {\n    let container = state.itemsRef.current\n    if (!container) return\n    if (state.menuState !== MenuStates.Open) return\n    if (container === ownerDocument?.activeElement) return\n\n    container.focus({ preventScroll: true })\n  }, [state.menuState, state.itemsRef, ownerDocument])\n\n  useTreeWalker({\n    container: state.itemsRef.current,\n    enabled: state.menuState === MenuStates.Open,\n    accept(node) {\n      if (node.getAttribute('role') === 'menuitem') return NodeFilter.FILTER_REJECT\n      if (node.hasAttribute('role')) return NodeFilter.FILTER_SKIP\n      return NodeFilter.FILTER_ACCEPT\n    },\n    walk(node) {\n      node.setAttribute('role', 'none')\n    },\n  })\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLDivElement>) => {\n    searchDisposables.dispose()\n\n    switch (event.key) {\n      // Ref: https://www.w3.org/WAI/ARIA/apg/patterns/menu/#keyboard-interaction-12\n\n      // @ts-expect-error Fallthrough is expected here\n      case Keys.Space:\n        if (state.searchQuery !== '') {\n          event.preventDefault()\n          event.stopPropagation()\n          return dispatch({ type: ActionTypes.Search, value: event.key })\n        }\n      // When in type ahead mode, fallthrough\n      case Keys.Enter:\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.CloseMenu })\n        if (state.activeItemIndex !== null) {\n          let { dataRef } = state.items[state.activeItemIndex]\n          dataRef.current?.domRef.current?.click()\n        }\n        restoreFocusIfNecessary(state.buttonRef.current)\n        break\n\n      case Keys.ArrowDown:\n        event.preventDefault()\n        event.stopPropagation()\n        return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Next })\n\n      case Keys.ArrowUp:\n        event.preventDefault()\n        event.stopPropagation()\n        return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Previous })\n\n      case Keys.Home:\n      case Keys.PageUp:\n        event.preventDefault()\n        event.stopPropagation()\n        return dispatch({ type: ActionTypes.GoToItem, focus: Focus.First })\n\n      case Keys.End:\n      case Keys.PageDown:\n        event.preventDefault()\n        event.stopPropagation()\n        return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Last })\n\n      case Keys.Escape:\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.CloseMenu })\n        disposables().nextFrame(() => state.buttonRef.current?.focus({ preventScroll: true }))\n        break\n\n      case Keys.Tab:\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.CloseMenu })\n        disposables().microTask(() => {\n          focusFrom(\n            state.buttonRef.current!,\n            event.shiftKey ? FocusManagementFocus.Previous : FocusManagementFocus.Next\n          )\n        })\n        break\n\n      default:\n        if (event.key.length === 1) {\n          dispatch({ type: ActionTypes.Search, value: event.key })\n          searchDisposables.setTimeout(() => dispatch({ type: ActionTypes.ClearSearch }), 350)\n        }\n        break\n    }\n  })\n\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Space:\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n        break\n    }\n  })\n\n  let slot = useMemo(\n    () => ({ open: state.menuState === MenuStates.Open }) satisfies ItemsRenderPropArg,\n    [state]\n  )\n\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    'aria-activedescendant':\n      state.activeItemIndex === null ? undefined : state.items[state.activeItemIndex]?.id,\n    'aria-labelledby': state.buttonRef.current?.id,\n    id,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    role: 'menu',\n    tabIndex: 0,\n    ref: itemsRef,\n    style: {\n      ...style,\n      '--button-width': useElementSize(state.buttonRef, true).width,\n    } as CSSProperties,\n  })\n\n  let Wrapper = modal ? Modal : anchor ? Portal : Fragment\n  let wrapperProps = modal\n    ? ({\n        features: ModalFeatures.ScrollLock,\n        enabled: state.menuState === MenuStates.Open,\n      } satisfies ModalProps)\n    : {}\n\n  return (\n    <Wrapper {...wrapperProps}>\n      {render({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_ITEMS_TAG,\n        features: ItemsRenderFeatures,\n        visible: panelEnabled,\n        name: 'Menu.Items',\n      })}\n    </Wrapper>\n  )\n}\n\n// ---\n\nlet DEFAULT_ITEM_TAG = Fragment\ntype ItemRenderPropArg = {\n  /** @deprecated use `focus` instead */\n  active: boolean\n  focus: boolean\n  disabled: boolean\n  close: () => void\n}\ntype ItemPropsWeControl =\n  | 'aria-describedby'\n  | 'aria-disabled'\n  | 'aria-labelledby'\n  | 'role'\n  | 'tabIndex'\n\nexport type MenuItemProps<TTag extends ElementType = typeof DEFAULT_ITEM_TAG> = Props<\n  TTag,\n  ItemRenderPropArg,\n  ItemPropsWeControl,\n  {\n    disabled?: boolean\n  }\n>\n\nfunction ItemFn<TTag extends ElementType = typeof DEFAULT_ITEM_TAG>(\n  props: MenuItemProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-menu-item-${internalId}`, disabled = false, ...theirProps } = props\n  let [state, dispatch] = useMenuContext('Menu.Item')\n  let active = state.activeItemIndex !== null ? state.items[state.activeItemIndex].id === id : false\n  let internalItemRef = useRef<HTMLElement | null>(null)\n  let itemRef = useSyncRefs(ref, internalItemRef)\n\n  useIsoMorphicEffect(() => {\n    if (state.__demoMode) return\n    if (state.menuState !== MenuStates.Open) return\n    if (!active) return\n    if (state.activationTrigger === ActivationTrigger.Pointer) return\n    let d = disposables()\n    d.requestAnimationFrame(() => {\n      internalItemRef.current?.scrollIntoView?.({ block: 'nearest' })\n    })\n    return d.dispose\n  }, [\n    state.__demoMode,\n    internalItemRef,\n    active,\n    state.menuState,\n    state.activationTrigger,\n    /* We also want to trigger this when the position of the active item changes so that we can re-trigger the scrollIntoView */ state.activeItemIndex,\n  ])\n\n  let getTextValue = useTextValue(internalItemRef)\n\n  let bag = useRef<MenuItemDataRef['current']>({\n    disabled,\n    domRef: internalItemRef,\n    get textValue() {\n      return getTextValue()\n    },\n  })\n\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled\n  }, [bag, disabled])\n\n  useIsoMorphicEffect(() => {\n    dispatch({ type: ActionTypes.RegisterItem, id, dataRef: bag })\n    return () => dispatch({ type: ActionTypes.UnregisterItem, id })\n  }, [bag, id])\n\n  let close = useEvent(() => {\n    dispatch({ type: ActionTypes.CloseMenu })\n  })\n\n  let handleClick = useEvent((event: MouseEvent) => {\n    if (disabled) return event.preventDefault()\n    dispatch({ type: ActionTypes.CloseMenu })\n    restoreFocusIfNecessary(state.buttonRef.current)\n  })\n\n  let handleFocus = useEvent(() => {\n    if (disabled) return dispatch({ type: ActionTypes.GoToItem, focus: Focus.Nothing })\n    dispatch({ type: ActionTypes.GoToItem, focus: Focus.Specific, id })\n  })\n\n  let pointer = useTrackedPointer()\n\n  let handleEnter = useEvent((evt) => {\n    pointer.update(evt)\n    if (disabled) return\n    if (active) return\n    dispatch({\n      type: ActionTypes.GoToItem,\n      focus: Focus.Specific,\n      id,\n      trigger: ActivationTrigger.Pointer,\n    })\n  })\n\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled) return\n    if (active) return\n    dispatch({\n      type: ActionTypes.GoToItem,\n      focus: Focus.Specific,\n      id,\n      trigger: ActivationTrigger.Pointer,\n    })\n  })\n\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt)) return\n    if (disabled) return\n    if (!active) return\n    dispatch({ type: ActionTypes.GoToItem, focus: Focus.Nothing })\n  })\n\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let slot = useMemo(\n    () => ({ active, focus: active, disabled, close }) satisfies ItemRenderPropArg,\n    [active, disabled, close]\n  )\n  let ourProps = {\n    id,\n    ref: itemRef,\n    role: 'menuitem',\n    tabIndex: disabled === true ? undefined : -1,\n    'aria-disabled': disabled === true ? true : undefined,\n    'aria-labelledby': labelledby,\n    'aria-describedby': describedby,\n    disabled: undefined, // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerEnter: handleEnter,\n    onMouseEnter: handleEnter,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave,\n  }\n\n  return (\n    <LabelProvider>\n      <DescriptionProvider>\n        {render({\n          ourProps,\n          theirProps,\n          slot,\n          defaultTag: DEFAULT_ITEM_TAG,\n          name: 'Menu.Item',\n        })}\n      </DescriptionProvider>\n    </LabelProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_SECTION_TAG = 'div' as const\ntype SectionRenderPropArg = {}\ntype SectionPropsWeControl = 'role' | 'aria-labelledby'\n\nexport type MenuSectionProps<TTag extends ElementType = typeof DEFAULT_SECTION_TAG> = Props<\n  TTag,\n  SectionRenderPropArg,\n  SectionPropsWeControl\n>\n\nfunction SectionFn<TTag extends ElementType = typeof DEFAULT_SECTION_TAG>(\n  props: MenuSectionProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let [labelledby, LabelProvider] = useLabels()\n\n  let theirProps = props\n  let ourProps = { ref, 'aria-labelledby': labelledby, role: 'group' }\n\n  return (\n    <LabelProvider>\n      {render({\n        ourProps,\n        theirProps,\n        slot: {},\n        defaultTag: DEFAULT_SECTION_TAG,\n        name: 'Menu.Section',\n      })}\n    </LabelProvider>\n  )\n}\n\n// --\n\nlet DEFAULT_HEADING_TAG = 'header' as const\ntype HeadingRenderPropArg = {}\ntype HeadingPropsWeControl = 'role'\n\nexport type MenuHeadingProps<TTag extends ElementType = typeof DEFAULT_HEADING_TAG> = Props<\n  TTag,\n  HeadingRenderPropArg,\n  HeadingPropsWeControl\n>\n\nfunction HeadingFn<TTag extends ElementType = typeof DEFAULT_HEADING_TAG>(\n  props: MenuHeadingProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-menu-heading-${internalId}`, ...theirProps } = props\n\n  let context = useLabelContext()\n  useIsoMorphicEffect(() => context.register(id), [id, context.register])\n\n  let ourProps = { id, ref, role: 'presentation', ...context.props }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_HEADING_TAG,\n    name: 'Menu.Heading',\n  })\n}\n\n// ---\n\nlet DEFAULT_SEPARATOR_TAG = 'div' as const\ntype SeparatorRenderPropArg = {}\ntype SeparatorPropsWeControl = 'role'\n\nexport type MenuSeparatorProps<TTag extends ElementType = typeof DEFAULT_SEPARATOR_TAG> = Props<\n  TTag,\n  SeparatorRenderPropArg,\n  SeparatorPropsWeControl\n>\n\nfunction SeparatorFn<TTag extends ElementType = typeof DEFAULT_SEPARATOR_TAG>(\n  props: MenuSeparatorProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let theirProps = props\n  let ourProps = { ref, role: 'separator' }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_SEPARATOR_TAG,\n    name: 'Menu.Separator',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentMenu extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_MENU_TAG>(\n    props: MenuProps<TTag> & RefProp<typeof MenuFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: MenuButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuItems extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_ITEMS_TAG>(\n    props: MenuItemsProps<TTag> & RefProp<typeof ItemsFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuItem extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_ITEM_TAG>(\n    props: MenuItemProps<TTag> & RefProp<typeof ItemFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuSection extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_SECTION_TAG>(\n    props: MenuSectionProps<TTag> & RefProp<typeof SectionFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuHeading extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_HEADING_TAG>(\n    props: MenuHeadingProps<TTag> & RefProp<typeof HeadingFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentMenuSeparator extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_SEPARATOR_TAG>(\n    props: MenuSeparatorProps<TTag> & RefProp<typeof SeparatorFn>\n  ): JSX.Element\n}\n\nlet MenuRoot = forwardRefWithAs(MenuFn) as unknown as _internal_ComponentMenu\nexport let MenuButton = forwardRefWithAs(ButtonFn) as unknown as _internal_ComponentMenuButton\nexport let MenuItems = forwardRefWithAs(ItemsFn) as unknown as _internal_ComponentMenuItems\nexport let MenuItem = forwardRefWithAs(ItemFn) as unknown as _internal_ComponentMenuItem\nexport let MenuSection = forwardRefWithAs(SectionFn) as unknown as _internal_ComponentMenuSection\nexport let MenuHeading = forwardRefWithAs(HeadingFn) as unknown as _internal_ComponentMenuHeading\nexport let MenuSeparator = forwardRefWithAs(\n  SeparatorFn\n) as unknown as _internal_ComponentMenuSeparator\n\nexport let Menu = Object.assign(MenuRoot, {\n  Button: MenuButton,\n  Items: MenuItems,\n  Item: MenuItem,\n  Section: MenuSection,\n  Heading: MenuHeading,\n  Separator: MenuSeparator,\n})\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  createRef,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  type ContextType,\n  type Dispatch,\n  type ElementType,\n  type MouseEventHandler,\n  type MutableRefObject,\n  type FocusEvent as ReactFocusEvent,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useEvent } from '../../hooks/use-event'\nimport { useEventListener } from '../../hooks/use-event-listener'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useOutsideClick } from '../../hooks/use-outside-click'\nimport { useOwnerDocument } from '../../hooks/use-owner'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useMainTreeNode, useRootContainers } from '../../hooks/use-root-containers'\nimport { optionalRef, useSyncRefs } from '../../hooks/use-sync-refs'\nimport { Direction as TabDirection, useTabDirection } from '../../hooks/use-tab-direction'\nimport {\n  FloatingProvider,\n  useFloatingPanel,\n  useFloatingPanelProps,\n  useFloatingReference,\n  type AnchorProps,\n} from '../../internal/floating'\nimport { Hidden, HiddenFeatures } from '../../internal/hidden'\nimport { Modal, ModalFeatures as ModalRenderFeatures, type ModalProps } from '../../internal/modal'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport {\n  Focus,\n  FocusResult,\n  FocusableMode,\n  focusIn,\n  getFocusableElements,\n  isFocusableElement,\n} from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport { microTask } from '../../utils/micro-task'\nimport { getOwnerDocument } from '../../utils/owner'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  useMergeRefsFn,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport { FocusTrapFeatures } from '../focus-trap/focus-trap'\nimport { Keys } from '../keyboard'\nimport { Portal, useNestedPortals } from '../portal/portal'\n\ntype MouseEvent<T> = Parameters<MouseEventHandler<T>>[0]\n\nenum PopoverStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  __demoMode: boolean\n  popoverState: PopoverStates\n\n  buttons: MutableRefObject<Symbol[]>\n\n  button: HTMLElement | null\n  buttonId: string | null\n  panel: HTMLElement | null\n  panelId: string | null\n\n  beforePanelSentinel: MutableRefObject<HTMLButtonElement | null>\n  afterPanelSentinel: MutableRefObject<HTMLButtonElement | null>\n}\n\nenum ActionTypes {\n  TogglePopover,\n  ClosePopover,\n\n  SetButton,\n  SetButtonId,\n  SetPanel,\n  SetPanelId,\n}\n\ntype Actions =\n  | { type: ActionTypes.TogglePopover }\n  | { type: ActionTypes.ClosePopover }\n  | { type: ActionTypes.SetButton; button: HTMLElement | null }\n  | { type: ActionTypes.SetButtonId; buttonId: string | null }\n  | { type: ActionTypes.SetPanel; panel: HTMLElement | null }\n  | { type: ActionTypes.SetPanelId; panelId: string | null }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.TogglePopover]: (state) => {\n    let nextState = {\n      ...state,\n      popoverState: match(state.popoverState, {\n        [PopoverStates.Open]: PopoverStates.Closed,\n        [PopoverStates.Closed]: PopoverStates.Open,\n      }),\n    }\n\n    /* We can turn off demo mode once we re-open the `Popover` */\n    if (nextState.popoverState === PopoverStates.Open) {\n      nextState.__demoMode = false\n    }\n\n    return nextState\n  },\n  [ActionTypes.ClosePopover](state) {\n    if (state.popoverState === PopoverStates.Closed) return state\n    return { ...state, popoverState: PopoverStates.Closed }\n  },\n  [ActionTypes.SetButton](state, action) {\n    if (state.button === action.button) return state\n    return { ...state, button: action.button }\n  },\n  [ActionTypes.SetButtonId](state, action) {\n    if (state.buttonId === action.buttonId) return state\n    return { ...state, buttonId: action.buttonId }\n  },\n  [ActionTypes.SetPanel](state, action) {\n    if (state.panel === action.panel) return state\n    return { ...state, panel: action.panel }\n  },\n  [ActionTypes.SetPanelId](state, action) {\n    if (state.panelId === action.panelId) return state\n    return { ...state, panelId: action.panelId }\n  },\n}\n\nlet PopoverContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nPopoverContext.displayName = 'PopoverContext'\n\nfunction usePopoverContext(component: string) {\n  let context = useContext(PopoverContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverAPIContext = createContext<{\n  close(\n    focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null> | MouseEvent<HTMLElement>\n  ): void\n  isPortalled: boolean\n} | null>(null)\nPopoverAPIContext.displayName = 'PopoverAPIContext'\n\nfunction usePopoverAPIContext(component: string) {\n  let context = useContext(PopoverAPIContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverAPIContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverGroupContext = createContext<{\n  registerPopover(registerbag: PopoverRegisterBag): void\n  unregisterPopover(registerbag: PopoverRegisterBag): void\n  isFocusWithinPopoverGroup(): boolean\n  closeOthers(buttonId: string): void\n  mainTreeNodeRef: MutableRefObject<HTMLElement | null>\n} | null>(null)\nPopoverGroupContext.displayName = 'PopoverGroupContext'\n\nfunction usePopoverGroupContext() {\n  return useContext(PopoverGroupContext)\n}\n\nlet PopoverPanelContext = createContext<string | null>(null)\nPopoverPanelContext.displayName = 'PopoverPanelContext'\n\nfunction usePopoverPanelContext() {\n  return useContext(PopoverPanelContext)\n}\n\ninterface PopoverRegisterBag {\n  buttonId: MutableRefObject<string | null>\n  panelId: MutableRefObject<string | null>\n  close(): void\n}\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_POPOVER_TAG = 'div' as const\ntype PopoverRenderPropArg = {\n  open: boolean\n  close(\n    focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null> | MouseEvent<HTMLElement>\n  ): void\n}\ntype PopoverPropsWeControl = never\n\nexport type PopoverProps<TTag extends ElementType = typeof DEFAULT_POPOVER_TAG> = Props<\n  TTag,\n  PopoverRenderPropArg,\n  PopoverPropsWeControl,\n  {\n    __demoMode?: boolean\n  }\n>\n\nfunction PopoverFn<TTag extends ElementType = typeof DEFAULT_POPOVER_TAG>(\n  props: PopoverProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { __demoMode = false, ...theirProps } = props\n  let internalPopoverRef = useRef<HTMLElement | null>(null)\n  let popoverRef = useSyncRefs(\n    ref,\n    optionalRef((ref) => {\n      internalPopoverRef.current = ref\n    })\n  )\n\n  let buttons = useRef([])\n  let reducerBag = useReducer(stateReducer, {\n    __demoMode,\n    popoverState: __demoMode ? PopoverStates.Open : PopoverStates.Closed,\n    buttons,\n    button: null,\n    buttonId: null,\n    panel: null,\n    panelId: null,\n    beforePanelSentinel: createRef(),\n    afterPanelSentinel: createRef(),\n  } as StateDefinition)\n  let [\n    { popoverState, button, buttonId, panel, panelId, beforePanelSentinel, afterPanelSentinel },\n    dispatch,\n  ] = reducerBag\n\n  let ownerDocument = useOwnerDocument(internalPopoverRef.current ?? button)\n\n  let isPortalled = useMemo(() => {\n    if (!button) return false\n    if (!panel) return false\n\n    // We are part of a different \"root\" tree, so therefore we can consider it portalled. This is a\n    // heuristic because 3rd party tools could use some form of portal, typically rendered at the\n    // end of the body but we don't have an actual reference to that.\n    for (let root of document.querySelectorAll('body > *')) {\n      if (Number(root?.contains(button)) ^ Number(root?.contains(panel))) {\n        return true\n      }\n    }\n\n    // Use another heuristic to try and calculate wether or not the focusable elements are near\n    // eachother (aka, following the default focus/tab order from the browser). If they are then it\n    // doesn't really matter if they are portalled or not because we can follow the default tab\n    // order. But if they are not, then we can consider it being portalled so that we can ensure\n    // that tab and shift+tab (hopefully) go to the correct spot.\n    let elements = getFocusableElements()\n    let buttonIdx = elements.indexOf(button)\n\n    let beforeIdx = (buttonIdx + elements.length - 1) % elements.length\n    let afterIdx = (buttonIdx + 1) % elements.length\n\n    let beforeElement = elements[beforeIdx]\n    let afterElement = elements[afterIdx]\n\n    if (!panel.contains(beforeElement) && !panel.contains(afterElement)) {\n      return true\n    }\n\n    // It may or may not be portalled, but we don't really know.\n    return false\n  }, [button, panel])\n\n  let buttonIdRef = useLatestValue(buttonId)\n  let panelIdRef = useLatestValue(panelId)\n\n  let registerBag = useMemo(\n    () => ({\n      buttonId: buttonIdRef,\n      panelId: panelIdRef,\n      close: () => dispatch({ type: ActionTypes.ClosePopover }),\n    }),\n    [buttonIdRef, panelIdRef, dispatch]\n  )\n\n  let groupContext = usePopoverGroupContext()\n  let registerPopover = groupContext?.registerPopover\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    return (\n      groupContext?.isFocusWithinPopoverGroup() ??\n      (ownerDocument?.activeElement &&\n        (button?.contains(ownerDocument.activeElement) ||\n          panel?.contains(ownerDocument.activeElement)))\n    )\n  })\n\n  useEffect(() => registerPopover?.(registerBag), [registerPopover, registerBag])\n\n  let [portals, PortalWrapper] = useNestedPortals()\n  let root = useRootContainers({\n    mainTreeNodeRef: groupContext?.mainTreeNodeRef,\n    portals,\n    defaultContainers: [button, panel],\n  })\n\n  // Handle focus out\n  useEventListener(\n    ownerDocument?.defaultView,\n    'focus',\n    (event) => {\n      if (event.target === window) return\n      if (!(event.target instanceof HTMLElement)) return\n      if (popoverState !== PopoverStates.Open) return\n      if (isFocusWithinPopoverGroup()) return\n      if (!button) return\n      if (!panel) return\n      if (root.contains(event.target)) return\n      if (beforePanelSentinel.current?.contains?.(event.target)) return\n      if (afterPanelSentinel.current?.contains?.(event.target)) return\n\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    true\n  )\n\n  // Handle outside click\n  useOutsideClick(\n    root.resolveContainers,\n    (event, target) => {\n      dispatch({ type: ActionTypes.ClosePopover })\n\n      if (!isFocusableElement(target, FocusableMode.Loose)) {\n        event.preventDefault()\n        button?.focus()\n      }\n    },\n    popoverState === PopoverStates.Open\n  )\n\n  let close = useEvent(\n    (\n      focusableElement?:\n        | HTMLElement\n        | MutableRefObject<HTMLElement | null>\n        | MouseEvent<HTMLElement>\n    ) => {\n      dispatch({ type: ActionTypes.ClosePopover })\n\n      let restoreElement = (() => {\n        if (!focusableElement) return button\n        if (focusableElement instanceof HTMLElement) return focusableElement\n        if ('current' in focusableElement && focusableElement.current instanceof HTMLElement)\n          return focusableElement.current\n\n        return button\n      })()\n\n      restoreElement?.focus()\n    }\n  )\n\n  let api = useMemo<ContextType<typeof PopoverAPIContext>>(\n    () => ({ close, isPortalled }),\n    [close, isPortalled]\n  )\n\n  let slot = useMemo(\n    () => ({ open: popoverState === PopoverStates.Open, close }) satisfies PopoverRenderPropArg,\n    [popoverState, close]\n  )\n\n  let ourProps = { ref: popoverRef }\n\n  return (\n    <FloatingProvider>\n      <PopoverPanelContext.Provider value={null}>\n        <PopoverContext.Provider value={reducerBag}>\n          <PopoverAPIContext.Provider value={api}>\n            <OpenClosedProvider\n              value={match(popoverState, {\n                [PopoverStates.Open]: State.Open,\n                [PopoverStates.Closed]: State.Closed,\n              })}\n            >\n              <PortalWrapper>\n                {render({\n                  ourProps,\n                  theirProps,\n                  slot,\n                  defaultTag: DEFAULT_POPOVER_TAG,\n                  name: 'Popover',\n                })}\n                <root.MainTreeNode />\n              </PortalWrapper>\n            </OpenClosedProvider>\n          </PopoverAPIContext.Provider>\n        </PopoverContext.Provider>\n      </PopoverPanelContext.Provider>\n    </FloatingProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ntype ButtonRenderPropArg = {\n  open: boolean\n  active: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n}\ntype ButtonPropsWeControl = 'aria-controls' | 'aria-expanded'\n\nexport type PopoverButtonProps<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG> = Props<\n  TTag,\n  ButtonRenderPropArg,\n  ButtonPropsWeControl,\n  {\n    disabled?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction ButtonFn<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: PopoverButtonProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-popover-button-${internalId}`, ...theirProps } = props\n  let [state, dispatch] = usePopoverContext('Popover.Button')\n  let { isPortalled } = usePopoverAPIContext('Popover.Button')\n  let internalButtonRef = useRef<HTMLButtonElement | null>(null)\n\n  let sentinelId = `headlessui-focus-sentinel-${useId()}`\n\n  let groupContext = usePopoverGroupContext()\n  let closeOthers = groupContext?.closeOthers\n\n  let panelContext = usePopoverPanelContext()\n\n  // A button inside a panel will just have \"close\" functionality, no \"open\" functionality. However,\n  // if a `Popover.Button` is rendered inside a `Popover` which in turn is rendered inside a\n  // `Popover.Panel` (aka nested popovers), then we need to make sure that the button is able to\n  // open the nested popover.\n  //\n  // The `Popover` itself will also render a `PopoverPanelContext` but with a value of `null`. That\n  // way we don't need to keep track of _which_ `Popover.Panel` (if at all) we are in, we can just\n  // check if we are in a `Popover.Panel` or not since this will always point to the nearest one and\n  // won't pierce through `Popover` components themselves.\n  let isWithinPanel = panelContext !== null\n\n  useEffect(() => {\n    if (isWithinPanel) return\n    dispatch({ type: ActionTypes.SetButtonId, buttonId: id })\n    return () => {\n      dispatch({ type: ActionTypes.SetButtonId, buttonId: null })\n    }\n  }, [isWithinPanel, id, dispatch])\n\n  // This is a little bit different compared to the `id` we already have. The goal is to have a very\n  // unique identifier for this specific component. This can be achieved with the `id` from above.\n  //\n  // However, the difference is for React 17 and lower where the `useId` hook doesn't exist yet.\n  // There we will generate a unique ID based on a simple counter, but for SSR this will result in\n  // `undefined` first, later it is patched to be a unique ID. The problem is that this patching\n  // happens after the component is rendered and therefore there is a moment in time where multiple\n  // buttons have the exact same ID and the `state.buttons` would result in something like:\n  //\n  // ```js\n  // ['headlessui-popover-button-undefined', 'headlessui-popover-button-1']\n  // ```\n  //\n  // With this approach we guarantee that there is a unique value for each button.\n  let [uniqueIdentifier] = useState(() => Symbol())\n\n  let buttonRef = useSyncRefs(\n    internalButtonRef,\n    ref,\n    useFloatingReference(),\n    isWithinPanel\n      ? null\n      : (button) => {\n          if (button) {\n            state.buttons.current.push(uniqueIdentifier)\n          } else {\n            let idx = state.buttons.current.indexOf(uniqueIdentifier)\n            if (idx !== -1) state.buttons.current.splice(idx, 1)\n          }\n\n          if (state.buttons.current.length > 1) {\n            console.warn(\n              'You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.'\n            )\n          }\n\n          button && dispatch({ type: ActionTypes.SetButton, button })\n        }\n  )\n  let withinPanelButtonRef = useSyncRefs(internalButtonRef, ref)\n  let ownerDocument = useOwnerDocument(internalButtonRef)\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    if (isWithinPanel) {\n      if (state.popoverState === PopoverStates.Closed) return\n      switch (event.key) {\n        case Keys.Space:\n        case Keys.Enter:\n          event.preventDefault() // Prevent triggering a *click* event\n          // @ts-expect-error\n          event.target.click?.()\n          dispatch({ type: ActionTypes.ClosePopover })\n          state.button?.focus() // Re-focus the original opening Button\n          break\n      }\n    } else {\n      switch (event.key) {\n        case Keys.Space:\n        case Keys.Enter:\n          event.preventDefault() // Prevent triggering a *click* event\n          event.stopPropagation()\n          if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId!)\n          dispatch({ type: ActionTypes.TogglePopover })\n          break\n\n        case Keys.Escape:\n          if (state.popoverState !== PopoverStates.Open) return closeOthers?.(state.buttonId!)\n          if (!internalButtonRef.current) return\n          if (\n            ownerDocument?.activeElement &&\n            !internalButtonRef.current.contains(ownerDocument.activeElement)\n          ) {\n            return\n          }\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.ClosePopover })\n          break\n      }\n    }\n  })\n\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    if (isWithinPanel) return\n    if (event.key === Keys.Space) {\n      // Required for firefox, event.preventDefault() in handleKeyDown for\n      // the Space key doesn't cancel the handleKeyUp, which in turn\n      // triggers a *click*.\n      event.preventDefault()\n    }\n  })\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return\n    if (props.disabled) return\n    if (isWithinPanel) {\n      dispatch({ type: ActionTypes.ClosePopover })\n      state.button?.focus() // Re-focus the original opening Button\n    } else {\n      event.preventDefault()\n      event.stopPropagation()\n      if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId!)\n      dispatch({ type: ActionTypes.TogglePopover })\n      state.button?.focus()\n    }\n  })\n\n  let handleMouseDown = useEvent((event: ReactMouseEvent) => {\n    event.preventDefault()\n    event.stopPropagation()\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: props.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: props.disabled ?? false })\n\n  let visible = state.popoverState === PopoverStates.Open\n  let slot = useMemo(\n    () =>\n      ({\n        open: visible,\n        active: active || visible,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies ButtonRenderPropArg,\n    [visible, hover, focus, active, props.autoFocus]\n  )\n\n  let type = useResolveButtonType(props, internalButtonRef)\n  let ourProps = isWithinPanel\n    ? mergeProps(\n        {\n          ref: withinPanelButtonRef,\n          type,\n          onKeyDown: handleKeyDown,\n          onClick: handleClick,\n        },\n        focusProps,\n        hoverProps,\n        pressProps\n      )\n    : mergeProps(\n        {\n          ref: buttonRef,\n          id: state.buttonId,\n          type,\n          'aria-expanded': state.popoverState === PopoverStates.Open,\n          'aria-controls': state.panel ? state.panelId : undefined,\n          onKeyDown: handleKeyDown,\n          onKeyUp: handleKeyUp,\n          onClick: handleClick,\n          onMouseDown: handleMouseDown,\n        },\n        focusProps,\n        hoverProps,\n        pressProps\n      )\n\n  let direction = useTabDirection()\n  let handleFocus = useEvent(() => {\n    let el = state.panel as HTMLElement\n    if (!el) return\n\n    function run() {\n      let result = match(direction.current, {\n        [TabDirection.Forwards]: () => focusIn(el, Focus.First),\n        [TabDirection.Backwards]: () => focusIn(el, Focus.Last),\n      })\n\n      if (result === FocusResult.Error) {\n        focusIn(\n          getFocusableElements().filter((el) => el.dataset.headlessuiFocusGuard !== 'true'),\n          match(direction.current, {\n            [TabDirection.Forwards]: Focus.Next,\n            [TabDirection.Backwards]: Focus.Previous,\n          }),\n          { relativeTo: state.button }\n        )\n      }\n    }\n\n    // TODO: Cleanup once we are using real browser tests\n    if (process.env.NODE_ENV === 'test') {\n      microTask(run)\n    } else {\n      run()\n    }\n  })\n\n  return (\n    <>\n      {render({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_BUTTON_TAG,\n        name: 'Popover.Button',\n      })}\n      {visible && !isWithinPanel && isPortalled && (\n        <Hidden\n          id={sentinelId}\n          features={HiddenFeatures.Focusable}\n          data-headlessui-focus-guard\n          as=\"button\"\n          type=\"button\"\n          onFocus={handleFocus}\n        />\n      )}\n    </>\n  )\n}\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ntype OverlayRenderPropArg = {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'aria-hidden'\n\nlet OverlayRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type PopoverOverlayProps<TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG> = Props<\n  TTag,\n  OverlayRenderPropArg,\n  OverlayPropsWeControl,\n  PropsForFeatures<typeof OverlayRenderFeatures>\n>\n\nfunction OverlayFn<TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG>(\n  props: PopoverOverlayProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-popover-overlay-${internalId}`, ...theirProps } = props\n  let [{ popoverState }, dispatch] = usePopoverContext('Popover.Overlay')\n  let overlayRef = useSyncRefs(ref)\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return popoverState === PopoverStates.Open\n  })()\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    dispatch({ type: ActionTypes.ClosePopover })\n  })\n\n  let slot = useMemo(\n    () => ({ open: popoverState === PopoverStates.Open }) satisfies OverlayRenderPropArg,\n    [popoverState]\n  )\n\n  let ourProps = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    features: OverlayRenderFeatures,\n    visible,\n    name: 'Popover.Overlay',\n  })\n}\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ntype PanelRenderPropArg = {\n  open: boolean\n  close: (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => void\n}\n\nlet PanelRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\ntype PanelPropsWeControl = 'tabIndex'\n\nexport type PopoverPanelProps<TTag extends ElementType = typeof DEFAULT_PANEL_TAG> = Props<\n  TTag,\n  PanelRenderPropArg,\n  PanelPropsWeControl,\n  {\n    focus?: boolean\n    anchor?: AnchorProps\n    modal?: boolean\n\n    // ItemsRenderFeatures\n    static?: boolean\n    unmount?: boolean\n  }\n>\n\nfunction PanelFn<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: PopoverPanelProps<TTag>,\n  ref: Ref<HTMLDivElement>\n) {\n  let internalId = useId()\n  let {\n    id = `headlessui-popover-panel-${internalId}`,\n    focus = false,\n    anchor,\n    modal,\n    ...theirProps\n  } = props\n\n  let [state, dispatch] = usePopoverContext('Popover.Panel')\n  let { close, isPortalled } = usePopoverAPIContext('Popover.Panel')\n\n  let beforePanelSentinelId = `headlessui-focus-sentinel-before-${internalId}`\n  let afterPanelSentinelId = `headlessui-focus-sentinel-after-${internalId}`\n\n  let internalPanelRef = useRef<HTMLDivElement | null>(null)\n  let [floatingRef, style] = useFloatingPanel(anchor)\n  let getFloatingPanelProps = useFloatingPanelProps()\n\n  // Always use `modal` when `anchor` is passed in\n  if (anchor != null && modal == null) {\n    modal = true\n  } else if (modal == null) {\n    modal = false\n  }\n\n  let panelRef = useSyncRefs(internalPanelRef, ref, anchor ? floatingRef : null, (panel) => {\n    dispatch({ type: ActionTypes.SetPanel, panel })\n  })\n  let ownerDocument = useOwnerDocument(internalPanelRef)\n  let mergeRefs = useMergeRefsFn()\n\n  useIsoMorphicEffect(() => {\n    dispatch({ type: ActionTypes.SetPanelId, panelId: id })\n    return () => {\n      dispatch({ type: ActionTypes.SetPanelId, panelId: null })\n    }\n  }, [id, dispatch])\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return (usesOpenClosedState & State.Open) === State.Open\n    }\n\n    return state.popoverState === PopoverStates.Open\n  })()\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    switch (event.key) {\n      case Keys.Escape:\n        if (state.popoverState !== PopoverStates.Open) return\n        if (!internalPanelRef.current) return\n        if (\n          ownerDocument?.activeElement &&\n          !internalPanelRef.current.contains(ownerDocument.activeElement)\n        ) {\n          return\n        }\n        event.preventDefault()\n        event.stopPropagation()\n        dispatch({ type: ActionTypes.ClosePopover })\n        state.button?.focus()\n        break\n    }\n  })\n\n  // Unlink on \"unmount\" children\n  useEffect(() => {\n    if (props.static) return\n\n    if (state.popoverState === PopoverStates.Closed && (props.unmount ?? true)) {\n      dispatch({ type: ActionTypes.SetPanel, panel: null })\n    }\n  }, [state.popoverState, props.unmount, props.static, dispatch])\n\n  // Move focus within panel\n  useEffect(() => {\n    if (state.__demoMode) return\n    if (!focus) return\n    if (state.popoverState !== PopoverStates.Open) return\n    if (!internalPanelRef.current) return\n\n    let activeElement = ownerDocument?.activeElement as HTMLElement\n    if (internalPanelRef.current.contains(activeElement)) return // Already focused within Dialog\n\n    focusIn(internalPanelRef.current, Focus.First)\n  }, [state.__demoMode, focus, internalPanelRef, state.popoverState])\n\n  let slot = useMemo(\n    () => ({ open: state.popoverState === PopoverStates.Open, close }) satisfies PanelRenderPropArg,\n    [state, close]\n  )\n\n  let ourProps: Record<string, any> = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    ref: panelRef,\n    id,\n    onKeyDown: handleKeyDown,\n    onBlur:\n      focus && state.popoverState === PopoverStates.Open\n        ? (event: ReactFocusEvent) => {\n            let el = event.relatedTarget as HTMLElement\n            if (!el) return\n            if (!internalPanelRef.current) return\n            if (internalPanelRef.current?.contains(el)) return\n\n            dispatch({ type: ActionTypes.ClosePopover })\n\n            if (\n              state.beforePanelSentinel.current?.contains?.(el) ||\n              state.afterPanelSentinel.current?.contains?.(el)\n            ) {\n              el.focus({ preventScroll: true })\n            }\n          }\n        : undefined,\n    tabIndex: -1,\n    ...(style ? { style } : {}),\n  })\n\n  let direction = useTabDirection()\n  let handleBeforeFocus = useEvent(() => {\n    let el = internalPanelRef.current as HTMLElement\n    if (!el) return\n\n    function run() {\n      match(direction.current, {\n        [TabDirection.Forwards]: () => {\n          // Try to focus the first thing in the panel. But if that fails (e.g.: there are no\n          // focusable elements, then we can move outside of the panel)\n          let result = focusIn(el, Focus.First)\n          if (result === FocusResult.Error) {\n            state.afterPanelSentinel.current?.focus()\n          }\n        },\n        [TabDirection.Backwards]: () => {\n          // Coming from the Popover.Panel (which is portalled to somewhere else). Let's redirect\n          // the focus to the Popover.Button again.\n          state.button?.focus({ preventScroll: true })\n        },\n      })\n    }\n\n    // TODO: Cleanup once we are using real browser tests\n    if (process.env.NODE_ENV === 'test') {\n      microTask(run)\n    } else {\n      run()\n    }\n  })\n\n  let handleAfterFocus = useEvent(() => {\n    let el = internalPanelRef.current as HTMLElement\n    if (!el) return\n\n    function run() {\n      match(direction.current, {\n        [TabDirection.Forwards]: () => {\n          if (!state.button) return\n\n          let elements = getFocusableElements()\n\n          let idx = elements.indexOf(state.button)\n          let before = elements.slice(0, idx + 1)\n          let after = elements.slice(idx + 1)\n\n          let combined = [...after, ...before]\n\n          // Ignore sentinel buttons and items inside the panel\n          for (let element of combined.slice()) {\n            if (element.dataset.headlessuiFocusGuard === 'true' || state.panel?.contains(element)) {\n              let idx = combined.indexOf(element)\n              if (idx !== -1) combined.splice(idx, 1)\n            }\n          }\n\n          focusIn(combined, Focus.First, { sorted: false })\n        },\n        [TabDirection.Backwards]: () => {\n          // Try to focus the first thing in the panel. But if that fails (e.g.: there are no\n          // focusable elements, then we can move outside of the panel)\n          let result = focusIn(el, Focus.Previous)\n          if (result === FocusResult.Error) {\n            state.button?.focus()\n          }\n        },\n      })\n    }\n\n    // TODO: Cleanup once we are using real browser tests\n    if (process.env.NODE_ENV === 'test') {\n      microTask(run)\n    } else {\n      run()\n    }\n  })\n\n  let Wrapper = modal ? Modal : anchor ? Portal : Fragment\n  let wrapperProps = modal\n    ? ({\n        focusTrapFeatures: FocusTrapFeatures.None,\n        features: ModalRenderFeatures.ScrollLock,\n        enabled: state.popoverState === PopoverStates.Open,\n      } satisfies ModalProps)\n    : {}\n\n  if (Wrapper === Portal || Wrapper === Modal) {\n    isPortalled = true\n  }\n\n  return (\n    <PopoverPanelContext.Provider value={id}>\n      <PopoverAPIContext.Provider value={{ close, isPortalled }}>\n        <Wrapper {...wrapperProps}>\n          {visible && isPortalled && (\n            <Hidden\n              id={beforePanelSentinelId}\n              ref={state.beforePanelSentinel}\n              features={HiddenFeatures.Focusable}\n              data-headlessui-focus-guard\n              as=\"button\"\n              type=\"button\"\n              onFocus={handleBeforeFocus}\n            />\n          )}\n          {render({\n            mergeRefs,\n            ourProps,\n            theirProps,\n            slot,\n            defaultTag: DEFAULT_PANEL_TAG,\n            features: PanelRenderFeatures,\n            visible,\n            name: 'Popover.Panel',\n          })}\n          {visible && isPortalled && (\n            <Hidden\n              id={afterPanelSentinelId}\n              ref={state.afterPanelSentinel}\n              features={HiddenFeatures.Focusable}\n              data-headlessui-focus-guard\n              as=\"button\"\n              type=\"button\"\n              onFocus={handleAfterFocus}\n            />\n          )}\n        </Wrapper>\n      </PopoverAPIContext.Provider>\n    </PopoverPanelContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_GROUP_TAG = 'div' as const\ntype GroupRenderPropArg = {}\ntype GroupPropsWeControl = never\n\nexport type PopoverGroupProps<TTag extends ElementType = typeof DEFAULT_GROUP_TAG> = Props<\n  TTag,\n  GroupRenderPropArg,\n  GroupPropsWeControl\n>\n\nfunction GroupFn<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n  props: PopoverGroupProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalGroupRef = useRef<HTMLElement | null>(null)\n  let groupRef = useSyncRefs(internalGroupRef, ref)\n  let [popovers, setPopovers] = useState<PopoverRegisterBag[]>([])\n  let root = useMainTreeNode()\n\n  let unregisterPopover = useEvent((registerbag: PopoverRegisterBag) => {\n    setPopovers((existing) => {\n      let idx = existing.indexOf(registerbag)\n      if (idx !== -1) {\n        let clone = existing.slice()\n        clone.splice(idx, 1)\n        return clone\n      }\n      return existing\n    })\n  })\n\n  let registerPopover = useEvent((registerbag: PopoverRegisterBag) => {\n    setPopovers((existing) => [...existing, registerbag])\n    return () => unregisterPopover(registerbag)\n  })\n\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    let ownerDocument = getOwnerDocument(internalGroupRef)\n    if (!ownerDocument) return false\n    let element = ownerDocument.activeElement\n\n    if (internalGroupRef.current?.contains(element)) return true\n\n    // Check if the focus is in one of the button or panel elements. This is important in case you are rendering inside a Portal.\n    return popovers.some((bag) => {\n      return (\n        ownerDocument!.getElementById(bag.buttonId.current!)?.contains(element) ||\n        ownerDocument!.getElementById(bag.panelId.current!)?.contains(element)\n      )\n    })\n  })\n\n  let closeOthers = useEvent((buttonId: string) => {\n    for (let popover of popovers) {\n      if (popover.buttonId.current !== buttonId) popover.close()\n    }\n  })\n\n  let contextBag = useMemo<ContextType<typeof PopoverGroupContext>>(\n    () => ({\n      registerPopover: registerPopover,\n      unregisterPopover: unregisterPopover,\n      isFocusWithinPopoverGroup,\n      closeOthers,\n      mainTreeNodeRef: root.mainTreeNodeRef,\n    }),\n    [\n      registerPopover,\n      unregisterPopover,\n      isFocusWithinPopoverGroup,\n      closeOthers,\n      root.mainTreeNodeRef,\n    ]\n  )\n\n  let slot = useMemo(() => ({}) satisfies GroupRenderPropArg, [])\n\n  let theirProps = props\n  let ourProps = { ref: groupRef }\n\n  return (\n    <PopoverGroupContext.Provider value={contextBag}>\n      {render({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n      <root.MainTreeNode />\n    </PopoverGroupContext.Provider>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentPopover extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_POPOVER_TAG>(\n    props: PopoverProps<TTag> & RefProp<typeof PopoverFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentPopoverButton extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n    props: PopoverButtonProps<TTag> & RefProp<typeof ButtonFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentPopoverOverlay extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG>(\n    props: PopoverOverlayProps<TTag> & RefProp<typeof OverlayFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentPopoverPanel extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n    props: PopoverPanelProps<TTag> & RefProp<typeof PanelFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentPopoverGroup extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n    props: PopoverGroupProps<TTag> & RefProp<typeof GroupFn>\n  ): JSX.Element\n}\n\nlet PopoverRoot = forwardRefWithAs(PopoverFn) as unknown as _internal_ComponentPopover\nexport let PopoverButton = forwardRefWithAs(ButtonFn) as unknown as _internal_ComponentPopoverButton\nexport let PopoverOverlay = forwardRefWithAs(\n  OverlayFn\n) as unknown as _internal_ComponentPopoverOverlay\nexport let PopoverPanel = forwardRefWithAs(PanelFn) as unknown as _internal_ComponentPopoverPanel\nexport let PopoverGroup = forwardRefWithAs(GroupFn) as unknown as _internal_ComponentPopoverGroup\n\nexport let Popover = Object.assign(PopoverRoot, {\n  Button: PopoverButton,\n  Overlay: PopoverOverlay,\n  Panel: PopoverPanel,\n  Group: PopoverGroup,\n})\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  type ElementType,\n  type MutableRefObject,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useByComparator, type ByComparator } from '../../hooks/use-by-comparator'\nimport { useControllable } from '../../hooks/use-controllable'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useDisabled } from '../../internal/disabled'\nimport { FormFields } from '../../internal/form-fields'\nimport { useProvidedId } from '../../internal/id'\nimport type { Expand, Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { Focus, FocusResult, focusIn, sortByDomNode } from '../../utils/focus-management'\nimport { attemptSubmit } from '../../utils/form'\nimport { match } from '../../utils/match'\nimport { getOwnerDocument } from '../../utils/owner'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport {\n  Description,\n  useDescribedBy,\n  useDescriptions,\n  type _internal_ComponentDescription,\n} from '../description/description'\nimport { Keys } from '../keyboard'\nimport { Label, useLabelledBy, useLabels, type _internal_ComponentLabel } from '../label/label'\n\ninterface Option<T = unknown> {\n  id: string\n  element: MutableRefObject<HTMLElement | null>\n  propsRef: MutableRefObject<{ value: T; disabled: boolean }>\n}\n\ninterface StateDefinition<T = unknown> {\n  options: Option<T>[]\n}\n\nenum ActionTypes {\n  RegisterOption,\n  UnregisterOption,\n}\n\ntype Actions =\n  | Expand<{ type: ActionTypes.RegisterOption } & Option>\n  | { type: ActionTypes.UnregisterOption; id: Option['id'] }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.RegisterOption](state, action) {\n    let nextOptions = [\n      ...state.options,\n      { id: action.id, element: action.element, propsRef: action.propsRef },\n    ]\n\n    return {\n      ...state,\n      options: sortByDomNode(nextOptions, (option) => option.element.current),\n    }\n  },\n  [ActionTypes.UnregisterOption](state, action) {\n    let options = state.options.slice()\n    let idx = state.options.findIndex((radio) => radio.id === action.id)\n    if (idx === -1) return state\n    options.splice(idx, 1)\n    return { ...state, options }\n  },\n}\n\nlet RadioGroupDataContext = createContext<\n  | ({\n      value: unknown\n      firstOption?: Option\n      containsCheckedOption: boolean\n      disabled: boolean\n      compare(a: unknown, z: unknown): boolean\n    } & StateDefinition)\n  | null\n>(null)\nRadioGroupDataContext.displayName = 'RadioGroupDataContext'\n\nfunction useData(component: string) {\n  let context = useContext(RadioGroupDataContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <RadioGroup /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useData)\n    throw err\n  }\n  return context\n}\ntype _Data = ReturnType<typeof useData>\n\nlet RadioGroupActionsContext = createContext<{\n  registerOption(option: Option): () => void\n  change(value: unknown): boolean\n} | null>(null)\nRadioGroupActionsContext.displayName = 'RadioGroupActionsContext'\n\nfunction useActions(component: string) {\n  let context = useContext(RadioGroupActionsContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <RadioGroup /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useActions)\n    throw err\n  }\n  return context\n}\ntype _Actions = ReturnType<typeof useActions>\n\nfunction stateReducer<T>(state: StateDefinition<T>, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_RADIO_GROUP_TAG = 'div' as const\ntype RadioGroupRenderPropArg<TType> = {\n  value: TType\n}\ntype RadioGroupPropsWeControl = 'role' | 'aria-labelledby' | 'aria-describedby'\n\nexport type RadioGroupProps<\n  TTag extends ElementType = typeof DEFAULT_RADIO_GROUP_TAG,\n  TType = string,\n> = Props<\n  TTag,\n  RadioGroupRenderPropArg<TType>,\n  RadioGroupPropsWeControl,\n  {\n    value?: TType\n    defaultValue?: TType\n    onChange?(value: TType): void\n    by?: ByComparator<TType>\n    disabled?: boolean\n    form?: string\n    name?: string\n  }\n>\n\nfunction RadioGroupFn<TTag extends ElementType = typeof DEFAULT_RADIO_GROUP_TAG, TType = string>(\n  props: RadioGroupProps<TTag, TType>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let providedDisabled = useDisabled()\n  let {\n    id = `headlessui-radiogroup-${internalId}`,\n    value: controlledValue,\n    defaultValue,\n    form,\n    name,\n    onChange: controlledOnChange,\n    by,\n    disabled = providedDisabled || false,\n    ...theirProps\n  } = props\n\n  let compare = useByComparator(by)\n  let [state, dispatch] = useReducer(stateReducer, { options: [] } as StateDefinition<TType>)\n  let options = state.options as unknown as Option<TType>[]\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n  let internalRadioGroupRef = useRef<HTMLElement | null>(null)\n  let radioGroupRef = useSyncRefs(internalRadioGroupRef, ref)\n\n  let [value, onChange] = useControllable(controlledValue, controlledOnChange, defaultValue)\n\n  let firstOption = useMemo(\n    () =>\n      options.find((option) => {\n        if (option.propsRef.current.disabled) return false\n        return true\n      }),\n    [options]\n  )\n  let containsCheckedOption = useMemo(\n    () => options.some((option) => compare(option.propsRef.current.value as TType, value)),\n    [options, value]\n  )\n\n  let triggerChange = useEvent((nextValue: TType) => {\n    if (disabled) return false\n    if (compare(nextValue, value)) return false\n    let nextOption = options.find((option) =>\n      compare(option.propsRef.current.value as TType, nextValue)\n    )?.propsRef.current\n    if (nextOption?.disabled) return false\n\n    onChange?.(nextValue)\n\n    return true\n  })\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    let container = internalRadioGroupRef.current\n    if (!container) return\n\n    let ownerDocument = getOwnerDocument(container)\n\n    let all = options\n      .filter((option) => option.propsRef.current.disabled === false)\n      .map((radio) => radio.element.current) as HTMLElement[]\n\n    switch (event.key) {\n      case Keys.Enter:\n        attemptSubmit(event.currentTarget)\n        break\n      case Keys.ArrowLeft:\n      case Keys.ArrowUp:\n        {\n          event.preventDefault()\n          event.stopPropagation()\n\n          let result = focusIn(all, Focus.Previous | Focus.WrapAround)\n\n          if (result === FocusResult.Success) {\n            let activeOption = options.find(\n              (option) => option.element.current === ownerDocument?.activeElement\n            )\n            if (activeOption) triggerChange(activeOption.propsRef.current.value)\n          }\n        }\n        break\n\n      case Keys.ArrowRight:\n      case Keys.ArrowDown:\n        {\n          event.preventDefault()\n          event.stopPropagation()\n\n          let result = focusIn(all, Focus.Next | Focus.WrapAround)\n\n          if (result === FocusResult.Success) {\n            let activeOption = options.find(\n              (option) => option.element.current === ownerDocument?.activeElement\n            )\n            if (activeOption) triggerChange(activeOption.propsRef.current.value)\n          }\n        }\n        break\n\n      case Keys.Space:\n        {\n          event.preventDefault()\n          event.stopPropagation()\n\n          let activeOption = options.find(\n            (option) => option.element.current === ownerDocument?.activeElement\n          )\n          if (activeOption) triggerChange(activeOption.propsRef.current.value)\n        }\n        break\n    }\n  })\n\n  let registerOption = useEvent((option: Option) => {\n    dispatch({ type: ActionTypes.RegisterOption, ...option })\n    return () => dispatch({ type: ActionTypes.UnregisterOption, id: option.id })\n  })\n\n  let radioGroupData = useMemo<_Data>(\n    () => ({ value, firstOption, containsCheckedOption, disabled, compare, ...state }),\n    [value, firstOption, containsCheckedOption, disabled, compare, state]\n  )\n  let radioGroupActions = useMemo<_Actions>(\n    () => ({ registerOption, change: triggerChange }),\n    [registerOption, triggerChange]\n  )\n\n  let ourProps = {\n    ref: radioGroupRef,\n    id,\n    role: 'radiogroup',\n    'aria-labelledby': labelledby,\n    'aria-describedby': describedby,\n    onKeyDown: handleKeyDown,\n  }\n\n  let slot = useMemo(() => ({ value }) satisfies RadioGroupRenderPropArg<TType>, [value])\n\n  let reset = useCallback(() => {\n    return triggerChange(defaultValue!)\n  }, [triggerChange /* Explicitly ignoring `defaultValue` */])\n\n  return (\n    <DescriptionProvider name=\"RadioGroup.Description\">\n      <LabelProvider name=\"RadioGroup.Label\">\n        <RadioGroupActionsContext.Provider value={radioGroupActions}>\n          <RadioGroupDataContext.Provider value={radioGroupData}>\n            {name != null && (\n              <FormFields\n                data={value != null ? { [name]: value || 'on' } : {}}\n                form={form}\n                onReset={reset}\n              />\n            )}\n\n            {render({\n              ourProps,\n              theirProps,\n              slot,\n              defaultTag: DEFAULT_RADIO_GROUP_TAG,\n              name: 'RadioGroup',\n            })}\n          </RadioGroupDataContext.Provider>\n        </RadioGroupActionsContext.Provider>\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_OPTION_TAG = 'div' as const\ntype OptionRenderPropArg = {\n  checked: boolean\n  /** @deprecated use `focus` instead */\n  active: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n  disabled: boolean\n}\ntype OptionPropsWeControl =\n  | 'aria-checked'\n  | 'aria-describedby'\n  | 'aria-labelledby'\n  | 'role'\n  | 'tabIndex'\n\nexport type RadioOptionProps<TTag extends ElementType, TType> = Props<\n  TTag,\n  OptionRenderPropArg,\n  OptionPropsWeControl,\n  {\n    value: TType\n    disabled?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction OptionFn<\n  TTag extends ElementType = typeof DEFAULT_OPTION_TAG,\n  // TODO: One day we will be able to infer this type from the generic in RadioGroup itself.\n  // But today is not that day..\n  TType = Parameters<typeof RadioGroupRoot>[0]['value'],\n>(props: RadioOptionProps<TTag, TType>, ref: Ref<HTMLElement>) {\n  let internalId = useId()\n  let {\n    id = `headlessui-radiogroup-option-${internalId}`,\n    value,\n    disabled = false,\n    ...theirProps\n  } = props\n  let internalOptionRef = useRef<HTMLElement | null>(null)\n  let optionRef = useSyncRefs(internalOptionRef, ref)\n\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let propsRef = useLatestValue({ value, disabled })\n\n  let data = useData('RadioGroup.Option')\n  let actions = useActions('RadioGroup.Option')\n\n  useIsoMorphicEffect(\n    () => actions.registerOption({ id, element: internalOptionRef, propsRef }),\n    [id, actions, internalOptionRef, propsRef]\n  )\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    if (!actions.change(value)) return\n    internalOptionRef.current?.focus()\n  })\n\n  let isFirstOption = data.firstOption?.id === id\n  let isDisabled = data.disabled || disabled\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: isDisabled ?? false })\n\n  let checked = data.compare(data.value as TType, value)\n  let ourProps = mergeProps(\n    {\n      ref: optionRef,\n      id,\n      role: 'radio',\n      'aria-checked': checked ? 'true' : 'false',\n      'aria-labelledby': labelledby,\n      'aria-describedby': describedby,\n      'aria-disabled': isDisabled ? true : undefined,\n      tabIndex: (() => {\n        if (isDisabled) return -1\n        if (checked) return 0\n        if (!data.containsCheckedOption && isFirstOption) return 0\n        return -1\n      })(),\n      onClick: isDisabled ? undefined : handleClick,\n    },\n    focusProps,\n    hoverProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        checked,\n        disabled: isDisabled,\n        active: focus,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies OptionRenderPropArg,\n    [checked, isDisabled, hover, focus, props.autoFocus]\n  )\n\n  return (\n    <DescriptionProvider name=\"RadioGroup.Description\">\n      <LabelProvider name=\"RadioGroup.Label\">\n        {render({\n          ourProps,\n          theirProps,\n          slot,\n          defaultTag: DEFAULT_OPTION_TAG,\n          name: 'RadioGroup.Option',\n        })}\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_RADIO_TAG = 'span' as const\ntype RadioRenderPropArg = {\n  checked: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n  disabled: boolean\n}\ntype RadioPropsWeControl =\n  | 'aria-checked'\n  | 'aria-describedby'\n  | 'aria-labelledby'\n  | 'role'\n  | 'tabIndex'\n\nexport type RadioProps<TTag extends ElementType = typeof DEFAULT_RADIO_TAG, TType = string> = Props<\n  TTag,\n  RadioRenderPropArg,\n  RadioPropsWeControl,\n  {\n    value: TType\n    disabled?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction RadioFn<\n  TTag extends ElementType = typeof DEFAULT_RADIO_TAG,\n  // TODO: One day we will be able to infer this type from the generic in RadioGroup itself.\n  // But today is not that day..\n  TType = Parameters<typeof RadioGroupRoot>[0]['value'],\n>(props: RadioProps<TTag, TType>, ref: Ref<HTMLElement>) {\n  let data = useData('Radio')\n  let actions = useActions('Radio')\n\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-radio-${internalId}`,\n    value,\n    disabled = data.disabled || providedDisabled || false,\n    ...theirProps\n  } = props\n  let internalRadioRef = useRef<HTMLElement | null>(null)\n  let radioRef = useSyncRefs(internalRadioRef, ref)\n\n  let labelledby = useLabelledBy()\n  let describedby = useDescribedBy()\n\n  let propsRef = useLatestValue({ value, disabled })\n\n  useIsoMorphicEffect(\n    () => actions.registerOption({ id, element: internalRadioRef, propsRef }),\n    [id, actions, internalRadioRef, propsRef]\n  )\n\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    if (!actions.change(value)) return\n\n    internalRadioRef.current?.focus()\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n\n  let isFirstOption = data.firstOption?.id === id\n\n  let checked = data.compare(data.value as TType, value)\n  let ourProps = mergeProps(\n    {\n      ref: radioRef,\n      id,\n      role: 'radio',\n      'aria-checked': checked ? 'true' : 'false',\n      'aria-labelledby': labelledby,\n      'aria-describedby': describedby,\n      'aria-disabled': disabled ? true : undefined,\n      tabIndex: (() => {\n        if (disabled) return -1\n        if (checked) return 0\n        if (!data.containsCheckedOption && isFirstOption) return 0\n        return -1\n      })(),\n      onClick: disabled ? undefined : handleClick,\n    },\n    focusProps,\n    hoverProps\n  )\n  let slot = useMemo(\n    () =>\n      ({\n        checked,\n        disabled,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies RadioRenderPropArg,\n    [checked, disabled, hover, focus, props.autoFocus]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_RADIO_TAG,\n    name: 'Radio',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentRadioGroup extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_RADIO_GROUP_TAG, TType = string>(\n    props: RadioGroupProps<TTag, TType> & RefProp<typeof RadioGroupFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentRadioOption extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_OPTION_TAG, TType = string>(\n    props: RadioOptionProps<TTag, TType> & RefProp<typeof OptionFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentRadio extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_RADIO_TAG, TType = string>(\n    props: RadioProps<TTag, TType> & RefProp<typeof RadioFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentRadioLabel extends _internal_ComponentLabel {}\nexport interface _internal_ComponentRadioDescription extends _internal_ComponentDescription {}\n\nlet RadioGroupRoot = forwardRefWithAs(RadioGroupFn) as unknown as _internal_ComponentRadioGroup\nexport let RadioGroupOption = forwardRefWithAs(\n  OptionFn\n) as unknown as _internal_ComponentRadioOption\nexport let Radio = forwardRefWithAs(RadioFn) as unknown as _internal_ComponentRadio\n/** @deprecated use `<Label>` instead of `<RadioGroupLabel>` */\nexport let RadioGroupLabel = Label as _internal_ComponentRadioLabel\n/** @deprecated use `<Description>` instead of `<RadioGroupDescription>` */\nexport let RadioGroupDescription = Description as _internal_ComponentRadioDescription\n\nexport let RadioGroup = Object.assign(RadioGroupRoot, {\n  Option: RadioGroupOption,\n  /** @deprecated use `<Label>` instead of `<RadioGroup.Label>` */\n  Label: RadioGroupLabel,\n  /** @deprecated use `<Description>` instead of `<RadioGroup.Description>` */\n  Description: RadioGroupDescription,\n})\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { useMemo, type ElementType, type Ref } from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useId } from '../../hooks/use-id'\nimport { useDisabled } from '../../internal/disabled'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { useLabelledBy } from '../label/label'\n\nlet DEFAULT_SELECT_TAG = 'select' as const\n\ntype SelectRenderPropArg = {\n  disabled: boolean\n  hover: boolean\n  focus: boolean\n  active: boolean\n  autofocus: boolean\n  invalid: boolean\n}\ntype SelectPropsWeControl = 'aria-labelledby' | 'aria-describedby'\n\nexport type SelectProps<TTag extends ElementType = typeof DEFAULT_SELECT_TAG> = Props<\n  TTag,\n  SelectRenderPropArg,\n  SelectPropsWeControl,\n  {\n    disabled?: boolean\n    invalid?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction SelectFn<TTag extends ElementType = typeof DEFAULT_SELECT_TAG>(\n  props: SelectProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-select-${internalId}`,\n    disabled = providedDisabled || false,\n    invalid = false,\n    ...theirProps\n  } = props\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: disabled ?? false })\n\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      'aria-invalid': invalid ? '' : undefined,\n      disabled: disabled || undefined,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        disabled,\n        invalid,\n        hover,\n        focus,\n        active,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies SelectRenderPropArg,\n    [disabled, invalid, hover, focus, active, props.autoFocus]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_SELECT_TAG,\n    name: 'Select',\n  })\n}\n\nexport interface _internal_ComponentSelect extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_SELECT_TAG>(\n    props: SelectProps<TTag> & RefProp<typeof SelectFn>\n  ): JSX.Element\n}\n\nexport let Select = forwardRefWithAs(SelectFn) as unknown as _internal_ComponentSelect\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n  type ElementType,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useControllable } from '../../hooks/use-controllable'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useDisabled } from '../../internal/disabled'\nimport { FormFields } from '../../internal/form-fields'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport { attemptSubmit } from '../../utils/form'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport {\n  Description,\n  useDescribedBy,\n  useDescriptions,\n  type _internal_ComponentDescription,\n} from '../description/description'\nimport { Keys } from '../keyboard'\nimport { Label, useLabelledBy, useLabels, type _internal_ComponentLabel } from '../label/label'\n\ninterface StateDefinition {\n  switch: HTMLButtonElement | null\n  setSwitch(element: HTMLButtonElement): void\n}\n\nlet GroupContext = createContext<StateDefinition | null>(null)\nGroupContext.displayName = 'GroupContext'\n\n// ---\n\nlet DEFAULT_GROUP_TAG = Fragment\n\nexport type SwitchGroupProps<TTag extends ElementType = typeof DEFAULT_GROUP_TAG> = Props<TTag>\n\nfunction GroupFn<TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n  props: SwitchGroupProps<TTag>\n) {\n  let [switchElement, setSwitchElement] = useState<HTMLButtonElement | null>(null)\n  let [labelledby, LabelProvider] = useLabels()\n  let [describedby, DescriptionProvider] = useDescriptions()\n\n  let context = useMemo<StateDefinition>(\n    () => ({ switch: switchElement, setSwitch: setSwitchElement }),\n    [switchElement, setSwitchElement]\n  )\n\n  let ourProps = {}\n  let theirProps = props\n\n  return (\n    <DescriptionProvider name=\"Switch.Description\" value={describedby}>\n      <LabelProvider\n        name=\"Switch.Label\"\n        value={labelledby}\n        props={{\n          htmlFor: context.switch?.id,\n          onClick(event: React.MouseEvent<HTMLLabelElement>) {\n            if (!switchElement) return\n            if (event.currentTarget instanceof HTMLLabelElement) {\n              event.preventDefault()\n            }\n            switchElement.click()\n            switchElement.focus({ preventScroll: true })\n          },\n        }}\n      >\n        <GroupContext.Provider value={context}>\n          {render({\n            ourProps,\n            theirProps,\n            slot: {},\n            defaultTag: DEFAULT_GROUP_TAG,\n            name: 'Switch.Group',\n          })}\n        </GroupContext.Provider>\n      </LabelProvider>\n    </DescriptionProvider>\n  )\n}\n\n// ---\n\nlet DEFAULT_SWITCH_TAG = 'button' as const\ntype SwitchRenderPropArg = {\n  checked: boolean\n  hover: boolean\n  focus: boolean\n  active: boolean\n  autofocus: boolean\n  changing: boolean\n  disabled: boolean\n}\ntype SwitchPropsWeControl =\n  | 'aria-checked'\n  | 'aria-describedby'\n  | 'aria-labelledby'\n  | 'role'\n  | 'tabIndex'\n\nexport type SwitchProps<TTag extends ElementType = typeof DEFAULT_SWITCH_TAG> = Props<\n  TTag,\n  SwitchRenderPropArg,\n  SwitchPropsWeControl,\n  {\n    checked?: boolean\n    defaultChecked?: boolean\n    onChange?(checked: boolean): void\n    name?: string\n    value?: string\n    form?: string\n    autoFocus?: boolean\n    disabled?: boolean\n  }\n>\n\nfunction SwitchFn<TTag extends ElementType = typeof DEFAULT_SWITCH_TAG>(\n  props: SwitchProps<TTag>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-switch-${internalId}`,\n    disabled = providedDisabled || false,\n    checked: controlledChecked,\n    defaultChecked = false,\n    onChange: controlledOnChange,\n    name,\n    value,\n    form,\n    ...theirProps\n  } = props\n  let groupContext = useContext(GroupContext)\n  let internalSwitchRef = useRef<HTMLButtonElement | null>(null)\n  let switchRef = useSyncRefs(\n    internalSwitchRef,\n    ref,\n    groupContext === null ? null : groupContext.setSwitch\n  )\n\n  let [checked, onChange] = useControllable(controlledChecked, controlledOnChange, defaultChecked)\n\n  let d = useDisposables()\n  let [changing, setChanging] = useState(false)\n  let toggle = useEvent(() => {\n    setChanging(true)\n    onChange?.(!checked)\n\n    d.nextFrame(() => {\n      setChanging(false)\n    })\n  })\n  let handleClick = useEvent((event: ReactMouseEvent) => {\n    if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n    event.preventDefault()\n    toggle()\n  })\n  let handleKeyUp = useEvent((event: ReactKeyboardEvent<HTMLButtonElement>) => {\n    if (event.key === Keys.Space) {\n      event.preventDefault()\n      toggle()\n    } else if (event.key === Keys.Enter) {\n      attemptSubmit(event.currentTarget)\n    }\n  })\n\n  // This is needed so that we can \"cancel\" the click event when we use the `Enter` key on a button.\n  let handleKeyPress = useEvent((event: ReactKeyboardEvent<HTMLElement>) => event.preventDefault())\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        checked,\n        disabled,\n        hover,\n        focus,\n        active,\n        autofocus: props.autoFocus ?? false,\n        changing,\n      }) satisfies SwitchRenderPropArg,\n    [checked, hover, focus, active, disabled, changing, props.autoFocus]\n  )\n\n  let ourProps = mergeProps(\n    {\n      id,\n      ref: switchRef,\n      role: 'switch',\n      type: useResolveButtonType(props, internalSwitchRef),\n      tabIndex: 0,\n      'aria-checked': checked,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      disabled,\n      onClick: handleClick,\n      onKeyUp: handleKeyUp,\n      onKeyPress: handleKeyPress,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  let reset = useCallback(() => {\n    return onChange?.(defaultChecked)\n  }, [onChange /* Explicitly ignoring `defaultChecked` */])\n\n  return (\n    <>\n      {name != null && (\n        <FormFields data={checked ? { [name]: value || 'on' } : {}} form={form} onReset={reset} />\n      )}\n      {render({ ourProps, theirProps, slot, defaultTag: DEFAULT_SWITCH_TAG, name: 'Switch' })}\n    </>\n  )\n}\n\n// ---\n\nexport interface _internal_ComponentSwitch extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_SWITCH_TAG>(\n    props: SwitchProps<TTag> & RefProp<typeof SwitchFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentSwitchGroup extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_GROUP_TAG>(\n    props: SwitchGroupProps<TTag> & RefProp<typeof GroupFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentSwitchLabel extends _internal_ComponentLabel {}\nexport interface _internal_ComponentSwitchDescription extends _internal_ComponentDescription {}\n\nlet SwitchRoot = forwardRefWithAs(SwitchFn) as unknown as _internal_ComponentSwitch\nexport let SwitchGroup = GroupFn as unknown as _internal_ComponentSwitchGroup\n/** @deprecated use `<Label>` instead of `<SwitchLabel>` */\nexport let SwitchLabel = Label as _internal_ComponentSwitchLabel\n/** @deprecated use `<Description>` instead of `<SwitchDescription>` */\nexport let SwitchDescription = Description as _internal_ComponentSwitchDescription\n\nexport let Switch = Object.assign(SwitchRoot, {\n  Group: SwitchGroup,\n  /** @deprecated use `<Label>` instead of `<Switch.Label>` */\n  Label: SwitchLabel,\n  /** @deprecated use `<Description>` instead of `<Switch.Description>` */\n  Description: SwitchDescription,\n})\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport React, {\n  Fragment,\n  createContext,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  type ElementType,\n  type MutableRefObject,\n  type KeyboardEvent as ReactKeyboardEvent,\n  type MouseEvent as ReactMouseEvent,\n  type Ref,\n} from 'react'\nimport { useActivePress } from '../../hooks/use-active-press'\nimport { useEvent } from '../../hooks/use-event'\nimport { useId } from '../../hooks/use-id'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { FocusSentinel } from '../../internal/focus-sentinel'\nimport { Hidden } from '../../internal/hidden'\nimport type { Props } from '../../types'\nimport { Focus, FocusResult, focusIn, sortByDomNode } from '../../utils/focus-management'\nimport { match } from '../../utils/match'\nimport { microTask } from '../../utils/micro-task'\nimport { getOwnerDocument } from '../../utils/owner'\nimport {\n  RenderFeatures,\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\nimport { StableCollection, useStableCollectionIndex } from '../../utils/stable-collection'\nimport { Keys } from '../keyboard'\n\nenum Direction {\n  Forwards,\n  Backwards,\n}\n\nenum Ordering {\n  Less = -1,\n  Equal = 0,\n  Greater = 1,\n}\n\ninterface StateDefinition {\n  selectedIndex: number\n\n  tabs: MutableRefObject<HTMLElement | null>[]\n  panels: MutableRefObject<HTMLElement | null>[]\n}\n\nenum ActionTypes {\n  SetSelectedIndex,\n\n  RegisterTab,\n  UnregisterTab,\n\n  RegisterPanel,\n  UnregisterPanel,\n}\n\ntype Actions =\n  | { type: ActionTypes.SetSelectedIndex; index: number }\n  | { type: ActionTypes.RegisterTab; tab: MutableRefObject<HTMLElement | null> }\n  | { type: ActionTypes.UnregisterTab; tab: MutableRefObject<HTMLElement | null> }\n  | { type: ActionTypes.RegisterPanel; panel: MutableRefObject<HTMLElement | null> }\n  | { type: ActionTypes.UnregisterPanel; panel: MutableRefObject<HTMLElement | null> }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.SetSelectedIndex](state, action) {\n    let tabs = sortByDomNode(state.tabs, (tab) => tab.current)\n    let panels = sortByDomNode(state.panels, (panel) => panel.current)\n\n    let focusableTabs = tabs.filter((tab) => !tab.current?.hasAttribute('disabled'))\n\n    let nextState = { ...state, tabs, panels }\n\n    if (\n      // Underflow\n      action.index < 0 ||\n      // Overflow\n      action.index > tabs.length - 1\n    ) {\n      let direction = match(Math.sign(action.index - state.selectedIndex), {\n        [Ordering.Less]: () => Direction.Backwards,\n        [Ordering.Equal]: () => {\n          return match(Math.sign(action.index), {\n            [Ordering.Less]: () => Direction.Forwards,\n            [Ordering.Equal]: () => Direction.Forwards,\n            [Ordering.Greater]: () => Direction.Backwards,\n          })\n        },\n        [Ordering.Greater]: () => Direction.Forwards,\n      })\n\n      // If there are no focusable tabs then.\n      // We won't change the selected index\n      // because it's likely the user is\n      // lazy loading tabs and there's\n      // nothing to focus on yet\n      if (focusableTabs.length === 0) {\n        return nextState\n      }\n\n      let nextSelectedIndex = match(direction, {\n        [Direction.Forwards]: () => tabs.indexOf(focusableTabs[0]),\n        [Direction.Backwards]: () => tabs.indexOf(focusableTabs[focusableTabs.length - 1]),\n      })\n\n      return {\n        ...nextState,\n        selectedIndex: nextSelectedIndex === -1 ? state.selectedIndex : nextSelectedIndex,\n      }\n    }\n\n    // Middle\n    let before = tabs.slice(0, action.index)\n    let after = tabs.slice(action.index)\n\n    let next = [...after, ...before].find((tab) => focusableTabs.includes(tab))\n    if (!next) return nextState\n\n    let selectedIndex = tabs.indexOf(next) ?? state.selectedIndex\n    if (selectedIndex === -1) selectedIndex = state.selectedIndex\n\n    return { ...nextState, selectedIndex }\n  },\n  [ActionTypes.RegisterTab](state, action) {\n    if (state.tabs.includes(action.tab)) return state\n    let activeTab = state.tabs[state.selectedIndex]\n\n    let adjustedTabs = sortByDomNode([...state.tabs, action.tab], (tab) => tab.current)\n    let selectedIndex = adjustedTabs.indexOf(activeTab) ?? state.selectedIndex\n    if (selectedIndex === -1) selectedIndex = state.selectedIndex\n\n    return { ...state, tabs: adjustedTabs, selectedIndex }\n  },\n  [ActionTypes.UnregisterTab](state, action) {\n    return { ...state, tabs: state.tabs.filter((tab) => tab !== action.tab) }\n  },\n  [ActionTypes.RegisterPanel](state, action) {\n    if (state.panels.includes(action.panel)) return state\n    return {\n      ...state,\n      panels: sortByDomNode([...state.panels, action.panel], (panel) => panel.current),\n    }\n  },\n  [ActionTypes.UnregisterPanel](state, action) {\n    return { ...state, panels: state.panels.filter((panel) => panel !== action.panel) }\n  },\n}\n\nlet TabsDataContext = createContext<\n  | ({\n      orientation: 'horizontal' | 'vertical'\n      activation: 'auto' | 'manual'\n    } & StateDefinition)\n  | null\n>(null)\nTabsDataContext.displayName = 'TabsDataContext'\n\nfunction useData(component: string) {\n  let context = useContext(TabsDataContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useData)\n    throw err\n  }\n  return context\n}\ntype _Data = ReturnType<typeof useData>\n\nlet TabsActionsContext = createContext<{\n  registerTab(tab: MutableRefObject<HTMLElement | null>): () => void\n  registerPanel(panel: MutableRefObject<HTMLElement | null>): () => void\n  change(index: number): void\n} | null>(null)\nTabsActionsContext.displayName = 'TabsActionsContext'\n\nfunction useActions(component: string) {\n  let context = useContext(TabsActionsContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, useActions)\n    throw err\n  }\n  return context\n}\ntype _Actions = ReturnType<typeof useActions>\n\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_TABS_TAG = Fragment\ntype TabsRenderPropArg = {\n  selectedIndex: number\n}\ntype TabsPropsWeControl = never\n\nexport type TabGroupProps<TTag extends ElementType = typeof DEFAULT_TABS_TAG> = Props<\n  TTag,\n  TabsRenderPropArg,\n  TabsPropsWeControl,\n  {\n    defaultIndex?: number\n    onChange?: (index: number) => void\n    selectedIndex?: number\n    vertical?: boolean\n    manual?: boolean\n  }\n>\n\nfunction GroupFn<TTag extends ElementType = typeof DEFAULT_TABS_TAG>(\n  props: TabGroupProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let {\n    defaultIndex = 0,\n    vertical = false,\n    manual = false,\n    onChange,\n    selectedIndex = null,\n    ...theirProps\n  } = props\n  const orientation = vertical ? 'vertical' : 'horizontal'\n  const activation = manual ? 'manual' : 'auto'\n\n  let isControlled = selectedIndex !== null\n\n  let tabsRef = useSyncRefs(ref)\n  let [state, dispatch] = useReducer(stateReducer, {\n    selectedIndex: selectedIndex ?? defaultIndex,\n    tabs: [],\n    panels: [],\n  })\n  let slot = useMemo(\n    () => ({ selectedIndex: state.selectedIndex }) satisfies TabsRenderPropArg,\n    [state.selectedIndex]\n  )\n  let onChangeRef = useLatestValue(onChange || (() => {}))\n  let stableTabsRef = useLatestValue(state.tabs)\n\n  let tabsData = useMemo<_Data>(\n    () => ({ orientation, activation, ...state }),\n    [orientation, activation, state]\n  )\n\n  let registerTab = useEvent((tab) => {\n    dispatch({ type: ActionTypes.RegisterTab, tab })\n    return () => dispatch({ type: ActionTypes.UnregisterTab, tab })\n  })\n\n  let registerPanel = useEvent((panel) => {\n    dispatch({ type: ActionTypes.RegisterPanel, panel })\n    return () => dispatch({ type: ActionTypes.UnregisterPanel, panel })\n  })\n\n  let change = useEvent((index: number) => {\n    if (realSelectedIndex.current !== index) {\n      onChangeRef.current(index)\n    }\n\n    if (!isControlled) {\n      dispatch({ type: ActionTypes.SetSelectedIndex, index })\n    }\n  })\n\n  let realSelectedIndex = useLatestValue(isControlled ? props.selectedIndex : state.selectedIndex)\n  let tabsActions = useMemo<_Actions>(() => ({ registerTab, registerPanel, change }), [])\n\n  useIsoMorphicEffect(() => {\n    dispatch({ type: ActionTypes.SetSelectedIndex, index: selectedIndex ?? defaultIndex })\n  }, [selectedIndex /* Deliberately skipping defaultIndex */])\n\n  useIsoMorphicEffect(() => {\n    if (realSelectedIndex.current === undefined) return\n    if (state.tabs.length <= 0) return\n\n    // TODO: Figure out a way to detect this without the slow sort on every render. Might be fine\n    //       unless you have a lot of tabs.\n    let sorted = sortByDomNode(state.tabs, (tab) => tab.current)\n    let didOrderChange = sorted.some((tab, i) => state.tabs[i] !== tab)\n\n    if (didOrderChange) {\n      change(sorted.indexOf(state.tabs[realSelectedIndex.current]))\n    }\n  })\n\n  let ourProps = { ref: tabsRef }\n\n  return (\n    <StableCollection>\n      <TabsActionsContext.Provider value={tabsActions}>\n        <TabsDataContext.Provider value={tabsData}>\n          {tabsData.tabs.length <= 0 && (\n            <FocusSentinel\n              onFocus={() => {\n                for (let tab of stableTabsRef.current) {\n                  if (tab.current?.tabIndex === 0) {\n                    tab.current?.focus()\n                    return true\n                  }\n                }\n\n                return false\n              }}\n            />\n          )}\n          {render({\n            ourProps,\n            theirProps,\n            slot,\n            defaultTag: DEFAULT_TABS_TAG,\n            name: 'Tabs',\n          })}\n        </TabsDataContext.Provider>\n      </TabsActionsContext.Provider>\n    </StableCollection>\n  )\n}\n\n// ---\n\nlet DEFAULT_LIST_TAG = 'div' as const\ntype ListRenderPropArg = {\n  selectedIndex: number\n}\ntype ListPropsWeControl = 'aria-orientation' | 'role'\n\nexport type TabListProps<TTag extends ElementType = typeof DEFAULT_LIST_TAG> = Props<\n  TTag,\n  ListRenderPropArg,\n  ListPropsWeControl,\n  {\n    //\n  }\n>\n\nfunction ListFn<TTag extends ElementType = typeof DEFAULT_LIST_TAG>(\n  props: TabListProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { orientation, selectedIndex } = useData('Tab.List')\n  let listRef = useSyncRefs(ref)\n\n  let slot = useMemo(() => ({ selectedIndex }) satisfies ListRenderPropArg, [selectedIndex])\n\n  let theirProps = props\n  let ourProps = {\n    ref: listRef,\n    role: 'tablist',\n    'aria-orientation': orientation,\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_LIST_TAG,\n    name: 'Tabs.List',\n  })\n}\n\n// ---\n\nlet DEFAULT_TAB_TAG = 'button' as const\ntype TabRenderPropArg = {\n  hover: boolean\n  focus: boolean\n  active: boolean\n  autofocus: boolean\n  selected: boolean\n}\ntype TabPropsWeControl = 'aria-controls' | 'aria-selected' | 'role' | 'tabIndex'\n\nexport type TabProps<TTag extends ElementType = typeof DEFAULT_TAB_TAG> = Props<\n  TTag,\n  TabRenderPropArg,\n  TabPropsWeControl,\n  {\n    autoFocus?: boolean\n    disabled?: boolean\n  }\n>\n\nfunction TabFn<TTag extends ElementType = typeof DEFAULT_TAB_TAG>(\n  props: TabProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-tabs-tab-${internalId}`, ...theirProps } = props\n\n  let { orientation, activation, selectedIndex, tabs, panels } = useData('Tab')\n  let actions = useActions('Tab')\n  let data = useData('Tab')\n\n  let internalTabRef = useRef<HTMLElement | null>(null)\n  let tabRef = useSyncRefs(internalTabRef, ref)\n\n  useIsoMorphicEffect(() => actions.registerTab(internalTabRef), [actions, internalTabRef])\n\n  let mySSRIndex = useStableCollectionIndex('tabs')\n\n  let myIndex = tabs.indexOf(internalTabRef)\n  if (myIndex === -1) myIndex = mySSRIndex\n  let selected = myIndex === selectedIndex\n\n  let activateUsing = useEvent((cb: () => FocusResult) => {\n    let result = cb()\n    if (result === FocusResult.Success && activation === 'auto') {\n      let newTab = getOwnerDocument(internalTabRef)?.activeElement\n      let idx = data.tabs.findIndex((tab) => tab.current === newTab)\n      if (idx !== -1) actions.change(idx)\n    }\n    return result\n  })\n\n  let handleKeyDown = useEvent((event: ReactKeyboardEvent<HTMLElement>) => {\n    let list = tabs.map((tab) => tab.current).filter(Boolean) as HTMLElement[]\n\n    if (event.key === Keys.Space || event.key === Keys.Enter) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      actions.change(myIndex)\n      return\n    }\n\n    switch (event.key) {\n      case Keys.Home:\n      case Keys.PageUp:\n        event.preventDefault()\n        event.stopPropagation()\n\n        return activateUsing(() => focusIn(list, Focus.First))\n\n      case Keys.End:\n      case Keys.PageDown:\n        event.preventDefault()\n        event.stopPropagation()\n\n        return activateUsing(() => focusIn(list, Focus.Last))\n    }\n\n    let result = activateUsing(() => {\n      return match(orientation, {\n        vertical() {\n          if (event.key === Keys.ArrowUp) return focusIn(list, Focus.Previous | Focus.WrapAround)\n          if (event.key === Keys.ArrowDown) return focusIn(list, Focus.Next | Focus.WrapAround)\n          return FocusResult.Error\n        },\n        horizontal() {\n          if (event.key === Keys.ArrowLeft) return focusIn(list, Focus.Previous | Focus.WrapAround)\n          if (event.key === Keys.ArrowRight) return focusIn(list, Focus.Next | Focus.WrapAround)\n          return FocusResult.Error\n        },\n      })\n    })\n\n    if (result === FocusResult.Success) {\n      return event.preventDefault()\n    }\n  })\n\n  let ready = useRef(false)\n  let handleSelection = useEvent(() => {\n    if (ready.current) return\n    ready.current = true\n\n    internalTabRef.current?.focus({ preventScroll: true })\n    actions.change(myIndex)\n\n    microTask(() => {\n      ready.current = false\n    })\n  })\n\n  // This is important because we want to only focus the tab when it gets focus\n  // OR it finished the click event (mouseup). However, if you perform a `click`,\n  // then you will first get the `focus` and then get the `click` event.\n  let handleMouseDown = useEvent((event: ReactMouseEvent<HTMLElement>) => {\n    event.preventDefault()\n  })\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: props.disabled ?? false })\n  let { pressed: active, pressProps } = useActivePress({ disabled: props.disabled ?? false })\n\n  let slot = useMemo(\n    () =>\n      ({\n        selected,\n        hover,\n        active,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies TabRenderPropArg,\n    [selected, hover, focus, active, props.autoFocus]\n  )\n\n  let ourProps = mergeProps(\n    {\n      ref: tabRef,\n      onKeyDown: handleKeyDown,\n      onMouseDown: handleMouseDown,\n      onClick: handleSelection,\n      id,\n      role: 'tab',\n      type: useResolveButtonType(props, internalTabRef),\n      'aria-controls': panels[myIndex]?.current?.id,\n      'aria-selected': selected,\n      tabIndex: selected ? 0 : -1,\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TAB_TAG,\n    name: 'Tabs.Tab',\n  })\n}\n\n// ---\n\nlet DEFAULT_PANELS_TAG = 'div' as const\ntype PanelsRenderPropArg = {\n  selectedIndex: number\n}\n\nexport type TabPanelsProps<TTag extends ElementType = typeof DEFAULT_PANELS_TAG> = Props<\n  TTag,\n  PanelsRenderPropArg\n>\n\nfunction PanelsFn<TTag extends ElementType = typeof DEFAULT_PANELS_TAG>(\n  props: TabPanelsProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let { selectedIndex } = useData('Tab.Panels')\n  let panelsRef = useSyncRefs(ref)\n\n  let slot = useMemo(() => ({ selectedIndex }), [selectedIndex])\n\n  let theirProps = props\n  let ourProps = { ref: panelsRef }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANELS_TAG,\n    name: 'Tabs.Panels',\n  })\n}\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ntype PanelRenderPropArg = {\n  selected: boolean\n}\ntype PanelPropsWeControl = 'role' | 'aria-labelledby'\nlet PanelRenderFeatures = RenderFeatures.RenderStrategy | RenderFeatures.Static\n\nexport type TabPanelProps<TTag extends ElementType = typeof DEFAULT_PANEL_TAG> = Props<\n  TTag,\n  PanelRenderPropArg,\n  PanelPropsWeControl,\n  PropsForFeatures<typeof PanelRenderFeatures> & { id?: string; tabIndex?: number }\n>\n\nfunction PanelFn<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: TabPanelProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let { id = `headlessui-tabs-panel-${internalId}`, tabIndex = 0, ...theirProps } = props\n  let { selectedIndex, tabs, panels } = useData('Tab.Panel')\n  let actions = useActions('Tab.Panel')\n\n  let internalPanelRef = useRef<HTMLElement | null>(null)\n  let panelRef = useSyncRefs(internalPanelRef, ref)\n\n  useIsoMorphicEffect(() => actions.registerPanel(internalPanelRef), [actions, internalPanelRef])\n\n  let mySSRIndex = useStableCollectionIndex('panels')\n\n  let myIndex = panels.indexOf(internalPanelRef)\n  if (myIndex === -1) myIndex = mySSRIndex\n\n  let selected = myIndex === selectedIndex\n\n  let slot = useMemo(() => ({ selected }), [selected])\n\n  let ourProps = {\n    ref: panelRef,\n    id,\n    role: 'tabpanel',\n    'aria-labelledby': tabs[myIndex]?.current?.id,\n    tabIndex: selected ? tabIndex : -1,\n  }\n\n  if (!selected && (theirProps.unmount ?? true) && !(theirProps.static ?? false)) {\n    return <Hidden as=\"span\" aria-hidden=\"true\" {...ourProps} />\n  }\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG,\n    features: PanelRenderFeatures,\n    visible: selected,\n    name: 'Tabs.Panel',\n  })\n}\n\n// ---\n\nexport interface _internal_ComponentTab extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TAB_TAG>(\n    props: TabProps<TTag> & RefProp<typeof TabFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentTabGroup extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TABS_TAG>(\n    props: TabGroupProps<TTag> & RefProp<typeof GroupFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentTabList extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_LIST_TAG>(\n    props: TabListProps<TTag> & RefProp<typeof ListFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentTabPanels extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PANELS_TAG>(\n    props: TabPanelsProps<TTag> & RefProp<typeof PanelsFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentTabPanel extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n    props: TabPanelProps<TTag> & RefProp<typeof PanelFn>\n  ): JSX.Element\n}\n\nlet TabRoot = forwardRefWithAs(TabFn) as unknown as _internal_ComponentTab\nexport let TabGroup = forwardRefWithAs(GroupFn) as unknown as _internal_ComponentTabGroup\nexport let TabList = forwardRefWithAs(ListFn) as unknown as _internal_ComponentTabList\nexport let TabPanels = forwardRefWithAs(PanelsFn) as unknown as _internal_ComponentTabPanels\nexport let TabPanel = forwardRefWithAs(PanelFn) as unknown as _internal_ComponentTabPanel\n\nexport let Tab = Object.assign(TabRoot, {\n  Group: TabGroup,\n  List: TabList,\n  Panels: TabPanels,\n  Panel: TabPanel,\n})\n", "import React, { useState, type FocusEvent as ReactFocusEvent } from 'react'\nimport { useIsMounted } from '../hooks/use-is-mounted'\nimport { Hidden, HiddenFeatures } from './hidden'\n\ninterface FocusSentinelProps {\n  onFocus(): boolean\n}\n\nexport function FocusSentinel({ onFocus }: FocusSentinelProps) {\n  let [enabled, setEnabled] = useState(true)\n  let mounted = useIsMounted()\n\n  if (!enabled) return null\n\n  return (\n    <Hidden\n      as=\"button\"\n      type=\"button\"\n      features={HiddenFeatures.Focusable}\n      onFocus={(event: ReactFocusEvent) => {\n        event.preventDefault()\n        let frame: ReturnType<typeof requestAnimationFrame>\n\n        let tries = 50\n        function forwardFocus() {\n          // Prevent infinite loops\n          if (tries-- <= 0) {\n            if (frame) cancelAnimationFrame(frame)\n            return\n          }\n\n          // Try to move focus to the correct element. This depends on the implementation\n          // of `onFocus` of course since it would be different for each place we use it in.\n          if (onFocus()) {\n            cancelAnimationFrame(frame)\n            if (!mounted.current) return\n\n            setEnabled(false)\n            return\n          }\n\n          // Retry\n          frame = requestAnimationFrame(forwardFocus)\n        }\n\n        frame = requestAnimationFrame(forwardFocus)\n      }}\n    />\n  )\n}\n", "import * as React from 'react'\n\ntype CollectionKey = string | symbol\ntype CollectionItem = [number, () => void]\ntype CollectionRef = React.MutableRefObject<ReturnType<typeof createCollection>>\nconst StableCollectionContext = React.createContext<CollectionRef | null>(null)\n\nfunction createCollection() {\n  return {\n    /** @type {Map<string, Map<string, number>>} */\n    groups: new Map(),\n\n    get(group: string, key: CollectionKey): CollectionItem {\n      let list = this.groups.get(group)\n      if (!list) {\n        list = new Map()\n        this.groups.set(group, list)\n      }\n\n      let renders = list.get(key) ?? 0\n      list.set(key, renders + 1)\n\n      let index = Array.from(list.keys()).indexOf(key)\n      function release() {\n        let renders = list.get(key)\n        if (renders > 1) {\n          list.set(key, renders - 1)\n        } else {\n          list.delete(key)\n        }\n      }\n\n      return [index, release]\n    },\n  }\n}\n\nexport function StableCollection({ children }: { children: React.ReactNode | React.ReactNode[] }) {\n  let collection = React.useRef(createCollection())\n\n  return (\n    <StableCollectionContext.Provider value={collection}>\n      {children}\n    </StableCollectionContext.Provider>\n  )\n}\n\nexport function useStableCollectionIndex(group: string) {\n  let collection = React.useContext(StableCollectionContext)\n  if (!collection) throw new Error('You must wrap your component in a <StableCollection>')\n\n  let key = useStableCollectionKey()\n  let [idx, cleanupIdx] = collection.current.get(group, key)\n  React.useEffect(() => cleanupIdx, [])\n  return idx\n}\n\n/**\n * Return a stable key based on the position of this node.\n *\n * @returns {symbol | string}\n */\nfunction useStableCollectionKey() {\n  let owner =\n    // @ts-ignore\n    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?.ReactCurrentOwner?.current ?? null\n\n  // ssr: dev/prod\n  // client: prod\n  if (!owner) return Symbol()\n\n  // client: dev\n  let indexes = []\n  let fiber = owner\n  while (fiber) {\n    indexes.push(fiber.index)\n    fiber = fiber.return\n  }\n\n  return '$.' + indexes.join('.')\n}\n", "'use client'\n\nimport { useFocusRing } from '@react-aria/focus'\nimport { useHover } from '@react-aria/interactions'\nimport { useMemo, type ElementType, type Ref } from 'react'\nimport { useId } from '../../hooks/use-id'\nimport { useDisabled } from '../../internal/disabled'\nimport { useProvidedId } from '../../internal/id'\nimport type { Props } from '../../types'\nimport {\n  forwardRefWithAs,\n  mergeProps,\n  render,\n  type HasDisplayName,\n  type RefProp,\n} from '../../utils/render'\nimport { useDescribedBy } from '../description/description'\nimport { useLabelledBy } from '../label/label'\n\nlet DEFAULT_TEXTAREA_TAG = 'textarea' as const\n\ntype TextareaRenderPropArg = {\n  disabled: boolean\n  hover: boolean\n  focus: boolean\n  autofocus: boolean\n  invalid: boolean\n}\ntype TextareaPropsWeControl = 'aria-labelledby' | 'aria-describedby'\n\nexport type TextareaProps<TTag extends ElementType = typeof DEFAULT_TEXTAREA_TAG> = Props<\n  TTag,\n  TextareaRenderPropArg,\n  TextareaPropsWeControl,\n  {\n    disabled?: boolean\n    invalid?: boolean\n    autoFocus?: boolean\n  }\n>\n\nfunction TextareaFn<TTag extends ElementType = typeof DEFAULT_TEXTAREA_TAG>(\n  props: TextareaProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let internalId = useId()\n  let providedId = useProvidedId()\n  let providedDisabled = useDisabled()\n  let {\n    id = providedId || `headlessui-textarea-${internalId}`,\n    disabled = providedDisabled || false,\n    invalid = false,\n    ...theirProps\n  } = props\n\n  let labelledBy = useLabelledBy()\n  let describedBy = useDescribedBy()\n\n  let { isFocusVisible: focus, focusProps } = useFocusRing({ autoFocus: props.autoFocus ?? false })\n  let { isHovered: hover, hoverProps } = useHover({ isDisabled: disabled ?? false })\n\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      'aria-labelledby': labelledBy,\n      'aria-describedby': describedBy,\n      'aria-invalid': invalid ? '' : undefined,\n      disabled: disabled || undefined,\n    },\n    focusProps,\n    hoverProps\n  )\n\n  let slot = useMemo(\n    () =>\n      ({\n        disabled,\n        invalid,\n        hover,\n        focus,\n        autofocus: props.autoFocus ?? false,\n      }) satisfies TextareaRenderPropArg,\n    [disabled, invalid, hover, focus, props.autoFocus]\n  )\n\n  return render({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TEXTAREA_TAG,\n    name: 'Textarea',\n  })\n}\n\nexport interface _internal_ComponentTextarea extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TEXTAREA_TAG>(\n    props: TextareaProps<TTag> & RefProp<typeof TextareaFn>\n  ): JSX.Element\n}\n\nexport let Textarea = forwardRefWithAs(TextareaFn) as unknown as _internal_ComponentTextarea\n", "'use client'\n\nimport React, {\n  Fragment,\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ElementType,\n  type MutableRefObject,\n  type Ref,\n} from 'react'\nimport { useDisposables } from '../../hooks/use-disposables'\nimport { useEvent } from '../../hooks/use-event'\nimport { useFlags } from '../../hooks/use-flags'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\nimport { useLatestValue } from '../../hooks/use-latest-value'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useTransition } from '../../hooks/use-transition'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport type { Props, ReactTag } from '../../types'\nimport { classNames } from '../../utils/class-names'\nimport { match } from '../../utils/match'\nimport {\n  RenderFeatures,\n  RenderStrategy,\n  forwardRefWithAs,\n  render,\n  type HasDisplayName,\n  type PropsForFeatures,\n  type RefProp,\n} from '../../utils/render'\n\ntype ContainerElement = MutableRefObject<HTMLElement | null>\n\ntype TransitionDirection = 'enter' | 'leave' | 'idle'\n\n/**\n * Split class lists by whitespace\n *\n * We can't check for just spaces as all whitespace characters are\n * invalid in a class name, so we have to split on ANY whitespace.\n */\nfunction splitClasses(classes: string = '') {\n  return classes.split(/\\s+/).filter((className) => className.length > 1)\n}\n\ninterface TransitionContextValues {\n  show: boolean\n  appear: boolean\n  initial: boolean\n}\nlet TransitionContext = createContext<TransitionContextValues | null>(null)\nTransitionContext.displayName = 'TransitionContext'\n\nenum TreeStates {\n  Visible = 'visible',\n  Hidden = 'hidden',\n}\n\nexport interface TransitionClasses {\n  enter?: string\n  enterFrom?: string\n  enterTo?: string\n  entered?: string\n  leave?: string\n  leaveFrom?: string\n  leaveTo?: string\n}\n\nexport interface TransitionEvents {\n  beforeEnter?: () => void\n  afterEnter?: () => void\n  beforeLeave?: () => void\n  afterLeave?: () => void\n}\n\ntype TransitionChildPropsWeControl = never\n\nexport type TransitionChildProps<TTag extends ReactTag> = Props<\n  TTag,\n  TransitionChildRenderPropArg,\n  TransitionChildPropsWeControl,\n  PropsForFeatures<typeof TransitionChildRenderFeatures> &\n    TransitionClasses &\n    TransitionEvents & { appear?: boolean }\n>\n\nfunction useTransitionContext() {\n  let context = useContext(TransitionContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\nfunction useParentNesting() {\n  let context = useContext(NestingContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\ninterface NestingContextValues {\n  children: MutableRefObject<{ el: ContainerElement; state: TreeStates }[]>\n  register: (el: ContainerElement) => () => void\n  unregister: (el: ContainerElement, strategy?: RenderStrategy) => void\n  onStart: (el: ContainerElement, direction: TransitionDirection, cb: () => void) => void\n  onStop: (el: ContainerElement, direction: TransitionDirection, cb: () => void) => void\n  chains: MutableRefObject<\n    Record<TransitionDirection, [container: ContainerElement, promise: Promise<void>][]>\n  >\n  wait: MutableRefObject<Promise<void>>\n}\n\nlet NestingContext = createContext<NestingContextValues | null>(null)\nNestingContext.displayName = 'NestingContext'\n\nfunction hasChildren(\n  bag: NestingContextValues['children'] | { children: NestingContextValues['children'] }\n): boolean {\n  if ('children' in bag) return hasChildren(bag.children)\n  return (\n    bag.current\n      .filter(({ el }) => el.current !== null)\n      .filter(({ state }) => state === TreeStates.Visible).length > 0\n  )\n}\n\nfunction useNesting(done?: () => void, parent?: NestingContextValues) {\n  let doneRef = useLatestValue(done)\n  let transitionableChildren = useRef<NestingContextValues['children']['current']>([])\n  let mounted = useIsMounted()\n  let d = useDisposables()\n\n  let unregister = useEvent((container: ContainerElement, strategy = RenderStrategy.Hidden) => {\n    let idx = transitionableChildren.current.findIndex(({ el }) => el === container)\n    if (idx === -1) return\n\n    match(strategy, {\n      [RenderStrategy.Unmount]() {\n        transitionableChildren.current.splice(idx, 1)\n      },\n      [RenderStrategy.Hidden]() {\n        transitionableChildren.current[idx].state = TreeStates.Hidden\n      },\n    })\n\n    d.microTask(() => {\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        doneRef.current?.()\n      }\n    })\n  })\n\n  let register = useEvent((container: ContainerElement) => {\n    let child = transitionableChildren.current.find(({ el }) => el === container)\n    if (!child) {\n      transitionableChildren.current.push({ el: container, state: TreeStates.Visible })\n    } else if (child.state !== TreeStates.Visible) {\n      child.state = TreeStates.Visible\n    }\n\n    return () => unregister(container, RenderStrategy.Unmount)\n  })\n\n  let todos = useRef<(() => void)[]>([])\n  let wait = useRef<Promise<void>>(Promise.resolve())\n\n  let chains = useRef<\n    Record<TransitionDirection, [identifier: ContainerElement, promise: Promise<void>][]>\n  >({\n    enter: [],\n    leave: [],\n    idle: [],\n  })\n\n  let onStart = useEvent(\n    (\n      container: ContainerElement,\n      direction: TransitionDirection,\n      cb: (direction: TransitionDirection) => void\n    ) => {\n      // Clear out all existing todos\n      todos.current.splice(0)\n\n      // Remove all existing promises for the current container from the parent because we can\n      // ignore those and use only the new one.\n      if (parent) {\n        parent.chains.current[direction] = parent.chains.current[direction].filter(\n          ([containerInParent]) => containerInParent !== container\n        )\n      }\n\n      // Wait until our own transition is done\n      parent?.chains.current[direction].push([\n        container,\n        new Promise<void>((resolve) => {\n          todos.current.push(resolve)\n        }),\n      ])\n\n      // Wait until our children are done\n      parent?.chains.current[direction].push([\n        container,\n        new Promise<void>((resolve) => {\n          Promise.all(chains.current[direction].map(([_container, promise]) => promise)).then(() =>\n            resolve()\n          )\n        }),\n      ])\n\n      if (direction === 'enter') {\n        wait.current = wait.current.then(() => parent?.wait.current).then(() => cb(direction))\n      } else {\n        cb(direction)\n      }\n    }\n  )\n\n  let onStop = useEvent(\n    (\n      _container: ContainerElement,\n      direction: TransitionDirection,\n      cb: (direction: TransitionDirection) => void\n    ) => {\n      Promise.all(chains.current[direction].splice(0).map(([_container, promise]) => promise)) // Wait for my children\n        .then(() => {\n          todos.current.shift()?.() // I'm ready\n        })\n        .then(() => cb(direction))\n    }\n  )\n\n  return useMemo(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n      onStart,\n      onStop,\n      wait,\n      chains,\n    }),\n    [register, unregister, transitionableChildren, onStart, onStop, chains, wait]\n  )\n}\n\nfunction noop() {}\nlet eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'] as const\nfunction ensureEventHooksExist(events: TransitionEvents) {\n  let result = {} as Record<keyof typeof events, () => void>\n  for (let name of eventNames) {\n    result[name] = events[name] ?? noop\n  }\n  return result\n}\n\nfunction useEvents(events: TransitionEvents) {\n  let eventsRef = useRef(ensureEventHooksExist(events))\n\n  useEffect(() => {\n    eventsRef.current = ensureEventHooksExist(events)\n  }, [events])\n\n  return eventsRef\n}\n\n// ---\n\nlet DEFAULT_TRANSITION_CHILD_TAG = 'div' as const\ntype TransitionChildRenderPropArg = MutableRefObject<HTMLDivElement>\nlet TransitionChildRenderFeatures = RenderFeatures.RenderStrategy\n\nfunction TransitionChildFn<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  let {\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n\n    // @ts-expect-error\n    ...rest\n  } = props as typeof props\n  let container = useRef<HTMLElement | null>(null)\n  let transitionRef = useSyncRefs(container, ref)\n  let strategy = rest.unmount ?? true ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n  let { show, appear, initial } = useTransitionContext()\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let parentNesting = useParentNesting()\n  let { register, unregister } = parentNesting\n\n  useIsoMorphicEffect(() => register(container), [register, container])\n\n  useIsoMorphicEffect(() => {\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return\n    if (!container.current) return\n\n    // Make sure that we are visible\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible)\n      return\n    }\n\n    return match(state, {\n      [TreeStates.Hidden]: () => unregister(container),\n      [TreeStates.Visible]: () => register(container),\n    })\n  }, [state, container, register, unregister, show, strategy])\n\n  let classes = useLatestValue({\n    base: splitClasses(rest.className),\n    enter: splitClasses(enter),\n    enterFrom: splitClasses(enterFrom),\n    enterTo: splitClasses(enterTo),\n    entered: splitClasses(entered),\n    leave: splitClasses(leave),\n    leaveFrom: splitClasses(leaveFrom),\n    leaveTo: splitClasses(leaveTo),\n  })\n\n  let events = useEvents({\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n  })\n\n  let ready = useServerHandoffComplete()\n\n  useIsoMorphicEffect(() => {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?')\n    }\n  }, [container, state, ready])\n\n  // Skipping initial transition\n  let skip = initial && !appear\n  let immediate = appear && show && initial\n\n  let transitionDirection = (() => {\n    if (!ready) return 'idle'\n    if (skip) return 'idle'\n    return show ? 'enter' : 'leave'\n  })() as TransitionDirection\n\n  let transitionStateFlags = useFlags(0)\n\n  let beforeEvent = useEvent((direction: TransitionDirection) => {\n    return match(direction, {\n      enter: () => {\n        transitionStateFlags.addFlag(State.Opening)\n        events.current.beforeEnter()\n      },\n      leave: () => {\n        transitionStateFlags.addFlag(State.Closing)\n        events.current.beforeLeave()\n      },\n      idle: () => {},\n    })\n  })\n\n  let afterEvent = useEvent((direction: TransitionDirection) => {\n    return match(direction, {\n      enter: () => {\n        transitionStateFlags.removeFlag(State.Opening)\n        events.current.afterEnter()\n      },\n      leave: () => {\n        transitionStateFlags.removeFlag(State.Closing)\n        events.current.afterLeave()\n      },\n      idle: () => {},\n    })\n  })\n\n  let nesting = useNesting(() => {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    setState(TreeStates.Hidden)\n    unregister(container)\n  }, parentNesting)\n\n  let isTransitioning = useRef(false)\n  useTransition({\n    immediate,\n    container,\n    classes,\n    direction: transitionDirection,\n    onStart: useLatestValue((direction) => {\n      isTransitioning.current = true\n      nesting.onStart(container, direction, beforeEvent)\n    }),\n    onStop: useLatestValue((direction) => {\n      isTransitioning.current = false\n      nesting.onStop(container, direction, afterEvent)\n\n      if (direction === 'leave' && !hasChildren(nesting)) {\n        // When we don't have children anymore we can safely unregister from the parent and hide\n        // ourselves.\n        setState(TreeStates.Hidden)\n        unregister(container)\n      }\n    }),\n  })\n\n  let theirProps = rest\n  let ourProps = { ref: transitionRef }\n\n  if (immediate) {\n    theirProps = {\n      ...theirProps,\n      // Already apply the `enter` and `enterFrom` on the server if required\n      className: classNames(rest.className, ...classes.current.enter, ...classes.current.enterFrom),\n    }\n  }\n\n  // If we are re-rendering while we are transitioning, then we should ensure that the classes are\n  // not mutated by React itself because we are handling the transition ourself.\n  else if (isTransitioning.current) {\n    // When we re-render while we are in the middle of the transition, then we should take the\n    // incoming className and the current classes that are applied.\n    //\n    // This is a bit dirty, but we need to make sure React is not applying changes to the class\n    // attribute while we are transitioning.\n    theirProps.className = classNames(rest.className, container.current?.className)\n    if (theirProps.className === '') delete theirProps.className\n  }\n\n  return (\n    <NestingContext.Provider value={nesting}>\n      <OpenClosedProvider\n        value={\n          match(state, {\n            [TreeStates.Visible]: State.Open,\n            [TreeStates.Hidden]: State.Closed,\n          }) | transitionStateFlags.flags\n        }\n      >\n        {render({\n          ourProps,\n          theirProps,\n          defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition.Child',\n        })}\n      </OpenClosedProvider>\n    </NestingContext.Provider>\n  )\n}\n\nexport type TransitionRootProps<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG> =\n  TransitionChildProps<TTag> & {\n    show?: boolean\n    appear?: boolean\n  }\n\nfunction TransitionRootFn<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionRootProps<TTag>,\n  ref: Ref<HTMLElement>\n) {\n  // @ts-expect-error\n  let { show, appear = false, unmount = true, ...theirProps } = props as typeof props\n  let internalTransitionRef = useRef<HTMLElement | null>(null)\n  let transitionRef = useSyncRefs(internalTransitionRef, ref)\n\n  // The TransitionChild will also call this hook, and we have to make sure that we are ready.\n  useServerHandoffComplete()\n\n  let usesOpenClosedState = useOpenClosed()\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    show = (usesOpenClosedState & State.Open) === State.Open\n  }\n\n  if (![true, false].includes(show as unknown as boolean)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.')\n  }\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let nestingBag = useNesting(() => {\n    setState(TreeStates.Hidden)\n  })\n\n  let [initial, setInitial] = useState(true)\n\n  // Change the `initial` value\n  let changes = useRef([show])\n  useIsoMorphicEffect(() => {\n    // We can skip this effect\n    if (initial === false) {\n      return\n    }\n\n    // Track the changes\n    if (changes.current[changes.current.length - 1] !== show) {\n      changes.current.push(show)\n      setInitial(false)\n    }\n  }, [changes, show])\n\n  let transitionBag = useMemo<TransitionContextValues>(\n    () => ({ show: show as boolean, appear, initial }),\n    [show, appear, initial]\n  )\n\n  useIsoMorphicEffect(() => {\n    if (show) {\n      setState(TreeStates.Visible)\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden)\n    } else if (\n      process.env.NODE_ENV !==\n      'test' /* TODO: Remove this once we have real tests! JSDOM doesn't \"render\", therefore getBoundingClientRect() will always result in `0`. */\n    ) {\n      let node = internalTransitionRef.current\n      if (!node) return\n      let rect = node.getBoundingClientRect()\n\n      if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {\n        // The node is completely hidden, let's hide it\n        setState(TreeStates.Hidden)\n      }\n    }\n  }, [show, nestingBag])\n\n  let sharedProps = { unmount }\n\n  let beforeEnter = useEvent(() => {\n    if (initial) setInitial(false)\n    props.beforeEnter?.()\n  })\n\n  let beforeLeave = useEvent(() => {\n    if (initial) setInitial(false)\n    props.beforeLeave?.()\n  })\n\n  return (\n    <NestingContext.Provider value={nestingBag}>\n      <TransitionContext.Provider value={transitionBag}>\n        {render({\n          ourProps: {\n            ...sharedProps,\n            as: Fragment,\n            children: (\n              <InternalTransitionChild\n                ref={transitionRef}\n                {...sharedProps}\n                {...theirProps}\n                beforeEnter={beforeEnter}\n                beforeLeave={beforeLeave}\n              />\n            ),\n          },\n          theirProps: {},\n          defaultTag: Fragment,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition',\n        })}\n      </TransitionContext.Provider>\n    </NestingContext.Provider>\n  )\n}\n\nfunction ChildFn<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>,\n  ref: MutableRefObject<HTMLElement>\n) {\n  let hasTransitionContext = useContext(TransitionContext) !== null\n  let hasOpenClosedContext = useOpenClosed() !== null\n\n  return (\n    <>\n      {!hasTransitionContext && hasOpenClosedContext ? (\n        // @ts-expect-error This is an object\n        <TransitionRoot ref={ref} {...props} />\n      ) : (\n        // @ts-expect-error This is an object\n        <InternalTransitionChild ref={ref} {...props} />\n      )}\n    </>\n  )\n}\n\nexport interface _internal_ComponentTransitionRoot extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n    props: TransitionRootProps<TTag> & RefProp<typeof TransitionRootFn>\n  ): JSX.Element\n}\n\nexport interface _internal_ComponentTransitionChild extends HasDisplayName {\n  <TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n    props: TransitionChildProps<TTag> & RefProp<typeof TransitionChildFn>\n  ): JSX.Element\n}\n\nlet TransitionRoot = forwardRefWithAs(\n  TransitionRootFn\n) as unknown as _internal_ComponentTransitionRoot\nlet InternalTransitionChild = forwardRefWithAs(\n  TransitionChildFn\n) as unknown as _internal_ComponentTransitionChild\nexport let TransitionChild = forwardRefWithAs(\n  ChildFn\n) as unknown as _internal_ComponentTransitionChild\n\nexport let Transition = Object.assign(TransitionRoot, {\n  Child: TransitionChild,\n  Root: TransitionRoot,\n})\n", "import { useCallback, useState } from 'react'\nimport { useIsMounted } from './use-is-mounted'\n\nexport function useFlags(initialFlags = 0) {\n  let [flags, setFlags] = useState(initialFlags)\n  let mounted = useIsMounted()\n\n  let addFlag = useCallback(\n    (flag: number) => {\n      if (!mounted.current) return\n      setFlags((flags) => flags | flag)\n    },\n    [flags, mounted]\n  )\n  let hasFlag = useCallback((flag: number) => Boolean(flags & flag), [flags])\n  let removeFlag = useCallback(\n    (flag: number) => {\n      if (!mounted.current) return\n      setFlags((flags) => flags & ~flag)\n    },\n    [setFlags, mounted]\n  )\n  let toggleFlag = useCallback(\n    (flag: number) => {\n      if (!mounted.current) return\n      setFlags((flags) => flags ^ flag)\n    },\n    [setFlags]\n  )\n\n  return { flags, addFlag, hasFlag, removeFlag, toggleFlag }\n}\n", "export function once<T>(cb: (...args: T[]) => void) {\n  let state = { called: false }\n\n  return (...args: T[]) => {\n    if (state.called) return\n    state.called = true\n    return cb(...args)\n  }\n}\n", "import { disposables } from '../../../utils/disposables'\nimport { match } from '../../../utils/match'\nimport { once } from '../../../utils/once'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nfunction waitForTransition(node: HTMLElement, done: () => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delayMs] = [transitionDuration, transitionDelay].map((value) => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map((v) => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  let totalDuration = durationMs + delayMs\n\n  if (totalDuration !== 0) {\n    if (process.env.NODE_ENV === 'test') {\n      let dispose = d.setTimeout(() => {\n        done()\n        dispose()\n      }, totalDuration)\n    } else {\n      let disposeGroup = d.group((d) => {\n        // Mark the transition as done when the timeout is reached. This is a fallback in case the\n        // transitionrun event is not fired.\n        let cancelTimeout = d.setTimeout(() => {\n          done()\n          d.dispose()\n        }, totalDuration)\n\n        // The moment the transitionrun event fires, we should cleanup the timeout fallback, because\n        // then we know that we can use the native transition events because something is\n        // transitioning.\n        d.addEventListener(node, 'transitionrun', (event) => {\n          if (event.target !== event.currentTarget) return\n          cancelTimeout()\n\n          d.addEventListener(node, 'transitioncancel', (event) => {\n            if (event.target !== event.currentTarget) return\n            done()\n            disposeGroup()\n          })\n        })\n      })\n\n      d.addEventListener(node, 'transitionend', (event) => {\n        if (event.target !== event.currentTarget) return\n        done()\n        d.dispose()\n      })\n    }\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done()\n  }\n\n  // If we get disposed before the transition finishes, we should cleanup anyway.\n  d.add(() => done())\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  classes: {\n    base: string[]\n    enter: string[]\n    enterFrom: string[]\n    enterTo: string[]\n    leave: string[]\n    leaveFrom: string[]\n    leaveTo: string[]\n    entered: string[]\n  },\n  show: boolean,\n  done?: () => void\n) {\n  let direction = show ? 'enter' : 'leave'\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  // When using unmount={false}, when the element is \"hidden\", then we apply a `style.display =\n  // 'none'` and a `hidden` attribute. Let's remove that in case we want to make an enter\n  // transition. It can happen that React is removing this a bit too late causing the element to not\n  // transition at all.\n  if (direction === 'enter') {\n    node.removeAttribute('hidden')\n    node.style.display = ''\n  }\n\n  let base = match(direction, {\n    enter: () => classes.enter,\n    leave: () => classes.leave,\n  })\n  let to = match(direction, {\n    enter: () => classes.enterTo,\n    leave: () => classes.leaveTo,\n  })\n  let from = match(direction, {\n    enter: () => classes.enterFrom,\n    leave: () => classes.leaveFrom,\n  })\n\n  removeClasses(\n    node,\n    ...classes.base,\n    ...classes.enter,\n    ...classes.enterTo,\n    ...classes.enterFrom,\n    ...classes.leave,\n    ...classes.leaveFrom,\n    ...classes.leaveTo,\n    ...classes.entered\n  )\n  addClasses(node, ...classes.base, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...classes.base, ...base, ...from)\n    addClasses(node, ...classes.base, ...base, ...to)\n\n    waitForTransition(node, () => {\n      removeClasses(node, ...classes.base, ...base)\n      addClasses(node, ...classes.base, ...classes.entered)\n\n      return _done()\n    })\n  })\n\n  return d.dispose\n}\n", "import type { MutableRefObject } from 'react'\nimport { transition } from '../components/transition/utils/transition'\nimport { disposables } from '../utils/disposables'\nimport { useDisposables } from './use-disposables'\nimport { useIsMounted } from './use-is-mounted'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useLatestValue } from './use-latest-value'\n\ninterface TransitionArgs {\n  immediate: boolean\n  container: MutableRefObject<HTMLElement | null>\n  classes: MutableRefObject<{\n    base: string[]\n\n    enter: string[]\n    enterFrom: string[]\n    enterTo: string[]\n\n    leave: string[]\n    leaveFrom: string[]\n    leaveTo: string[]\n\n    entered: string[]\n  }>\n  direction: 'enter' | 'leave' | 'idle'\n  onStart: MutableRefObject<(direction: TransitionArgs['direction']) => void>\n  onStop: MutableRefObject<(direction: TransitionArgs['direction']) => void>\n}\n\nexport function useTransition({\n  immediate,\n  container,\n  direction,\n  classes,\n  onStart,\n  onStop,\n}: TransitionArgs) {\n  let mounted = useIsMounted()\n  let d = useDisposables()\n\n  let latestDirection = useLatestValue(direction)\n\n  useIsoMorphicEffect(() => {\n    if (!immediate) return\n\n    latestDirection.current = 'enter'\n  }, [immediate])\n\n  useIsoMorphicEffect(() => {\n    let dd = disposables()\n    d.add(dd.dispose)\n\n    let node = container.current\n    if (!node) return // We don't have a DOM node (yet)\n    if (latestDirection.current === 'idle') return // We don't need to transition\n    if (!mounted.current) return\n\n    dd.dispose()\n\n    onStart.current(latestDirection.current)\n\n    dd.add(\n      transition(node, classes.current, latestDirection.current === 'enter', () => {\n        dd.dispose()\n        onStop.current(latestDirection.current)\n      })\n    )\n\n    return dd.dispose\n  }, [direction])\n}\n"],
  "mappings": "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",
  "names": ["e", "isFocused", "$f0a04ccd8dbdd83b$export$e5c5a5f917a5871c", "$12uGp$react", "$bdb11010cef70236$var$canUseDOM", "$7215afc6de606d6b$export$de79e2c695e052f3", "$7215afc6de606d6b$var$supportsPreventScroll", "$7215afc6de606d6b$var$getScrollableElements", "$7215afc6de606d6b$var$restoreScrollPosition", "$7215afc6de606d6b$var$supportsPreventScrollCached", "$c87311424ea30a05$var$testUserAgent", "$c87311424ea30a05$var$testPlatform", "$c87311424ea30a05$export$9ac100e40613ea10", "$c87311424ea30a05$export$7bef049ce92e4224", "$c87311424ea30a05$var$testPlatform", "$c87311424ea30a05$export$9ac100e40613ea10", "$c87311424ea30a05$export$78551043582a6a98", "$c87311424ea30a05$var$testUserAgent", "$c87311424ea30a05$export$6446a186d09e379e", "$c87311424ea30a05$export$a11b0059900ceec8", "$c87311424ea30a05$export$b7d78993b74f766d", "$ea8dcbcb9ea1b556$export$95185d699e05d4d7", "$c87311424ea30a05$export$b7d78993b74f766d", "$c87311424ea30a05$export$9ac100e40613ea10", "$c87311424ea30a05$export$78551043582a6a98", "$c87311424ea30a05$export$7bef049ce92e4224", "$7215afc6de606d6b$export$de79e2c695e052f3", "$bbed8b41f857bcc0$var$transitionsByElement", "$bbed8b41f857bcc0$var$transitionCallbacks", "$bbed8b41f857bcc0$var$setupGlobalEvents", "$5df64b3807dc15ee$var$visualViewport", "$6a7db85432448f7f$export$60278871457622de", "$c87311424ea30a05$export$a11b0059900ceec8", "$ae1eeba8b9eafd08$export$5165eccb35aaadb5", "$bx7SL$react", "$f6c31cce2adf654f$var$LINK_CLICKED", "$507fabe10e71c6fb$var$currentModality", "$507fabe10e71c6fb$var$changeHandlers", "$507fabe10e71c6fb$var$hasSetupGlobalListeners", "$507fabe10e71c6fb$var$hasEventBeforeFocus", "$507fabe10e71c6fb$var$hasBlurredWindowRecently", "$507fabe10e71c6fb$var$triggerChangeHandlers", "$507fabe10e71c6fb$var$changeHandlers", "$507fabe10e71c6fb$var$isValidKey", "$c87311424ea30a05$export$9ac100e40613ea10", "$507fabe10e71c6fb$var$handleKeyboardEvent", "$507fabe10e71c6fb$var$hasEventBeforeFocus", "$507fabe10e71c6fb$var$currentModality", "$507fabe10e71c6fb$var$handlePointerEvent", "$507fabe10e71c6fb$var$handleClickEvent", "$6a7db85432448f7f$export$60278871457622de", "$507fabe10e71c6fb$var$handleFocusEvent", "$507fabe10e71c6fb$var$hasBlurredWindowRecently", "$507fabe10e71c6fb$var$handleWindowBlur", "$507fabe10e71c6fb$var$setupGlobalFocusEvents", "$507fabe10e71c6fb$var$hasSetupGlobalListeners", "$bx7SL$useState", "$bx7SL$useRef", "$bx7SL$useEffect", "$bx7SL$useMemo", "triggerHoverEnd", "hoverProps", "useRef", "useState", "env", "useEffect", "useEffect", "useEvent", "useRef", "useState", "event", "React", "useRef", "useRef", "React", "useCallback", "useMemo", "useState", "useRef", "useState", "useState", "useRef", "React", "React", "React", "useSyncExternalStore", "React", "useId", "React", "createContext", "useContext", "useEffect", "useState", "createContext", "useState", "React", "useContext", "useEffect", "React", "createContext", "useContext", "React", "createContext", "useContext", "useMemo", "useState", "useEffect", "useRef", "useRef", "useEffect", "createContext", "useContext", "useState", "useMemo", "React", "React", "createContext", "useContext", "useMemo", "useState", "createContext", "useContext", "useState", "useMemo", "React", "useState", "useMemo", "useCallback", "React", "_extends", "memo", "getDeps", "fn", "opts", "deps", "initialDeps", "result", "depTime", "key", "debug", "Date", "now", "newDeps", "depsChanged", "length", "some", "dep", "index", "resultTime", "depEndTime", "Math", "round", "resultEndTime", "resultFpsPercentage", "pad", "str", "num", "String", "console", "info", "max", "min", "onChange", "notUndefined", "value", "msg", "undefined", "Error", "approxEqual", "a", "b", "abs", "defaultKeyExtractor", "index", "defaultRangeExtractor", "range", "start", "Math", "max", "startIndex", "overscan", "end", "min", "endIndex", "count", "arr", "i", "push", "observeElementRect", "instance", "cb", "element", "scrollElement", "handler", "rect", "width", "height", "round", "getBoundingClientRect", "observer", "ResizeObserver", "entries", "entry", "borderBoxSize", "box", "inlineSize", "blockSize", "observe", "unobserve", "observeElementOffset", "instance", "cb", "element", "scrollElement", "handler", "options", "horizontal", "addEventListener", "passive", "removeEventListener", "measureElement", "element", "entry", "instance", "borderBoxSize", "box", "size", "Math", "round", "options", "horizontal", "getBoundingClientRect", "elementScroll", "offset", "instance", "adjustments", "behavior", "toOffset", "scrollElement", "scrollTo", "options", "horizontal", "Virtualizer", "opts", "unsubs", "isScrolling", "isScrollingTimeoutId", "scrollToIndexTimeoutId", "measurementsCache", "itemSizeCache", "Map", "pendingMeasuredCacheIndexes", "scrollDirection", "scrollAdjustments", "measureElementCache", "observer", "_ro", "get", "ResizeObserver", "entries", "forEach", "entry", "_measureElement", "target", "disconnect", "observe", "box", "unobserve", "range", "startIndex", "endIndex", "setOptions", "Object", "key", "value", "_extends", "debug", "initialOffset", "overscan", "paddingStart", "paddingEnd", "scrollPaddingStart", "scrollPaddingEnd", "getItemKey", "defaultKeyExtractor", "rangeExtractor", "defaultRangeExtractor", "onChange", "measureElement", "initialRect", "width", "height", "scrollMargin", "scrollingDelay", "indexAttribute", "initialMeasurementsCache", "lanes", "notify", "cleanup", "filter", "Boolean", "d", "_didMount", "_willUpdate", "getScrollElement", "_scrollToOffset", "scrollOffset", "undefined", "push", "observeElementRect", "rect", "prev", "scrollRect", "maybeNotify", "observeElementOffset", "clearTimeout", "setTimeout", "getSize", "memoOptions", "memo", "count", "getFurthestMeasurement", "measurements", "index", "furthestMeasurementsFound", "furthestMeasurements", "m", "measurement", "has", "lane", "previousFurthestMeasurement", "end", "set", "size", "Array", "from", "values", "sort", "a", "b", "getMeasurements", "min", "length", "Math", "slice", "i", "furthestMeasurement", "start", "measuredSize", "estimateSize", "calculateRange", "outerSize", "initialDeps", "getIndexes", "indexFromElement", "node", "attributeName", "indexStr", "getAttribute", "console", "warn", "parseInt", "item", "cached", "prevNode", "isConnected", "measuredItemSize", "resizeItem", "itemSize", "delta", "info", "getVirtualItems", "indexes", "virtualItems", "k", "len", "getVirtualItemForOffset", "notUndefined", "findNearestBinarySearch", "getOffsetForAlignment", "align", "scrollSizeProp", "scrollSize", "document", "documentElement", "maxOffset", "max", "getOffsetForIndex", "isDynamicMode", "cancelScrollToIndex", "scrollToOffset", "scrollToIndex", "initialAlign", "elementInDOM", "approxEqual", "scrollBy", "getTotalSize", "scrollToFn", "measure", "low", "high", "getCurrentValue", "middle", "currentValue", "getOffset", "useIsomorphicLayoutEffect", "document", "useLayoutEffect", "useEffect", "useVirtualizerBase", "options", "rerender", "useReducer", "resolvedOptions", "onChange", "instance", "React", "useState", "Virtualizer", "setOptions", "_didMount", "_willUpdate", "useVirtualizer", "observeElementRect", "observeElementOffset", "scrollToFn", "elementScroll", "React", "Fragment", "createContext", "useCallback", "useContext", "useMemo", "useReducer", "useRef", "useState", "useCallback", "useEffect", "useRef", "offset", "useEffect", "useEffect", "useEffect", "useEffect", "useRef", "useEffect", "containers", "useMemo", "useMemo", "useState", "useState", "useRef", "useEffect", "useRef", "useRef", "useEffect", "accept", "walk", "useEffect", "useRef", "useRef", "useEffect", "React", "useLayoutEffect", "useEffect", "useRef", "getComputedStyle", "platform", "platform", "placements", "overflows", "sides", "side", "placement", "overflow", "platform", "x", "y", "min", "max", "platform", "getComputedStyle", "window", "computePosition", "React", "useLayoutEffect", "useEffect", "useLayoutEffect", "useEffect", "platform", "computePosition", "data", "createPortal", "flushSync", "React", "index", "useLayoutEffect", "useEffect", "index", "React", "useId", "useFloating", "open", "useId", "index", "node", "mergeProps", "index", "flushSync", "React", "createContext", "useCallback", "useContext", "useMemo", "useRef", "useState", "createContext", "useContext", "useCallback", "useMemo", "useState", "useRef", "offset", "inner", "useFloating", "value", "element", "setValue", "history", "React", "createContext", "useContext", "useContext", "React", "activeOptionIndex", "activationTrigger", "createContext", "useContext", "useMemo", "useState", "React", "Fragment", "useReducer", "useRef", "value", "useCallback", "localActiveOptionIndex", "currentDisplayValue", "DEFAULT_BUTTON_TAG", "ButtonFn", "Fragment", "useMemo", "Fragment", "useMemo", "React", "createContext", "createRef", "useCallback", "useContext", "useEffect", "useMemo", "useReducer", "useRef", "useState", "React", "React", "useState", "useEffect", "useLayoutEffect", "useSyncExternalStore", "useSyncExternalStore", "React", "useSyncExternalStore", "useEffect", "useEffect", "count", "useState", "useState", "React", "useMemo", "useRef", "useRef", "resolveContainers", "useMemo", "React", "React", "createContext", "useContext", "React", "createContext", "useContext", "createContext", "useContext", "React", "React", "useRef", "useRef", "useRef", "useEffect", "useRef", "useRef", "useEffect", "useRef", "useRef", "FocusTrapFeatures", "useRef", "contains", "React", "activeElement", "React", "Fragment", "createContext", "useContext", "useEffect", "useMemo", "useRef", "useState", "createPortal", "useContext", "useState", "useEffect", "Fragment", "useRef", "ref", "createPortal", "createContext", "React", "useMemo", "reducers", "createContext", "useContext", "stateReducer", "useState", "useRef", "useReducer", "createRef", "id", "useCallback", "useEffect", "useMemo", "React", "count", "React", "Fragment", "createContext", "useContext", "useEffect", "useMemo", "useReducer", "useRef", "React", "startTransition", "reducers", "createContext", "useContext", "stateReducer", "Fragment", "useRef", "ref", "useReducer", "useMemo", "React", "DEFAULT_BUTTON_TAG", "ButtonFn", "useEffect", "DEFAULT_PANEL_TAG", "PanelFn", "React", "useMemo", "useMemo", "React", "React", "useMemo", "useMemo", "React", "useMemo", "DEFAULT_INPUT_TAG", "InputFn", "useMemo", "React", "React", "React", "Fragment", "createContext", "createRef", "useCallback", "useContext", "useEffect", "useMemo", "useReducer", "useRef", "useState", "useState", "useState", "useRef", "useRef", "useState", "size", "useState", "useRef", "labelledby", "label", "useRef", "React", "useCallback", "useMemo", "useRef", "useScrollLock", "useRef", "useCallback", "useScrollLock", "useMemo", "React", "adjustOrderedState", "reducers", "offset", "createContext", "useActions", "useContext", "useData", "stateReducer", "Fragment", "useReducer", "createRef", "useRef", "useCallback", "useMemo", "value", "React", "DEFAULT_BUTTON_TAG", "ButtonFn", "DEFAULT_OPTIONS_TAG", "OptionsRenderFeatures", "OptionsFn", "useEffect", "useState", "DEFAULT_OPTION_TAG", "OptionFn", "getTextValue", "React", "Fragment", "createContext", "createRef", "useContext", "useEffect", "useMemo", "useReducer", "useRef", "adjustOrderedState", "reducers", "offset", "createContext", "useContext", "stateReducer", "Fragment", "useReducer", "createRef", "useMemo", "React", "DEFAULT_BUTTON_TAG", "ButtonFn", "useEffect", "useRef", "getTextValue", "React", "Fragment", "createContext", "createRef", "useContext", "useEffect", "useMemo", "useReducer", "useRef", "useState", "reducers", "createContext", "useContext", "stateReducer", "useRef", "ref", "useReducer", "createRef", "useMemo", "root", "useEffect", "React", "DEFAULT_BUTTON_TAG", "ButtonFn", "useState", "el", "DEFAULT_OVERLAY_TAG", "OverlayFn", "DEFAULT_PANEL_TAG", "PanelRenderFeatures", "PanelFn", "activeElement", "idx", "Fragment", "DEFAULT_GROUP_TAG", "GroupFn", "React", "createContext", "useCallback", "useContext", "useMemo", "useReducer", "useRef", "reducers", "createContext", "useData", "useContext", "useActions", "stateReducer", "useReducer", "useRef", "useMemo", "useCallback", "React", "DEFAULT_OPTION_TAG", "OptionFn", "useMemo", "useMemo", "React", "Fragment", "createContext", "useCallback", "useContext", "useMemo", "useRef", "useState", "createContext", "DEFAULT_GROUP_TAG", "Fragment", "GroupFn", "useState", "useMemo", "React", "useContext", "useRef", "useCallback", "React", "Fragment", "createContext", "useContext", "useMemo", "useReducer", "useRef", "React", "useState", "useState", "React", "React", "index", "renders", "reducers", "createContext", "useData", "useContext", "useActions", "stateReducer", "Fragment", "GroupFn", "useReducer", "useMemo", "index", "React", "useRef", "DEFAULT_PANEL_TAG", "PanelRenderFeatures", "PanelFn", "useMemo", "useMemo", "React", "Fragment", "createContext", "useContext", "useEffect", "useMemo", "useRef", "useState", "useCallback", "useState", "useState", "useCallback", "flags", "d", "event", "createContext", "useContext", "createContext", "useRef", "_container", "useMemo", "useEffect", "useState", "React", "Fragment"]
}
