export default SpringSystem;
/**
 * A set of Springs that all run on the same physics
 * timing loop. To get started with a Rebound animation, first
 * create a new SpringSystem and then add springs to it.
 * @public
 */
declare class SpringSystem {
    constructor(looper: any);
    looper: any;
    listeners: any[];
    _activeSprings: any[];
    _idleSpringIndices: any[];
    _isIdle: boolean;
    _lastTimeMillis: number;
    _springRegistry: {};
    /**
     * Add a new spring to this SpringSystem. This Spring will now be solved for
     * during the physics iteration loop. By default the spring will use the
     * default Origami spring config with 40 tension and 7 friction, but you can
     * also provide your own values here.
     * @public
     */
    public createSpring(tension: any, friction: any): Spring;
    /**
     * Add a spring with the provided SpringConfig.
     * @public
     */
    public createSpringWithConfig(springConfig: any): Spring;
    /**
     * Check if a SpringSystem is idle or active. If all of the Springs in the
     * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,
     * then this method will return true.
     * @public
     */
    public getIsIdle(): boolean;
    /**
     * Manually add a spring to this system. This is called automatically
     * if a Spring is created with SpringSystem#createSpring.
     *
     * This method sets the spring up in the registry so that it can be solved
     * in the solver loop.
     * @public
     */
    public registerSpring(spring: any): void;
    /**
     * Deregister a spring with this SpringSystem. The SpringSystem will
     * no longer consider this Spring during its integration loop once
     * this is called. This is normally done automatically for you when
     * you call Spring#destroy.
     * @public
     */
    public deregisterSpring(spring: any): void;
    advance(time: any, deltaTime: any): void;
    /**
     * This is the main solver loop called to move the simulation
     * forward through time. Before each pass in the solver loop
     * onBeforeIntegrate is called on an any listeners that have
     * registered themeselves with the SpringSystem. This gives you
     * an opportunity to apply any constraints or adjustments to
     * the springs that should be enforced before each iteration
     * loop. Next the advance method is called to move each Spring in
     * the systemShouldAdvance forward to the current time. After the
     * integration step runs in advance, onAfterIntegrate is called
     * on any listeners that have registered themselves with the
     * SpringSystem. This gives you an opportunity to run any post
     * integration constraints or adjustments on the Springs in the
     * SpringSystem.
     * @public
     */
    public loop(currentTimeMillis: any): void;
    /**
     * Used to notify the SpringSystem that a Spring has become displaced.
     * The system responds by starting its solver loop up if it is currently idle.
     */
    activateSpring(springId: any): void;
}
import Spring from "./Spring";
