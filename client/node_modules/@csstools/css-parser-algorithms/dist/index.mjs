import{TokenType as e,isToken as n,stringify as t,mirrorVariant as o,ParseError as s,mirrorVariantType as i}from"@csstools/css-tokenizer";var r;function walkerIndexGenerator(e){let n=e.slice();return(e,t,o)=>{let s=-1;for(let i=n.indexOf(t);i<n.length&&(s=e.indexOf(n[i]),-1===s||s<o);i++);return-1===s||s===o&&t===e[o]&&(s++,s>=e.length)?-1:(n=e.slice(),s)}}function consumeComponentValue(n,t){const o=t[0];if(o[0]===e.OpenParen||o[0]===e.OpenCurly||o[0]===e.OpenSquare){const e=consumeSimpleBlock(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Function){const e=consumeFunction(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Whitespace){const e=consumeWhitespace(n,t);return{advance:e.advance,node:e.node}}if(o[0]===e.Comment){const e=consumeComment(n,t);return{advance:e.advance,node:e.node}}return{advance:1,node:new TokenNode(o)}}!function(e){e.Function="function",e.SimpleBlock="simple-block",e.Whitespace="whitespace",e.Comment="comment",e.Token="token"}(r||(r={}));class ContainerNodeBaseClass{value=[];indexOf(e){return this.value.indexOf(e)}at(e){if("number"==typeof e)return e<0&&(e=this.value.length+e),this.value[e]}forEach(e,n){if(0===this.value.length)return;const t=walkerIndexGenerator(this.value);let o=0;for(;o<this.value.length;){const s=this.value[o];let i;if(n&&(i={...n}),!1===e({node:s,parent:this,state:i},o))return!1;if(o=t(this.value,s,o),-1===o)break}}walk(e,n){0!==this.value.length&&this.forEach(((n,t)=>!1!==e(n,t)&&((!("walk"in n.node)||!this.value.includes(n.node)||!1!==n.node.walk(e,n.state))&&void 0)),n)}}class FunctionNode extends ContainerNodeBaseClass{type=r.Function;name;endToken;constructor(e,n,t){super(),this.name=e,this.endToken=n,this.value=t}getName(){return this.name[4].value}normalize(){this.endToken[0]===e.EOF&&(this.endToken=[e.CloseParen,")",-1,-1,void 0])}tokens(){return this.endToken[0]===e.EOF?[this.name,...this.value.flatMap((e=>e.tokens()))]:[this.name,...this.value.flatMap((e=>e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?t(e):e.toString())).join("");return t(this.name)+e+t(this.endToken)}toJSON(){return{type:this.type,name:this.getName(),tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isFunctionNode(){return FunctionNode.isFunctionNode(this)}static isFunctionNode(e){return!!e&&(e instanceof FunctionNode&&e.type===r.Function)}}function consumeFunction(n,t){const o=[];let i=1;for(;;){const r=t[i];if(!r||r[0]===e.EOF)return n.onParseError(new s("Unexpected EOF while consuming a function.",t[0][2],t[t.length-1][3],["5.4.9. Consume a function","Unexpected EOF"])),{advance:t.length,node:new FunctionNode(t[0],r,o)};if(r[0]===e.CloseParen)return{advance:i+1,node:new FunctionNode(t[0],r,o)};if(r[0]===e.Comment||r[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,t.slice(i));i+=e.advance,o.push(...e.nodes);continue}const a=consumeComponentValue(n,t.slice(i));i+=a.advance,o.push(a.node)}}class SimpleBlockNode extends ContainerNodeBaseClass{type=r.SimpleBlock;startToken;endToken;constructor(e,n,t){super(),this.startToken=e,this.endToken=n,this.value=t}normalize(){if(this.endToken[0]===e.EOF){const e=o(this.startToken);e&&(this.endToken=e)}}tokens(){return this.endToken[0]===e.EOF?[this.startToken,...this.value.flatMap((e=>e.tokens()))]:[this.startToken,...this.value.flatMap((e=>e.tokens())),this.endToken]}toString(){const e=this.value.map((e=>n(e)?t(e):e.toString())).join("");return t(this.startToken)+e+t(this.endToken)}toJSON(){return{type:this.type,startToken:this.startToken,tokens:this.tokens(),value:this.value.map((e=>e.toJSON()))}}isSimpleBlockNode(){return SimpleBlockNode.isSimpleBlockNode(this)}static isSimpleBlockNode(e){return!!e&&(e instanceof SimpleBlockNode&&e.type===r.SimpleBlock)}}function consumeSimpleBlock(n,t){const o=i(t[0][0]);if(!o)throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");const r=[];let a=1;for(;;){const i=t[a];if(!i||i[0]===e.EOF)return n.onParseError(new s("Unexpected EOF while consuming a simple block.",t[0][2],t[t.length-1][3],["5.4.8. Consume a simple block","Unexpected EOF"])),{advance:t.length,node:new SimpleBlockNode(t[0],i,r)};if(i[0]===o)return{advance:a+1,node:new SimpleBlockNode(t[0],i,r)};if(i[0]===e.Comment||i[0]===e.Whitespace){const e=consumeAllCommentsAndWhitespace(n,t.slice(a));a+=e.advance,r.push(...e.nodes);continue}const c=consumeComponentValue(n,t.slice(a));a+=c.advance,r.push(c.node)}}class WhitespaceNode{type=r.Whitespace;value;constructor(e){this.value=e}tokens(){return this.value}toString(){return t(...this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isWhitespaceNode(){return WhitespaceNode.isWhitespaceNode(this)}static isWhitespaceNode(e){return!!e&&(e instanceof WhitespaceNode&&e.type===r.Whitespace)}}function consumeWhitespace(n,t){let o=0;for(;;){if(t[o][0]!==e.Whitespace)return{advance:o,node:new WhitespaceNode(t.slice(0,o))};o++}}class CommentNode{type=r.Comment;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return t(this.value)}toJSON(){return{type:this.type,tokens:this.tokens()}}isCommentNode(){return CommentNode.isCommentNode(this)}static isCommentNode(e){return!!e&&(e instanceof CommentNode&&e.type===r.Comment)}}function consumeComment(e,n){return{advance:1,node:new CommentNode(n[0])}}function consumeAllCommentsAndWhitespace(n,t){const o=[];let s=0;for(;;)if(t[s][0]!==e.Whitespace){if(t[s][0]!==e.Comment)return{advance:s,nodes:o};o.push(new CommentNode(t[s])),s++}else{const e=consumeWhitespace(0,t.slice(s));s+=e.advance,o.push(e.node)}}class TokenNode{type=r.Token;value;constructor(e){this.value=e}tokens(){return[this.value]}toString(){return this.value[1]}toJSON(){return{type:this.type,tokens:this.tokens()}}isTokenNode(){return TokenNode.isTokenNode(this)}static isTokenNode(e){return!!e&&(e instanceof TokenNode&&e.type===r.Token)}}function parseComponentValue(n,t){const o={onParseError:t?.onParseError??(()=>{})},i=[...n];i[i.length-1][0]!==e.EOF&&i.push([e.EOF,"",i[i.length-1][2],i[i.length-1][3],void 0]);const r=consumeComponentValue(o,i);if(i[Math.min(r.advance,i.length-1)][0]===e.EOF)return r.node;o.onParseError(new s("Expected EOF after parsing a component value.",n[0][2],n[n.length-1][3],["5.3.9. Parse a component value","Expected EOF"]))}function parseListOfComponentValues(n,t){const o={onParseError:t?.onParseError??(()=>{})},s=[...n];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let r=0;for(;;){if(!s[r]||s[r][0]===e.EOF)return i;const n=consumeComponentValue(o,s.slice(r));i.push(n.node),r+=n.advance}}function parseCommaSeparatedListOfComponentValues(n,t){const o={onParseError:t?.onParseError??(()=>{})},s=[...n];if(0===n.length)return[];s[s.length-1][0]!==e.EOF&&s.push([e.EOF,"",s[s.length-1][2],s[s.length-1][3],void 0]);const i=[];let r=[],a=0;for(;;){if(!s[a]||s[a][0]===e.EOF)return r.length&&i.push(r),i;if(s[a][0]===e.Comma){i.push(r),r=[],a++;continue}const t=consumeComponentValue(o,n.slice(a));r.push(t.node),a+=t.advance}}function gatherNodeAncestry(e){const n=new Map;return e.walk((e=>{Array.isArray(e.node)?e.node.forEach((t=>{n.set(t,e.parent)})):n.set(e.node,e.parent)})),n}function forEach(e,n,t){if(0===e.length)return;const o=walkerIndexGenerator(e);let s=0;for(;s<e.length;){const i=e[s];let r;if(t&&(r={...t}),!1===n({node:i,parent:{value:e},state:r},s))return!1;if(s=o(e,i,s),-1===s)break}}function walk(e,n,t){0!==e.length&&forEach(e,((t,o)=>!1!==n(t,o)&&((!("walk"in t.node)||!e.includes(t.node)||!1!==t.node.walk(n,t.state))&&void 0)),t)}function replaceComponentValues(e,n){for(let t=0;t<e.length;t++){walk(e[t],((e,t)=>{if("number"!=typeof t)return;const o=n(e.node);o&&e.parent.value.splice(t,1,o)}))}return e}function stringify(e){return e.map((e=>e.map((e=>t(...e.tokens()))).join(""))).join(",")}function isSimpleBlockNode(e){return SimpleBlockNode.isSimpleBlockNode(e)}function isFunctionNode(e){return FunctionNode.isFunctionNode(e)}function isWhitespaceNode(e){return WhitespaceNode.isWhitespaceNode(e)}function isCommentNode(e){return CommentNode.isCommentNode(e)}function isTokenNode(e){return TokenNode.isTokenNode(e)}function sourceIndices(e){if(Array.isArray(e)){const n=e[0];if(!n)return[0,0];const t=e[e.length-1]||n;return[sourceIndices(n)[0],sourceIndices(t)[1]]}const n=e.tokens(),t=n[0],o=n[n.length-1];return t&&o?[t[2],o[3]]:[0,0]}export{CommentNode,r as ComponentValueType,ContainerNodeBaseClass,FunctionNode,SimpleBlockNode,TokenNode,WhitespaceNode,forEach,gatherNodeAncestry,isCommentNode,isFunctionNode,isSimpleBlockNode,isTokenNode,isWhitespaceNode,parseCommaSeparatedListOfComponentValues,parseComponentValue,parseListOfComponentValues,replaceComponentValues,sourceIndices,stringify,walk,walkerIndexGenerator};
